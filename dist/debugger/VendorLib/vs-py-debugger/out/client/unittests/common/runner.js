"use strict";

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const inversify_1 = require("inversify");

const path = require("path");

const configSettings_1 = require("../../common/configSettings");

const errorUtils_1 = require("../../common/errors/errorUtils");

const moduleNotInstalledError_1 = require("../../common/errors/moduleNotInstalledError");

const types_1 = require("../../common/process/types");

const types_2 = require("../../ioc/types");

const constants_1 = require("./constants");

const types_3 = require("./types");

let TestRunner = class TestRunner {
  constructor(serviceContainer) {
    this.serviceContainer = serviceContainer;
  }

  run(testProvider, options) {
    return run(this.serviceContainer, testProvider, options);
  }

};
TestRunner = __decorate([inversify_1.injectable(), __param(0, inversify_1.inject(types_2.IServiceContainer))], TestRunner);
exports.TestRunner = TestRunner;

function run(serviceContainer, testProvider, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const testExecutablePath = getExecutablePath(testProvider, configSettings_1.PythonSettings.getInstance(options.workspaceFolder));
    const moduleName = getTestModuleName(testProvider);
    const spawnOptions = options;
    let pythonExecutionServicePromise;
    spawnOptions.mergeStdOutErr = typeof spawnOptions.mergeStdOutErr === 'boolean' ? spawnOptions.mergeStdOutErr : true;
    let promise;

    if (!testExecutablePath && testProvider === constants_1.UNITTEST_PROVIDER) {
      // Unit tests have a special way of being executed
      const pythonServiceFactory = serviceContainer.get(types_1.IPythonExecutionFactory);
      pythonExecutionServicePromise = pythonServiceFactory.create({
        resource: options.workspaceFolder
      });
      promise = pythonExecutionServicePromise.then(executionService => executionService.execObservable(options.args, Object.assign({}, spawnOptions)));
    } else {
      const pythonToolsExecutionService = serviceContainer.get(types_1.IPythonToolExecutionService);
      const testHelper = serviceContainer.get(types_3.ITestsHelper);
      const executionInfo = {
        execPath: testExecutablePath,
        args: options.args,
        moduleName: testExecutablePath && testExecutablePath.length > 0 ? undefined : moduleName,
        product: testHelper.parseProduct(testProvider)
      };
      promise = pythonToolsExecutionService.execObservable(executionInfo, spawnOptions, options.workspaceFolder);
    }

    return promise.then(result => {
      return new Promise((resolve, reject) => {
        let stdOut = '';
        let stdErr = '';
        result.out.subscribe(output => {
          stdOut += output.out; // If the test runner python module is not installed we'll have something in stderr.
          // Hence track that separately and check at the end.

          if (output.source === 'stderr') {
            stdErr += output.out;
          }

          if (options.outChannel) {
            options.outChannel.append(output.out);
          }
        }, reject, () => __awaiter(this, void 0, void 0, function* () {
          // If the test runner python module is not installed we'll have something in stderr.
          if (moduleName && pythonExecutionServicePromise && errorUtils_1.ErrorUtils.outputHasModuleNotInstalledError(moduleName, stdErr)) {
            const pythonExecutionService = yield pythonExecutionServicePromise;
            const isInstalled = yield pythonExecutionService.isModuleInstalled(moduleName);

            if (!isInstalled) {
              return reject(new moduleNotInstalledError_1.ModuleNotInstalledError(moduleName));
            }
          }

          resolve(stdOut);
        }));
      });
    });
  });
}

exports.run = run;

function getExecutablePath(testProvider, settings) {
  let testRunnerExecutablePath;

  switch (testProvider) {
    case constants_1.NOSETEST_PROVIDER:
      {
        testRunnerExecutablePath = settings.unitTest.nosetestPath;
        break;
      }

    case constants_1.PYTEST_PROVIDER:
      {
        testRunnerExecutablePath = settings.unitTest.pyTestPath;
        break;
      }

    default:
      {
        return undefined;
      }
  }

  return path.basename(testRunnerExecutablePath) === testRunnerExecutablePath ? undefined : testRunnerExecutablePath;
}

function getTestModuleName(testProvider) {
  switch (testProvider) {
    case constants_1.NOSETEST_PROVIDER:
      {
        return 'nose';
      }

    case constants_1.PYTEST_PROVIDER:
      {
        return 'pytest';
      }

    case constants_1.UNITTEST_PROVIDER:
      {
        return 'unittest';
      }

    default:
      {
        throw new Error(`Test provider '${testProvider}' not supported`);
      }
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJ1bm5lci5qcyJdLCJuYW1lcyI6WyJfX2RlY29yYXRlIiwiZGVjb3JhdG9ycyIsInRhcmdldCIsImtleSIsImRlc2MiLCJjIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiciIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImQiLCJSZWZsZWN0IiwiZGVjb3JhdGUiLCJpIiwiZGVmaW5lUHJvcGVydHkiLCJfX3BhcmFtIiwicGFyYW1JbmRleCIsImRlY29yYXRvciIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJleHBvcnRzIiwiaW52ZXJzaWZ5XzEiLCJyZXF1aXJlIiwicGF0aCIsImNvbmZpZ1NldHRpbmdzXzEiLCJlcnJvclV0aWxzXzEiLCJtb2R1bGVOb3RJbnN0YWxsZWRFcnJvcl8xIiwidHlwZXNfMSIsInR5cGVzXzIiLCJjb25zdGFudHNfMSIsInR5cGVzXzMiLCJUZXN0UnVubmVyIiwiY29uc3RydWN0b3IiLCJzZXJ2aWNlQ29udGFpbmVyIiwicnVuIiwidGVzdFByb3ZpZGVyIiwib3B0aW9ucyIsImluamVjdGFibGUiLCJpbmplY3QiLCJJU2VydmljZUNvbnRhaW5lciIsInRlc3RFeGVjdXRhYmxlUGF0aCIsImdldEV4ZWN1dGFibGVQYXRoIiwiUHl0aG9uU2V0dGluZ3MiLCJnZXRJbnN0YW5jZSIsIndvcmtzcGFjZUZvbGRlciIsIm1vZHVsZU5hbWUiLCJnZXRUZXN0TW9kdWxlTmFtZSIsInNwYXduT3B0aW9ucyIsInB5dGhvbkV4ZWN1dGlvblNlcnZpY2VQcm9taXNlIiwibWVyZ2VTdGRPdXRFcnIiLCJwcm9taXNlIiwiVU5JVFRFU1RfUFJPVklERVIiLCJweXRob25TZXJ2aWNlRmFjdG9yeSIsImdldCIsIklQeXRob25FeGVjdXRpb25GYWN0b3J5IiwiY3JlYXRlIiwicmVzb3VyY2UiLCJleGVjdXRpb25TZXJ2aWNlIiwiZXhlY09ic2VydmFibGUiLCJhcmdzIiwiYXNzaWduIiwicHl0aG9uVG9vbHNFeGVjdXRpb25TZXJ2aWNlIiwiSVB5dGhvblRvb2xFeGVjdXRpb25TZXJ2aWNlIiwidGVzdEhlbHBlciIsIklUZXN0c0hlbHBlciIsImV4ZWN1dGlvbkluZm8iLCJleGVjUGF0aCIsInVuZGVmaW5lZCIsInByb2R1Y3QiLCJwYXJzZVByb2R1Y3QiLCJzdGRPdXQiLCJzdGRFcnIiLCJvdXQiLCJzdWJzY3JpYmUiLCJvdXRwdXQiLCJzb3VyY2UiLCJvdXRDaGFubmVsIiwiYXBwZW5kIiwiRXJyb3JVdGlscyIsIm91dHB1dEhhc01vZHVsZU5vdEluc3RhbGxlZEVycm9yIiwicHl0aG9uRXhlY3V0aW9uU2VydmljZSIsImlzSW5zdGFsbGVkIiwiaXNNb2R1bGVJbnN0YWxsZWQiLCJNb2R1bGVOb3RJbnN0YWxsZWRFcnJvciIsInNldHRpbmdzIiwidGVzdFJ1bm5lckV4ZWN1dGFibGVQYXRoIiwiTk9TRVRFU1RfUFJPVklERVIiLCJ1bml0VGVzdCIsIm5vc2V0ZXN0UGF0aCIsIlBZVEVTVF9QUk9WSURFUiIsInB5VGVzdFBhdGgiLCJiYXNlbmFtZSIsIkVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxVQUFVLEdBQUksVUFBUSxTQUFLQSxVQUFkLElBQTZCLFVBQVVDLFVBQVYsRUFBc0JDLE1BQXRCLEVBQThCQyxHQUE5QixFQUFtQ0MsSUFBbkMsRUFBeUM7QUFDbkYsTUFBSUMsQ0FBQyxHQUFHQyxTQUFTLENBQUNDLE1BQWxCO0FBQUEsTUFBMEJDLENBQUMsR0FBR0gsQ0FBQyxHQUFHLENBQUosR0FBUUgsTUFBUixHQUFpQkUsSUFBSSxLQUFLLElBQVQsR0FBZ0JBLElBQUksR0FBR0ssTUFBTSxDQUFDQyx3QkFBUCxDQUFnQ1IsTUFBaEMsRUFBd0NDLEdBQXhDLENBQXZC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RCxXQUFXLENBQUM0RCxlQUFqQjtBQUFrQztBQUM5QkosUUFBQUEsd0JBQXdCLEdBQUdELFFBQVEsQ0FBQ0csUUFBVCxDQUFrQkcsVUFBN0M7QUFDQTtBQUNIOztBQUNEO0FBQVM7QUFDTCxlQUFPdkIsU0FBUDtBQUNIO0FBWEw7O0FBYUEsU0FBTzVDLElBQUksQ0FBQ29FLFFBQUwsQ0FBY04sd0JBQWQsTUFBNENBLHdCQUE1QyxHQUF1RWxCLFNBQXZFLEdBQW1Ga0Isd0JBQTFGO0FBQ0g7O0FBQ0QsU0FBU3ZDLGlCQUFULENBQTJCWCxZQUEzQixFQUF5QztBQUNyQyxVQUFRQSxZQUFSO0FBQ0ksU0FBS04sV0FBVyxDQUFDeUQsaUJBQWpCO0FBQW9DO0FBQ2hDLGVBQU8sTUFBUDtBQUNIOztBQUNELFNBQUt6RCxXQUFXLENBQUM0RCxlQUFqQjtBQUFrQztBQUM5QixlQUFPLFFBQVA7QUFDSDs7QUFDRCxTQUFLNUQsV0FBVyxDQUFDc0IsaUJBQWpCO0FBQW9DO0FBQ2hDLGVBQU8sVUFBUDtBQUNIOztBQUNEO0FBQVM7QUFDTCxjQUFNLElBQUl5QyxLQUFKLENBQVcsa0JBQWlCekQsWUFBYSxpQkFBekMsQ0FBTjtBQUNIO0FBWkw7QUFjSCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgaW52ZXJzaWZ5XzEgPSByZXF1aXJlKFwiaW52ZXJzaWZ5XCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IGNvbmZpZ1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2NvbmZpZ1NldHRpbmdzXCIpO1xyXG5jb25zdCBlcnJvclV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2Vycm9ycy9lcnJvclV0aWxzXCIpO1xyXG5jb25zdCBtb2R1bGVOb3RJbnN0YWxsZWRFcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9lcnJvcnMvbW9kdWxlTm90SW5zdGFsbGVkRXJyb3JcIik7XHJcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL3Byb2Nlc3MvdHlwZXNcIik7XHJcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vaW9jL3R5cGVzXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgdHlwZXNfMyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xyXG5sZXQgVGVzdFJ1bm5lciA9IGNsYXNzIFRlc3RSdW5uZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc2VydmljZUNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMuc2VydmljZUNvbnRhaW5lciA9IHNlcnZpY2VDb250YWluZXI7XHJcbiAgICB9XHJcbiAgICBydW4odGVzdFByb3ZpZGVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHJ1bih0aGlzLnNlcnZpY2VDb250YWluZXIsIHRlc3RQcm92aWRlciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbn07XHJcblRlc3RSdW5uZXIgPSBfX2RlY29yYXRlKFtcclxuICAgIGludmVyc2lmeV8xLmluamVjdGFibGUoKSxcclxuICAgIF9fcGFyYW0oMCwgaW52ZXJzaWZ5XzEuaW5qZWN0KHR5cGVzXzIuSVNlcnZpY2VDb250YWluZXIpKVxyXG5dLCBUZXN0UnVubmVyKTtcclxuZXhwb3J0cy5UZXN0UnVubmVyID0gVGVzdFJ1bm5lcjtcclxuZnVuY3Rpb24gcnVuKHNlcnZpY2VDb250YWluZXIsIHRlc3RQcm92aWRlciwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCB0ZXN0RXhlY3V0YWJsZVBhdGggPSBnZXRFeGVjdXRhYmxlUGF0aCh0ZXN0UHJvdmlkZXIsIGNvbmZpZ1NldHRpbmdzXzEuUHl0aG9uU2V0dGluZ3MuZ2V0SW5zdGFuY2Uob3B0aW9ucy53b3Jrc3BhY2VGb2xkZXIpKTtcclxuICAgICAgICBjb25zdCBtb2R1bGVOYW1lID0gZ2V0VGVzdE1vZHVsZU5hbWUodGVzdFByb3ZpZGVyKTtcclxuICAgICAgICBjb25zdCBzcGF3bk9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIGxldCBweXRob25FeGVjdXRpb25TZXJ2aWNlUHJvbWlzZTtcclxuICAgICAgICBzcGF3bk9wdGlvbnMubWVyZ2VTdGRPdXRFcnIgPSB0eXBlb2Ygc3Bhd25PcHRpb25zLm1lcmdlU3RkT3V0RXJyID09PSAnYm9vbGVhbicgPyBzcGF3bk9wdGlvbnMubWVyZ2VTdGRPdXRFcnIgOiB0cnVlO1xyXG4gICAgICAgIGxldCBwcm9taXNlO1xyXG4gICAgICAgIGlmICghdGVzdEV4ZWN1dGFibGVQYXRoICYmIHRlc3RQcm92aWRlciA9PT0gY29uc3RhbnRzXzEuVU5JVFRFU1RfUFJPVklERVIpIHtcclxuICAgICAgICAgICAgLy8gVW5pdCB0ZXN0cyBoYXZlIGEgc3BlY2lhbCB3YXkgb2YgYmVpbmcgZXhlY3V0ZWRcclxuICAgICAgICAgICAgY29uc3QgcHl0aG9uU2VydmljZUZhY3RvcnkgPSBzZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18xLklQeXRob25FeGVjdXRpb25GYWN0b3J5KTtcclxuICAgICAgICAgICAgcHl0aG9uRXhlY3V0aW9uU2VydmljZVByb21pc2UgPSBweXRob25TZXJ2aWNlRmFjdG9yeS5jcmVhdGUoeyByZXNvdXJjZTogb3B0aW9ucy53b3Jrc3BhY2VGb2xkZXIgfSk7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBweXRob25FeGVjdXRpb25TZXJ2aWNlUHJvbWlzZS50aGVuKGV4ZWN1dGlvblNlcnZpY2UgPT4gZXhlY3V0aW9uU2VydmljZS5leGVjT2JzZXJ2YWJsZShvcHRpb25zLmFyZ3MsIE9iamVjdC5hc3NpZ24oe30sIHNwYXduT3B0aW9ucykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB5dGhvblRvb2xzRXhlY3V0aW9uU2VydmljZSA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSVB5dGhvblRvb2xFeGVjdXRpb25TZXJ2aWNlKTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdEhlbHBlciA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzMuSVRlc3RzSGVscGVyKTtcclxuICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGV4ZWNQYXRoOiB0ZXN0RXhlY3V0YWJsZVBhdGgsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBvcHRpb25zLmFyZ3MsXHJcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiB0ZXN0RXhlY3V0YWJsZVBhdGggJiYgdGVzdEV4ZWN1dGFibGVQYXRoLmxlbmd0aCA+IDAgPyB1bmRlZmluZWQgOiBtb2R1bGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgcHJvZHVjdDogdGVzdEhlbHBlci5wYXJzZVByb2R1Y3QodGVzdFByb3ZpZGVyKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBwcm9taXNlID0gcHl0aG9uVG9vbHNFeGVjdXRpb25TZXJ2aWNlLmV4ZWNPYnNlcnZhYmxlKGV4ZWN1dGlvbkluZm8sIHNwYXduT3B0aW9ucywgb3B0aW9ucy53b3Jrc3BhY2VGb2xkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RkT3V0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RkRXJyID0gJyc7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQub3V0LnN1YnNjcmliZShvdXRwdXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZE91dCArPSBvdXRwdXQub3V0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0ZXN0IHJ1bm5lciBweXRob24gbW9kdWxlIGlzIG5vdCBpbnN0YWxsZWQgd2UnbGwgaGF2ZSBzb21ldGhpbmcgaW4gc3RkZXJyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhlbmNlIHRyYWNrIHRoYXQgc2VwYXJhdGVseSBhbmQgY2hlY2sgYXQgdGhlIGVuZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0LnNvdXJjZSA9PT0gJ3N0ZGVycicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RkRXJyICs9IG91dHB1dC5vdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dENoYW5uZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vdXRDaGFubmVsLmFwcGVuZChvdXRwdXQub3V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCByZWplY3QsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGVzdCBydW5uZXIgcHl0aG9uIG1vZHVsZSBpcyBub3QgaW5zdGFsbGVkIHdlJ2xsIGhhdmUgc29tZXRoaW5nIGluIHN0ZGVyci5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlTmFtZSAmJiBweXRob25FeGVjdXRpb25TZXJ2aWNlUHJvbWlzZSAmJiBlcnJvclV0aWxzXzEuRXJyb3JVdGlscy5vdXRwdXRIYXNNb2R1bGVOb3RJbnN0YWxsZWRFcnJvcihtb2R1bGVOYW1lLCBzdGRFcnIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB5dGhvbkV4ZWN1dGlvblNlcnZpY2UgPSB5aWVsZCBweXRob25FeGVjdXRpb25TZXJ2aWNlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJbnN0YWxsZWQgPSB5aWVsZCBweXRob25FeGVjdXRpb25TZXJ2aWNlLmlzTW9kdWxlSW5zdGFsbGVkKG1vZHVsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW5zdGFsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBtb2R1bGVOb3RJbnN0YWxsZWRFcnJvcl8xLk1vZHVsZU5vdEluc3RhbGxlZEVycm9yKG1vZHVsZU5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0ZE91dCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5ydW4gPSBydW47XHJcbmZ1bmN0aW9uIGdldEV4ZWN1dGFibGVQYXRoKHRlc3RQcm92aWRlciwgc2V0dGluZ3MpIHtcclxuICAgIGxldCB0ZXN0UnVubmVyRXhlY3V0YWJsZVBhdGg7XHJcbiAgICBzd2l0Y2ggKHRlc3RQcm92aWRlcikge1xyXG4gICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTk9TRVRFU1RfUFJPVklERVI6IHtcclxuICAgICAgICAgICAgdGVzdFJ1bm5lckV4ZWN1dGFibGVQYXRoID0gc2V0dGluZ3MudW5pdFRlc3Qubm9zZXRlc3RQYXRoO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBjb25zdGFudHNfMS5QWVRFU1RfUFJPVklERVI6IHtcclxuICAgICAgICAgICAgdGVzdFJ1bm5lckV4ZWN1dGFibGVQYXRoID0gc2V0dGluZ3MudW5pdFRlc3QucHlUZXN0UGF0aDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aC5iYXNlbmFtZSh0ZXN0UnVubmVyRXhlY3V0YWJsZVBhdGgpID09PSB0ZXN0UnVubmVyRXhlY3V0YWJsZVBhdGggPyB1bmRlZmluZWQgOiB0ZXN0UnVubmVyRXhlY3V0YWJsZVBhdGg7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGVzdE1vZHVsZU5hbWUodGVzdFByb3ZpZGVyKSB7XHJcbiAgICBzd2l0Y2ggKHRlc3RQcm92aWRlcikge1xyXG4gICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTk9TRVRFU1RfUFJPVklERVI6IHtcclxuICAgICAgICAgICAgcmV0dXJuICdub3NlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBjb25zdGFudHNfMS5QWVRFU1RfUFJPVklERVI6IHtcclxuICAgICAgICAgICAgcmV0dXJuICdweXRlc3QnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGNvbnN0YW50c18xLlVOSVRURVNUX1BST1ZJREVSOiB7XHJcbiAgICAgICAgICAgIHJldHVybiAndW5pdHRlc3QnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVzdCBwcm92aWRlciAnJHt0ZXN0UHJvdmlkZXJ9JyBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bm5lci5qcy5tYXAiXX0=