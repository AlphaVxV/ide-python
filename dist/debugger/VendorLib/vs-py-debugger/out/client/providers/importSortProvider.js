"use strict";

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const inversify_1 = require("inversify");

const os_1 = require("os");

const path = require("path");

const vscode_1 = require("vscode");

const types_1 = require("../common/application/types");

const constants_1 = require("../common/constants");

const types_2 = require("../common/platform/types");

const types_3 = require("../common/process/types");

const types_4 = require("../common/types");

const misc_1 = require("../common/utils/misc");

const types_5 = require("../ioc/types");

const telemetry_1 = require("../telemetry");

const constants_2 = require("../telemetry/constants");

let SortImportsEditingProvider = class SortImportsEditingProvider {
  constructor(serviceContainer) {
    this.serviceContainer = serviceContainer;
    this.shell = serviceContainer.get(types_1.IApplicationShell);
    this.documentManager = serviceContainer.get(types_1.IDocumentManager);
    this.configurationService = serviceContainer.get(types_4.IConfigurationService);
    this.pythonExecutionFactory = serviceContainer.get(types_3.IPythonExecutionFactory);
    this.processServiceFactory = serviceContainer.get(types_3.IProcessServiceFactory);
    this.editorUtils = serviceContainer.get(types_4.IEditorUtils);
  }

  provideDocumentSortImportsEdits(uri, token) {
    return __awaiter(this, void 0, void 0, function* () {
      const document = yield this.documentManager.openTextDocument(uri);

      if (!document) {
        return;
      }

      if (document.lineCount <= 1) {
        return;
      } // isort does have the ability to read from the process input stream and return the formatted code out of the output stream.
      // However they don't support returning the diff of the formatted text when reading data from the input stream.
      // Yes getting text formatted that way avoids having to create a temporary file, however the diffing will have
      // to be done here in node (extension), i.e. extension cpu, i.e. less responsive solution.


      const importScript = path.join(constants_1.EXTENSION_ROOT_DIR, 'pythonFiles', 'sortImports.py');
      const fsService = this.serviceContainer.get(types_2.IFileSystem);
      const tmpFile = document.isDirty ? yield fsService.createTemporaryFile(path.extname(document.uri.fsPath)) : undefined;

      if (tmpFile) {
        yield fsService.writeFile(tmpFile.filePath, document.getText());
      }

      const settings = this.configurationService.getSettings(uri);
      const isort = settings.sortImports.path;
      const filePath = tmpFile ? tmpFile.filePath : document.uri.fsPath;
      const args = [filePath, '--diff'].concat(settings.sortImports.args);
      let diffPatch;

      if (token && token.isCancellationRequested) {
        return;
      }

      try {
        if (typeof isort === 'string' && isort.length > 0) {
          // Lets just treat this as a standard tool.
          const processService = yield this.processServiceFactory.create(document.uri);
          diffPatch = (yield processService.exec(isort, args, {
            throwOnStdErr: true,
            token
          })).stdout;
        } else {
          const processExeService = yield this.pythonExecutionFactory.create({
            resource: document.uri
          });
          diffPatch = (yield processExeService.exec([importScript].concat(args), {
            throwOnStdErr: true,
            token
          })).stdout;
        }

        return this.editorUtils.getWorkspaceEditsFromPatch(document.getText(), diffPatch, document.uri);
      } finally {
        if (tmpFile) {
          tmpFile.dispose();
        }
      }
    });
  }

  registerCommands() {
    const cmdManager = this.serviceContainer.get(types_1.ICommandManager);
    const disposable = cmdManager.registerCommand(constants_1.Commands.Sort_Imports, this.sortImports, this);
    this.serviceContainer.get(types_4.IDisposableRegistry).push(disposable);
  }

  sortImports(uri) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!uri) {
        const activeEditor = this.documentManager.activeTextEditor;

        if (!activeEditor || activeEditor.document.languageId !== constants_1.PYTHON_LANGUAGE) {
          this.shell.showErrorMessage('Please open a Python file to sort the imports.').then(misc_1.noop, misc_1.noop);
          return;
        }

        uri = activeEditor.document.uri;
      }

      const document = yield this.documentManager.openTextDocument(uri);

      if (document.lineCount <= 1) {
        return;
      } // Hack, if the document doesn't contain an empty line at the end, then add it
      // Else the library strips off the last line


      const lastLine = document.lineAt(document.lineCount - 1);

      if (lastLine.text.trim().length > 0) {
        const edit = new vscode_1.WorkspaceEdit();
        edit.insert(uri, lastLine.range.end, os_1.EOL);
        yield this.documentManager.applyEdit(edit);
      }

      try {
        const changes = yield this.provideDocumentSortImportsEdits(uri);

        if (!changes || changes.entries().length === 0) {
          return;
        }

        yield this.documentManager.applyEdit(changes);
      } catch (error) {
        const message = typeof error === 'string' ? error : error.message ? error.message : error;
        const outputChannel = this.serviceContainer.get(types_4.IOutputChannel, constants_1.STANDARD_OUTPUT_CHANNEL);
        outputChannel.appendLine(error);
        outputChannel.show();
        const logger = this.serviceContainer.get(types_4.ILogger);
        logger.logError(`Failed to format imports for '${uri.fsPath}'.`, error);
        this.shell.showErrorMessage(message).then(misc_1.noop, misc_1.noop);
      }
    });
  }

};

__decorate([telemetry_1.captureTelemetry(constants_2.FORMAT_SORT_IMPORTS)], SortImportsEditingProvider.prototype, "provideDocumentSortImportsEdits", null);

SortImportsEditingProvider = __decorate([inversify_1.injectable(), __param(0, inversify_1.inject(types_5.IServiceContainer))], SortImportsEditingProvider);
exports.SortImportsEditingProvider = SortImportsEditingProvider;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImltcG9ydFNvcnRQcm92aWRlci5qcyJdLCJuYW1lcyI6WyJfX2RlY29yYXRlIiwiZGVjb3JhdG9ycyIsInRhcmdldCIsImtleSIsImRlc2MiLCJjIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiciIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImQiLCJSZWZsZWN0IiwiZGVjb3JhdGUiLCJpIiwiZGVmaW5lUHJvcGVydHkiLCJfX3BhcmFtIiwicGFyYW1JbmRleCIsImRlY29yYXRvciIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJleHBvcnRzIiwiaW52ZXJzaWZ5XzEiLCJyZXF1aXJlIiwib3NfMSIsInBhdGgiLCJ2c2NvZGVfMSIsInR5cGVzXzEiLCJjb25zdGFudHNfMSIsInR5cGVzXzIiLCJ0eXBlc18zIiwidHlwZXNfNCIsIm1pc2NfMSIsInR5cGVzXzUiLCJ0ZWxlbWV0cnlfMSIsImNvbnN0YW50c18yIiwiU29ydEltcG9ydHNFZGl0aW5nUHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsInNlcnZpY2VDb250YWluZXIiLCJzaGVsbCIsImdldCIsIklBcHBsaWNhdGlvblNoZWxsIiwiZG9jdW1lbnRNYW5hZ2VyIiwiSURvY3VtZW50TWFuYWdlciIsImNvbmZpZ3VyYXRpb25TZXJ2aWNlIiwiSUNvbmZpZ3VyYXRpb25TZXJ2aWNlIiwicHl0aG9uRXhlY3V0aW9uRmFjdG9yeSIsIklQeXRob25FeGVjdXRpb25GYWN0b3J5IiwicHJvY2Vzc1NlcnZpY2VGYWN0b3J5IiwiSVByb2Nlc3NTZXJ2aWNlRmFjdG9yeSIsImVkaXRvclV0aWxzIiwiSUVkaXRvclV0aWxzIiwicHJvdmlkZURvY3VtZW50U29ydEltcG9ydHNFZGl0cyIsInVyaSIsInRva2VuIiwiZG9jdW1lbnQiLCJvcGVuVGV4dERvY3VtZW50IiwibGluZUNvdW50IiwiaW1wb3J0U2NyaXB0Iiwiam9pbiIsIkVYVEVOU0lPTl9ST09UX0RJUiIsImZzU2VydmljZSIsIklGaWxlU3lzdGVtIiwidG1wRmlsZSIsImlzRGlydHkiLCJjcmVhdGVUZW1wb3JhcnlGaWxlIiwiZXh0bmFtZSIsImZzUGF0aCIsInVuZGVmaW5lZCIsIndyaXRlRmlsZSIsImZpbGVQYXRoIiwiZ2V0VGV4dCIsInNldHRpbmdzIiwiZ2V0U2V0dGluZ3MiLCJpc29ydCIsInNvcnRJbXBvcnRzIiwiYXJncyIsImNvbmNhdCIsImRpZmZQYXRjaCIsImlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwicHJvY2Vzc1NlcnZpY2UiLCJjcmVhdGUiLCJleGVjIiwidGhyb3dPblN0ZEVyciIsInN0ZG91dCIsInByb2Nlc3NFeGVTZXJ2aWNlIiwicmVzb3VyY2UiLCJnZXRXb3Jrc3BhY2VFZGl0c0Zyb21QYXRjaCIsImRpc3Bvc2UiLCJyZWdpc3RlckNvbW1hbmRzIiwiY21kTWFuYWdlciIsIklDb21tYW5kTWFuYWdlciIsImRpc3Bvc2FibGUiLCJyZWdpc3RlckNvbW1hbmQiLCJDb21tYW5kcyIsIlNvcnRfSW1wb3J0cyIsIklEaXNwb3NhYmxlUmVnaXN0cnkiLCJwdXNoIiwiYWN0aXZlRWRpdG9yIiwiYWN0aXZlVGV4dEVkaXRvciIsImxhbmd1YWdlSWQiLCJQWVRIT05fTEFOR1VBR0UiLCJzaG93RXJyb3JNZXNzYWdlIiwibm9vcCIsImxhc3RMaW5lIiwibGluZUF0IiwidGV4dCIsInRyaW0iLCJlZGl0IiwiV29ya3NwYWNlRWRpdCIsImluc2VydCIsInJhbmdlIiwiZW5kIiwiRU9MIiwiYXBwbHlFZGl0IiwiY2hhbmdlcyIsImVudHJpZXMiLCJlcnJvciIsIm1lc3NhZ2UiLCJvdXRwdXRDaGFubmVsIiwiSU91dHB1dENoYW5uZWwiLCJTVEFOREFSRF9PVVRQVVRfQ0hBTk5FTCIsImFwcGVuZExpbmUiLCJzaG93IiwibG9nZ2VyIiwiSUxvZ2dlciIsImxvZ0Vycm9yIiwiY2FwdHVyZVRlbGVtZXRyeSIsIkZPUk1BVF9TT1JUX0lNUE9SVFMiLCJwcm90b3R5cGUiLCJpbmplY3RhYmxlIiwiaW5qZWN0IiwiSVNlcnZpY2VDb250YWluZXIiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFVBQVUsR0FBSSxVQUFRLFNBQUtBLFVBQWQsSUFBNkIsVUFBVUMsVUFBVixFQUFzQkMsTUFBdEIsRUFBOEJDLEdBQTlCLEVBQW1DQyxJQUFuQyxFQUF5QztBQUNuRixNQUFJQyxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBbEI7QUFBQSxNQUEwQkMsQ0FBQyxHQUFHSCxDQUFDLEdBQUcsQ0FBSixHQUFRSCxNQUFSLEdBQWlCRSxJQUFJLEtBQUssSUFBVCxHQUFnQkEsSUFBSSxHQUFHSyxNQUFNLENBQUNDLHdCQUFQLENBQWdDUixNQUFoQyxFQUF3Q0MsR0FBeEMsQ0FBdkIsR0FBc0VDLElBQXJIO0FBQUEsTUFBMkhPLENBQTNIO0FBQ0EsTUFBSSxPQUFPQyxPQUFQLEtBQW1CLFFBQW5CLElBQStCLE9BQU9BLE9BQU8sQ0FBQ0MsUUFBZixLQUE0QixVQUEvRCxFQUEyRUwsQ0FBQyxHQUFHSSxPQUFPLENBQUNDLFFBQVIsQ0FBaUJaLFVBQWpCLEVBQTZCQyxNQUE3QixFQUFxQ0MsR0FBckMsRUFBMENDLElBQTFDLENBQUosQ0FBM0UsS0FDSyxLQUFLLElBQUlVLENBQUMsR0FBR2IsVUFBVSxDQUFDTSxNQUFYLEdBQW9CLENBQWpDLEVBQW9DTyxDQUFDLElBQUksQ0FBekMsRUFBNENBLENBQUMsRUFBN0MsRUFBaUQsSUFBSUgsQ0FBQyxHQUFHVixVQUFVLENBQUNhLENBQUQsQ0FBbEIsRUFBdUJOLENBQUMsR0FBRyxDQUFDSCxDQUFDLEdBQUcsQ0FBSixHQUFRTSxDQUFDLENBQUNILENBQUQsQ0FBVCxHQUFlSCxDQUFDLEdBQUcsQ0FBSixHQUFRTSxDQUFDLENBQUNULE1BQUQsRUFBU0MsR0FBVCxF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QUFBQSxhQUFhLENBQUNHLFVBQWQsQ0FBeUJMLEtBQXpCO0FBQ0FFLFFBQUFBLGFBQWEsQ0FBQ0ksSUFBZDtBQUNBLGNBQU1DLE1BQU0sR0FBRyxLQUFLdEYsZ0JBQUwsQ0FBc0JFLEdBQXRCLENBQTBCVCxPQUFPLENBQUM4RixPQUFsQyxDQUFmO0FBQ0FELFFBQUFBLE1BQU0sQ0FBQ0UsUUFBUCxDQUFpQixpQ0FBZ0N6RSxHQUFHLENBQUNjLE1BQU8sSUFBNUQsRUFBaUVrRCxLQUFqRTtBQUNBLGFBQUs5RSxLQUFMLENBQVcrRCxnQkFBWCxDQUE0QmdCLE9BQTVCLEVBQXFDbkcsSUFBckMsQ0FBMENhLE1BQU0sQ0FBQ3VFLElBQWpELEVBQXVEdkUsTUFBTSxDQUFDdUUsSUFBOUQ7QUFDSDtBQUNKLEtBckNlLENBQWhCO0FBc0NIOztBQXBHNkQsQ0FBbEU7O0FBc0dBdkgsVUFBVSxDQUFDLENBQ1BrRCxXQUFXLENBQUM2RixnQkFBWixDQUE2QjVGLFdBQVcsQ0FBQzZGLG1CQUF6QyxDQURPLENBQUQsRUFFUDVGLDBCQUEwQixDQUFDNkYsU0FGcEIsRUFFK0IsaUNBRi9CLEVBRWtFLElBRmxFLENBQVY7O0FBR0E3RiwwQkFBMEIsR0FBR3BELFVBQVUsQ0FBQyxDQUNwQ3NDLFdBQVcsQ0FBQzRHLFVBQVosRUFEb0MsRUFFcENsSSxPQUFPLENBQUMsQ0FBRCxFQUFJc0IsV0FBVyxDQUFDNkcsTUFBWixDQUFtQmxHLE9BQU8sQ0FBQ21HLGlCQUEzQixDQUFKLENBRjZCLENBQUQsRUFHcENoRywwQkFIb0MsQ0FBdkM7QUFJQWYsT0FBTyxDQUFDZSwwQkFBUixHQUFxQ0EsMEJBQXJDIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBpbnZlcnNpZnlfMSA9IHJlcXVpcmUoXCJpbnZlcnNpZnlcIik7XHJcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9hcHBsaWNhdGlvbi90eXBlc1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbnN0YW50c1wiKTtcclxuY29uc3QgdHlwZXNfMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vcGxhdGZvcm0vdHlwZXNcIik7XHJcbmNvbnN0IHR5cGVzXzMgPSByZXF1aXJlKFwiLi4vY29tbW9uL3Byb2Nlc3MvdHlwZXNcIik7XHJcbmNvbnN0IHR5cGVzXzQgPSByZXF1aXJlKFwiLi4vY29tbW9uL3R5cGVzXCIpO1xyXG5jb25zdCBtaXNjXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3V0aWxzL21pc2NcIik7XHJcbmNvbnN0IHR5cGVzXzUgPSByZXF1aXJlKFwiLi4vaW9jL3R5cGVzXCIpO1xyXG5jb25zdCB0ZWxlbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi90ZWxlbWV0cnlcIik7XHJcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4uL3RlbGVtZXRyeS9jb25zdGFudHNcIik7XHJcbmxldCBTb3J0SW1wb3J0c0VkaXRpbmdQcm92aWRlciA9IGNsYXNzIFNvcnRJbXBvcnRzRWRpdGluZ1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VDb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VDb250YWluZXIgPSBzZXJ2aWNlQ29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuc2hlbGwgPSBzZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18xLklBcHBsaWNhdGlvblNoZWxsKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50TWFuYWdlciA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSURvY3VtZW50TWFuYWdlcik7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzQuSUNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcclxuICAgICAgICB0aGlzLnB5dGhvbkV4ZWN1dGlvbkZhY3RvcnkgPSBzZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18zLklQeXRob25FeGVjdXRpb25GYWN0b3J5KTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NTZXJ2aWNlRmFjdG9yeSA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzMuSVByb2Nlc3NTZXJ2aWNlRmFjdG9yeSk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JVdGlscyA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzQuSUVkaXRvclV0aWxzKTtcclxuICAgIH1cclxuICAgIHByb3ZpZGVEb2N1bWVudFNvcnRJbXBvcnRzRWRpdHModXJpLCB0b2tlbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0geWllbGQgdGhpcy5kb2N1bWVudE1hbmFnZXIub3BlblRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmxpbmVDb3VudCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaXNvcnQgZG9lcyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlYWQgZnJvbSB0aGUgcHJvY2VzcyBpbnB1dCBzdHJlYW0gYW5kIHJldHVybiB0aGUgZm9ybWF0dGVkIGNvZGUgb3V0IG9mIHRoZSBvdXRwdXQgc3RyZWFtLlxyXG4gICAgICAgICAgICAvLyBIb3dldmVyIHRoZXkgZG9uJ3Qgc3VwcG9ydCByZXR1cm5pbmcgdGhlIGRpZmYgb2YgdGhlIGZvcm1hdHRlZCB0ZXh0IHdoZW4gcmVhZGluZyBkYXRhIGZyb20gdGhlIGlucHV0IHN0cmVhbS5cclxuICAgICAgICAgICAgLy8gWWVzIGdldHRpbmcgdGV4dCBmb3JtYXR0ZWQgdGhhdCB3YXkgYXZvaWRzIGhhdmluZyB0byBjcmVhdGUgYSB0ZW1wb3JhcnkgZmlsZSwgaG93ZXZlciB0aGUgZGlmZmluZyB3aWxsIGhhdmVcclxuICAgICAgICAgICAgLy8gdG8gYmUgZG9uZSBoZXJlIGluIG5vZGUgKGV4dGVuc2lvbiksIGkuZS4gZXh0ZW5zaW9uIGNwdSwgaS5lLiBsZXNzIHJlc3BvbnNpdmUgc29sdXRpb24uXHJcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydFNjcmlwdCA9IHBhdGguam9pbihjb25zdGFudHNfMS5FWFRFTlNJT05fUk9PVF9ESVIsICdweXRob25GaWxlcycsICdzb3J0SW1wb3J0cy5weScpO1xyXG4gICAgICAgICAgICBjb25zdCBmc1NlcnZpY2UgPSB0aGlzLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzIuSUZpbGVTeXN0ZW0pO1xyXG4gICAgICAgICAgICBjb25zdCB0bXBGaWxlID0gZG9jdW1lbnQuaXNEaXJ0eSA/IHlpZWxkIGZzU2VydmljZS5jcmVhdGVUZW1wb3JhcnlGaWxlKHBhdGguZXh0bmFtZShkb2N1bWVudC51cmkuZnNQYXRoKSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh0bXBGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBmc1NlcnZpY2Uud3JpdGVGaWxlKHRtcEZpbGUuZmlsZVBhdGgsIGRvY3VtZW50LmdldFRleHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldFNldHRpbmdzKHVyaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzb3J0ID0gc2V0dGluZ3Muc29ydEltcG9ydHMucGF0aDtcclxuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSB0bXBGaWxlID8gdG1wRmlsZS5maWxlUGF0aCA6IGRvY3VtZW50LnVyaS5mc1BhdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbZmlsZVBhdGgsICctLWRpZmYnXS5jb25jYXQoc2V0dGluZ3Muc29ydEltcG9ydHMuYXJncyk7XHJcbiAgICAgICAgICAgIGxldCBkaWZmUGF0Y2g7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzb3J0ID09PSAnc3RyaW5nJyAmJiBpc29ydC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0cyBqdXN0IHRyZWF0IHRoaXMgYXMgYSBzdGFuZGFyZCB0b29sLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NTZXJ2aWNlID0geWllbGQgdGhpcy5wcm9jZXNzU2VydmljZUZhY3RvcnkuY3JlYXRlKGRvY3VtZW50LnVyaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlmZlBhdGNoID0gKHlpZWxkIHByb2Nlc3NTZXJ2aWNlLmV4ZWMoaXNvcnQsIGFyZ3MsIHsgdGhyb3dPblN0ZEVycjogdHJ1ZSwgdG9rZW4gfSkpLnN0ZG91dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NFeGVTZXJ2aWNlID0geWllbGQgdGhpcy5weXRob25FeGVjdXRpb25GYWN0b3J5LmNyZWF0ZSh7IHJlc291cmNlOiBkb2N1bWVudC51cmkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlmZlBhdGNoID0gKHlpZWxkIHByb2Nlc3NFeGVTZXJ2aWNlLmV4ZWMoW2ltcG9ydFNjcmlwdF0uY29uY2F0KGFyZ3MpLCB7IHRocm93T25TdGRFcnI6IHRydWUsIHRva2VuIH0pKS5zdGRvdXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JVdGlscy5nZXRXb3Jrc3BhY2VFZGl0c0Zyb21QYXRjaChkb2N1bWVudC5nZXRUZXh0KCksIGRpZmZQYXRjaCwgZG9jdW1lbnQudXJpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0bXBGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wRmlsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgY21kTWFuYWdlciA9IHRoaXMuc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JQ29tbWFuZE1hbmFnZXIpO1xyXG4gICAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSBjbWRNYW5hZ2VyLnJlZ2lzdGVyQ29tbWFuZChjb25zdGFudHNfMS5Db21tYW5kcy5Tb3J0X0ltcG9ydHMsIHRoaXMuc29ydEltcG9ydHMsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfNC5JRGlzcG9zYWJsZVJlZ2lzdHJ5KS5wdXNoKGRpc3Bvc2FibGUpO1xyXG4gICAgfVxyXG4gICAgc29ydEltcG9ydHModXJpKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCF1cmkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUVkaXRvciA9IHRoaXMuZG9jdW1lbnRNYW5hZ2VyLmFjdGl2ZVRleHRFZGl0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZUVkaXRvciB8fCBhY3RpdmVFZGl0b3IuZG9jdW1lbnQubGFuZ3VhZ2VJZCAhPT0gY29uc3RhbnRzXzEuUFlUSE9OX0xBTkdVQUdFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGVsbC5zaG93RXJyb3JNZXNzYWdlKCdQbGVhc2Ugb3BlbiBhIFB5dGhvbiBmaWxlIHRvIHNvcnQgdGhlIGltcG9ydHMuJykudGhlbihtaXNjXzEubm9vcCwgbWlzY18xLm5vb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVyaSA9IGFjdGl2ZUVkaXRvci5kb2N1bWVudC51cmk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB5aWVsZCB0aGlzLmRvY3VtZW50TWFuYWdlci5vcGVuVGV4dERvY3VtZW50KHVyaSk7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5saW5lQ291bnQgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEhhY2ssIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGNvbnRhaW4gYW4gZW1wdHkgbGluZSBhdCB0aGUgZW5kLCB0aGVuIGFkZCBpdFxyXG4gICAgICAgICAgICAvLyBFbHNlIHRoZSBsaWJyYXJ5IHN0cmlwcyBvZmYgdGhlIGxhc3QgbGluZVxyXG4gICAgICAgICAgICBjb25zdCBsYXN0TGluZSA9IGRvY3VtZW50LmxpbmVBdChkb2N1bWVudC5saW5lQ291bnQgLSAxKTtcclxuICAgICAgICAgICAgaWYgKGxhc3RMaW5lLnRleHQudHJpbSgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXQgPSBuZXcgdnNjb2RlXzEuV29ya3NwYWNlRWRpdCgpO1xyXG4gICAgICAgICAgICAgICAgZWRpdC5pbnNlcnQodXJpLCBsYXN0TGluZS5yYW5nZS5lbmQsIG9zXzEuRU9MKTtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jdW1lbnRNYW5hZ2VyLmFwcGx5RWRpdChlZGl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHlpZWxkIHRoaXMucHJvdmlkZURvY3VtZW50U29ydEltcG9ydHNFZGl0cyh1cmkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VzIHx8IGNoYW5nZXMuZW50cmllcygpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jdW1lbnRNYW5hZ2VyLmFwcGx5RWRpdChjaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiAoZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRDaGFubmVsID0gdGhpcy5zZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc180LklPdXRwdXRDaGFubmVsLCBjb25zdGFudHNfMS5TVEFOREFSRF9PVVRQVVRfQ0hBTk5FTCk7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRDaGFubmVsLmFwcGVuZExpbmUoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dnZXIgPSB0aGlzLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzQuSUxvZ2dlcik7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nRXJyb3IoYEZhaWxlZCB0byBmb3JtYXQgaW1wb3J0cyBmb3IgJyR7dXJpLmZzUGF0aH0nLmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlbGwuc2hvd0Vycm9yTWVzc2FnZShtZXNzYWdlKS50aGVuKG1pc2NfMS5ub29wLCBtaXNjXzEubm9vcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0ZWxlbWV0cnlfMS5jYXB0dXJlVGVsZW1ldHJ5KGNvbnN0YW50c18yLkZPUk1BVF9TT1JUX0lNUE9SVFMpXHJcbl0sIFNvcnRJbXBvcnRzRWRpdGluZ1Byb3ZpZGVyLnByb3RvdHlwZSwgXCJwcm92aWRlRG9jdW1lbnRTb3J0SW1wb3J0c0VkaXRzXCIsIG51bGwpO1xyXG5Tb3J0SW1wb3J0c0VkaXRpbmdQcm92aWRlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgaW52ZXJzaWZ5XzEuaW5qZWN0YWJsZSgpLFxyXG4gICAgX19wYXJhbSgwLCBpbnZlcnNpZnlfMS5pbmplY3QodHlwZXNfNS5JU2VydmljZUNvbnRhaW5lcikpXHJcbl0sIFNvcnRJbXBvcnRzRWRpdGluZ1Byb3ZpZGVyKTtcclxuZXhwb3J0cy5Tb3J0SW1wb3J0c0VkaXRpbmdQcm92aWRlciA9IFNvcnRJbXBvcnRzRWRpdGluZ1Byb3ZpZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbXBvcnRTb3J0UHJvdmlkZXIuanMubWFwIl19