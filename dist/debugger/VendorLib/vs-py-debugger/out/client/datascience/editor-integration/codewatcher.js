// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const vscode_1 = require("vscode");

const types_1 = require("../../common/application/types");

const contextKey_1 = require("../../common/contextKey");

const types_2 = require("../../common/types");

const localize = require("../../common/utils/localize");

const telemetry_1 = require("../../telemetry");

const constants_1 = require("../constants");

const types_3 = require("../types");

class CodeWatcher {
  constructor(serviceContainer, document) {
    this.version = -1;
    this.fileName = '';
    this.codeLenses = []; // tslint:disable-next-line:no-any

    this.handleError = err => {
      if (err.actionTitle !== undefined) {
        const jupyterError = err; // This is a special error that shows a link to open for more help

        this.applicationShell.showErrorMessage(jupyterError.message, jupyterError.actionTitle).then(v => {
          // User clicked on the link, open it.
          if (v === jupyterError.actionTitle) {
            this.applicationShell.openUrl(jupyterError.action);
          }
        });
      } else if (err.message) {
        this.applicationShell.showErrorMessage(err.message);
      } else {
        this.applicationShell.showErrorMessage(err.toString());
      }

      this.logger.logError(err);
    };

    this.historyProvider = serviceContainer.get(types_3.IHistoryProvider);
    this.commandManager = serviceContainer.get(types_1.ICommandManager);
    this.applicationShell = serviceContainer.get(types_1.IApplicationShell);
    this.logger = serviceContainer.get(types_2.ILogger);
    this.document = document; // Cache these, we don't want to pull an old version if the document is updated

    this.fileName = document.fileName;
    this.version = document.version; // Get document cells here

    const cells = this.getCells(document);
    this.codeLenses = [];
    cells.forEach(cell => {
      const cmd = {
        arguments: [this, cell.range],
        title: localize.DataScience.runCellLensCommandTitle(),
        command: constants_1.Commands.RunCell
      };
      this.codeLenses.push(new vscode_1.CodeLens(cell.range, cmd));
      const runAllCmd = {
        arguments: [this],
        title: localize.DataScience.runAllCellsLensCommandTitle(),
        command: constants_1.Commands.RunAllCells
      };
      this.codeLenses.push(new vscode_1.CodeLens(cell.range, runAllCmd));
    });
  }

  getFileName() {
    return this.fileName;
  }

  getVersion() {
    return this.version;
  }

  getCodeLenses() {
    return this.codeLenses;
  }

  runAllCells() {
    return __awaiter(this, void 0, void 0, function* () {
      const activeHistory = this.historyProvider.active; // Run all of our code lenses, they should always be ordered in the file so we can just
      // run them one by one

      for (const lens of this.codeLenses) {
        // Make sure that we have the correct command (RunCell) lenses
        if (lens.command && lens.command.command === constants_1.Commands.RunCell && lens.command.arguments && lens.command.arguments.length >= 2) {
          const range = lens.command.arguments[1];

          if (this.document && range) {
            const code = this.document.getText(range);
            yield activeHistory.addCode(code, this.getFileName(), range.start.line);
          }
        }
      }
    });
  }

  runCell(range) {
    return __awaiter(this, void 0, void 0, function* () {
      const activeHistory = this.historyProvider.active;

      if (this.document) {
        const code = this.document.getText(range);

        try {
          yield activeHistory.addCode(code, this.getFileName(), range.start.line, vscode_1.window.activeTextEditor);
        } catch (err) {
          this.handleError(err);
        }
      }
    });
  }

  runCurrentCell() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!vscode_1.window.activeTextEditor || !vscode_1.window.activeTextEditor.document) {
        return;
      }

      for (const lens of this.codeLenses) {
        // Check to see which RunCell lens range overlaps the current selection start
        if (lens.range.contains(vscode_1.window.activeTextEditor.selection.start) && lens.command && lens.command.command === constants_1.Commands.RunCell) {
          yield this.runCell(lens.range);
          break;
        }
      }
    });
  }

  runCurrentCellAndAdvance() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!vscode_1.window.activeTextEditor || !vscode_1.window.activeTextEditor.document) {
        return;
      }

      let currentRunCellLens;
      let nextRunCellLens;

      for (const lens of this.codeLenses) {
        // If we have already found the current code lens, then the next run cell code lens will give us the next cell
        if (currentRunCellLens && lens.command && lens.command.command === constants_1.Commands.RunCell) {
          nextRunCellLens = lens;
          break;
        } // Check to see which RunCell lens range overlaps the current selection start


        if (lens.range.contains(vscode_1.window.activeTextEditor.selection.start) && lens.command && lens.command.command === constants_1.Commands.RunCell) {
          currentRunCellLens = lens;
        }
      }

      if (currentRunCellLens) {
        // Either use the next cell that we found, or add a new one into the document
        let nextRange;

        if (!nextRunCellLens) {
          nextRange = this.createNewCell(currentRunCellLens.range);
        } else {
          nextRange = nextRunCellLens.range;
        }

        if (nextRange) {
          this.advanceToRange(nextRange);
        } // Run the cell after moving the selection


        yield this.runCell(currentRunCellLens.range);
      }
    });
  } // User has picked run and advance on the last cell of a document
  // Create a new cell at the bottom and put their selection there, ready to type


  createNewCell(currentRange) {
    const editor = vscode_1.window.activeTextEditor;
    const newPosition = new vscode_1.Position(currentRange.end.line + 3, 0); // +3 to account for the added spaces and to position after the new mark

    if (editor) {
      editor.edit(editBuilder => {
        editBuilder.insert(new vscode_1.Position(currentRange.end.line + 1, 0), '\n\n#%%\n');
      });
    }

    return new vscode_1.Range(newPosition, newPosition);
  } // Advance the cursor to the selected range


  advanceToRange(targetRange) {
    const editor = vscode_1.window.activeTextEditor;
    const newSelection = new vscode_1.Selection(targetRange.start, targetRange.start);

    if (editor) {
      editor.selection = newSelection;
      editor.revealRange(targetRange, vscode_1.TextEditorRevealType.Default);
    }
  } // Implmentation of getCells here based on Don's Jupyter extension work


  getCells(document) {
    const cellIdentifier = constants_1.RegExpValues.PythonCellMarker;
    const editorContext = new contextKey_1.ContextKey(constants_1.EditorContexts.HasCodeCells, this.commandManager);
    const cells = [];

    for (let index = 0; index < document.lineCount; index += 1) {
      const line = document.lineAt(index); // clear regex cache

      cellIdentifier.lastIndex = -1;

      if (cellIdentifier.test(line.text)) {
        const results = cellIdentifier.exec(line.text);

        if (cells.length > 0) {
          const previousCell = cells[cells.length - 1];
          previousCell.range = new vscode_1.Range(previousCell.range.start, document.lineAt(index - 1).range.end);
        }

        if (results !== null) {
          cells.push({
            range: line.range,
            title: results.length > 1 ? results[2].trim() : ''
          });
        }
      }
    }

    if (cells.length >= 1) {
      const line = document.lineAt(document.lineCount - 1);
      const previousCell = cells[cells.length - 1];
      previousCell.range = new vscode_1.Range(previousCell.range.start, line.range.end);
    } // Inform the editor context that we have cells, fire and forget is ok on the promise here
    // as we don't care to wait for this context to be set and we can't do anything if it fails


    editorContext.set(cells.length > 0).catch();
    return cells;
  }

}

__decorate([telemetry_1.captureTelemetry(constants_1.Telemetry.RunAllCells)], CodeWatcher.prototype, "runAllCells", null);

__decorate([telemetry_1.captureTelemetry(constants_1.Telemetry.RunCell)], CodeWatcher.prototype, "runCell", null);

__decorate([telemetry_1.captureTelemetry(constants_1.Telemetry.RunCurrentCell)], CodeWatcher.prototype, "runCurrentCell", null);

__decorate([telemetry_1.captureTelemetry(constants_1.Telemetry.RunCurrentCellAndAdvance)], CodeWatcher.prototype, "runCurrentCellAndAdvance", null);

exports.CodeWatcher = CodeWatcher;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvZGV3YXRjaGVyLmpzIl0sIm5hbWVzIjpbIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJyIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZCIsIlJlZmxlY3QiLCJkZWNvcmF0ZSIsImkiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJleHBvcnRzIiwidnNjb2RlXzEiLCJyZXF1aXJlIiwidHlwZXNfMSIsImNvbnRleHRLZXlfMSIsInR5cGVzXzIiLCJsb2NhbGl6ZSIsInRlbGVtZXRyeV8xIiwiY29uc3RhbnRzXzEiLCJ0eXBlc18zIiwiQ29kZVdhdGNoZXIiLCJjb25zdHJ1Y3RvciIsInNlcnZpY2VDb250YWluZXIiLCJkb2N1bWVudCIsInZlcnNpb24iLCJmaWxlTmFtZSIsImNvZGVMZW5zZXMiLCJoYW5kbGVFcnJvciIsImVyciIsImFjdGlvblRpdGxlIiwidW5kZWZpbmVkIiwianVweXRlckVycm9yIiwiYXBwbGljYXRpb25TaGVsbCIsInNob3dFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwidiIsIm9wZW5VcmwiLCJhY3Rpb24iLCJ0b1N0cmluZyIsImxvZ2dlciIsImxvZ0Vycm9yIiwiaGlzdG9yeVByb3ZpZGVyIiwiZ2V0IiwiSUhpc3RvcnlQcm92aWRlciIsImNvbW1hbmRNYW5hZ2VyIiwiSUNvbW1hbmRNYW5hZ2VyIiwiSUFwcGxpY2F0aW9uU2hlbGwiLCJJTG9nZ2VyIiwiY2VsbHMiLCJnZXRDZWxscyIsImZvckVhY2giLCJjZWxsIiwiY21kIiwicmFuZ2UiLCJ0aXRsZSIsIkRhdGFTY2llbmNlIiwicnVuQ2VsbExlbnNDb21tYW5kVGl0bGUiLCJjb21tYW5kIiwiQ29tbWFuZHMiLCJSdW5DZWxsIiwicHVzaCIsIkNvZGVMZW5zIiwicnVuQWxsQ21kIiwicnVuQWxsQ2VsbHNMZW5zQ29tbWFuZFRpdGxlIiwiUnVuQWxsQ2VsbHMiLCJnZXRGaWxlTmFtZSIsImdldFZlcnNpb24iLCJnZXRDb2RlTGVuc2VzIiwicnVuQWxsQ2VsbHMiLCJhY3RpdmVIaXN0b3J5IiwiYWN0aXZlIiwibGVucyIsImNvZGUiLCJnZXRUZXh0IiwiYWRkQ29kZSIsInN0YXJ0IiwibGluZSIsInJ1bkNlbGwiLCJ3aW5kb3ciLCJhY3RpdmVUZXh0RWRpdG9yIiwicnVuQ3VycmVudENlbGwiLCJjb250YWlucyIsInNlbGVjdGlvbiIsInJ1bkN1cnJlbnRDZWxsQW5kQWR2YW5jZSIsImN1cnJlbnRSdW5DZWxsTGVucyIsIm5leHRSdW5DZWxsTGVucyIsIm5leHRSYW5nZSIsImNyZWF0ZU5ld0NlbGwiLCJhZHZhbmNlVG9SYW5nZSIsImN1cnJlbnRSYW5nZSIsImVkaXRvciIsIm5ld1Bvc2l0aW9uIiwiUG9zaXRpb24iLCJlbmQiLCJlZGl0IiwiZWRpdEJ1aWxkZXIiLCJpbnNlcnQiLCJSYW5nZSIsInRhcmdldFJhbmdlIiwibmV3U2VsZWN0aW9uIiwiU2VsZWN0aW9uIiwicmV2ZWFsUmFuZ2UiLCJUZXh0RWRpdG9yUmV2ZWFsVHlwZSIsIkRlZmF1bHQiLCJjZWxsSWRlbnRpZmllciIsIlJlZ0V4cFZhbHVlcyIsIlB5dGhvbkNlbGxNYXJrZXIiLCJlZGl0b3JDb250ZXh0IiwiQ29udGV4dEtleSIsIkVkaXRvckNvbnRleHRzIiwiSGFzQ29kZUNlbGxzIiwiaW5kZXgiLCJsaW5lQ291bnQiLCJsaW5lQXQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwidGV4dCIsInJlc3VsdHMiLCJleGVjIiwicHJldmlvdXNDZWxsIiwidHJpbSIsInNldCIsImNhdGNoIiwiY2FwdHVyZVRlbGVtZXRyeSIsIlRlbGVtZXRy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LENBQUMsQ0FDUHlDLFdBQVcsQ0FBQzBHLGdCQUFaLENBQTZCekcsV0FBVyxDQUFDMEcsU0FBWixDQUFzQjVELFdBQW5ELENBRE8sQ0FBRCxFQUVQNUMsV0FBVyxDQUFDeUcsU0FGTCxFQUVnQixhQUZoQixFQUUrQixJQUYvQixDQUFWOztBQUdBckosVUFBVSxDQUFDLENBQ1B5QyxXQUFXLENBQUMwRyxnQkFBWixDQUE2QnpHLFdBQVcsQ0FBQzBHLFNBQVosQ0FBc0JqRSxPQUFuRCxDQURPLENBQUQsRUFFUHZDLFdBQVcsQ0FBQ3lHLFNBRkwsRUFFZ0IsU0FGaEIsRUFFMkIsSUFGM0IsQ0FBVjs7QUFHQXJKLFVBQVUsQ0FBQyxDQUNQeUMsV0FBVyxDQUFDMEcsZ0JBQVosQ0FBNkJ6RyxXQUFXLENBQUMwRyxTQUFaLENBQXNCRSxjQUFuRCxDQURPLENBQUQsRUFFUDFHLFdBQVcsQ0FBQ3lHLFNBRkwsRUFFZ0IsZ0JBRmhCLEVBRWtDLElBRmxDLENBQVY7O0FBR0FySixVQUFVLENBQUMsQ0FDUHlDLFdBQVcsQ0FBQzBHLGdCQUFaLENBQTZCekcsV0FBVyxDQUFDMEcsU0FBWixDQUFzQkcsd0JBQW5ELENBRE8sQ0FBRCxFQUVQM0csV0FBVyxDQUFDeUcsU0FGTCxFQUVnQiwwQkFGaEIsRUFFNEMsSUFGNUMsQ0FBVjs7QUFHQW5ILE9BQU8sQ0FBQ1UsV0FBUixHQUFzQkEsV0FBdEIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9hcHBsaWNhdGlvbi90eXBlc1wiKTtcclxuY29uc3QgY29udGV4dEtleV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9jb250ZXh0S2V5XCIpO1xyXG5jb25zdCB0eXBlc18yID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi90eXBlc1wiKTtcclxuY29uc3QgbG9jYWxpemUgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL3V0aWxzL2xvY2FsaXplXCIpO1xyXG5jb25zdCB0ZWxlbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi8uLi90ZWxlbWV0cnlcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcclxuY29uc3QgdHlwZXNfMyA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcclxuY2xhc3MgQ29kZVdhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc2VydmljZUNvbnRhaW5lciwgZG9jdW1lbnQpIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSAtMTtcclxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gJyc7XHJcbiAgICAgICAgdGhpcy5jb2RlTGVuc2VzID0gW107XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIuYWN0aW9uVGl0bGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QganVweXRlckVycm9yID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgZXJyb3IgdGhhdCBzaG93cyBhIGxpbmsgdG8gb3BlbiBmb3IgbW9yZSBoZWxwXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uU2hlbGwuc2hvd0Vycm9yTWVzc2FnZShqdXB5dGVyRXJyb3IubWVzc2FnZSwganVweXRlckVycm9yLmFjdGlvblRpdGxlKS50aGVuKHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgY2xpY2tlZCBvbiB0aGUgbGluaywgb3BlbiBpdC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PT0ganVweXRlckVycm9yLmFjdGlvblRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25TaGVsbC5vcGVuVXJsKGp1cHl0ZXJFcnJvci5hY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVyci5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uU2hlbGwuc2hvd0Vycm9yTWVzc2FnZShlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uU2hlbGwuc2hvd0Vycm9yTWVzc2FnZShlcnIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nRXJyb3IoZXJyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeVByb3ZpZGVyID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMy5JSGlzdG9yeVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JQ29tbWFuZE1hbmFnZXIpO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25TaGVsbCA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSUFwcGxpY2F0aW9uU2hlbGwpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMi5JTG9nZ2VyKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgLy8gQ2FjaGUgdGhlc2UsIHdlIGRvbid0IHdhbnQgdG8gcHVsbCBhbiBvbGQgdmVyc2lvbiBpZiB0aGUgZG9jdW1lbnQgaXMgdXBkYXRlZFxyXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBkb2N1bWVudC5maWxlTmFtZTtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSBkb2N1bWVudC52ZXJzaW9uO1xyXG4gICAgICAgIC8vIEdldCBkb2N1bWVudCBjZWxscyBoZXJlXHJcbiAgICAgICAgY29uc3QgY2VsbHMgPSB0aGlzLmdldENlbGxzKGRvY3VtZW50KTtcclxuICAgICAgICB0aGlzLmNvZGVMZW5zZXMgPSBbXTtcclxuICAgICAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjbWQgPSB7XHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFt0aGlzLCBjZWxsLnJhbmdlXSxcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBsb2NhbGl6ZS5EYXRhU2NpZW5jZS5ydW5DZWxsTGVuc0NvbW1hbmRUaXRsZSgpLFxyXG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29uc3RhbnRzXzEuQ29tbWFuZHMuUnVuQ2VsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVMZW5zZXMucHVzaChuZXcgdnNjb2RlXzEuQ29kZUxlbnMoY2VsbC5yYW5nZSwgY21kKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bkFsbENtZCA9IHtcclxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW3RoaXNdLFxyXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsaXplLkRhdGFTY2llbmNlLnJ1bkFsbENlbGxzTGVuc0NvbW1hbmRUaXRsZSgpLFxyXG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29uc3RhbnRzXzEuQ29tbWFuZHMuUnVuQWxsQ2VsbHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTGVuc2VzLnB1c2gobmV3IHZzY29kZV8xLkNvZGVMZW5zKGNlbGwucmFuZ2UsIHJ1bkFsbENtZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RmlsZU5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZU5hbWU7XHJcbiAgICB9XHJcbiAgICBnZXRWZXJzaW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XHJcbiAgICB9XHJcbiAgICBnZXRDb2RlTGVuc2VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVMZW5zZXM7XHJcbiAgICB9XHJcbiAgICBydW5BbGxDZWxscygpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVIaXN0b3J5ID0gdGhpcy5oaXN0b3J5UHJvdmlkZXIuYWN0aXZlO1xyXG4gICAgICAgICAgICAvLyBSdW4gYWxsIG9mIG91ciBjb2RlIGxlbnNlcywgdGhleSBzaG91bGQgYWx3YXlzIGJlIG9yZGVyZWQgaW4gdGhlIGZpbGUgc28gd2UgY2FuIGp1c3RcclxuICAgICAgICAgICAgLy8gcnVuIHRoZW0gb25lIGJ5IG9uZVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxlbnMgb2YgdGhpcy5jb2RlTGVuc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBjb3JyZWN0IGNvbW1hbmQgKFJ1bkNlbGwpIGxlbnNlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbnMuY29tbWFuZCAmJiBsZW5zLmNvbW1hbmQuY29tbWFuZCA9PT0gY29uc3RhbnRzXzEuQ29tbWFuZHMuUnVuQ2VsbCAmJiBsZW5zLmNvbW1hbmQuYXJndW1lbnRzICYmIGxlbnMuY29tbWFuZC5hcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGxlbnMuY29tbWFuZC5hcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnQgJiYgcmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuZG9jdW1lbnQuZ2V0VGV4dChyYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGFjdGl2ZUhpc3RvcnkuYWRkQ29kZShjb2RlLCB0aGlzLmdldEZpbGVOYW1lKCksIHJhbmdlLnN0YXJ0LmxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcnVuQ2VsbChyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUhpc3RvcnkgPSB0aGlzLmhpc3RvcnlQcm92aWRlci5hY3RpdmU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5kb2N1bWVudC5nZXRUZXh0KHJhbmdlKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgYWN0aXZlSGlzdG9yeS5hZGRDb2RlKGNvZGUsIHRoaXMuZ2V0RmlsZU5hbWUoKSwgcmFuZ2Uuc3RhcnQubGluZSwgdnNjb2RlXzEud2luZG93LmFjdGl2ZVRleHRFZGl0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcnVuQ3VycmVudENlbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCF2c2NvZGVfMS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvciB8fCAhdnNjb2RlXzEud2luZG93LmFjdGl2ZVRleHRFZGl0b3IuZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxlbnMgb2YgdGhpcy5jb2RlTGVuc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgd2hpY2ggUnVuQ2VsbCBsZW5zIHJhbmdlIG92ZXJsYXBzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzdGFydFxyXG4gICAgICAgICAgICAgICAgaWYgKGxlbnMucmFuZ2UuY29udGFpbnModnNjb2RlXzEud2luZG93LmFjdGl2ZVRleHRFZGl0b3Iuc2VsZWN0aW9uLnN0YXJ0KSAmJiBsZW5zLmNvbW1hbmQgJiYgbGVucy5jb21tYW5kLmNvbW1hbmQgPT09IGNvbnN0YW50c18xLkNvbW1hbmRzLlJ1bkNlbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJ1bkNlbGwobGVucy5yYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJ1bkN1cnJlbnRDZWxsQW5kQWR2YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoIXZzY29kZV8xLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yIHx8ICF2c2NvZGVfMS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvci5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50UnVuQ2VsbExlbnM7XHJcbiAgICAgICAgICAgIGxldCBuZXh0UnVuQ2VsbExlbnM7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVucyBvZiB0aGlzLmNvZGVMZW5zZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYWxyZWFkeSBmb3VuZCB0aGUgY3VycmVudCBjb2RlIGxlbnMsIHRoZW4gdGhlIG5leHQgcnVuIGNlbGwgY29kZSBsZW5zIHdpbGwgZ2l2ZSB1cyB0aGUgbmV4dCBjZWxsXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJ1bkNlbGxMZW5zICYmIGxlbnMuY29tbWFuZCAmJiBsZW5zLmNvbW1hbmQuY29tbWFuZCA9PT0gY29uc3RhbnRzXzEuQ29tbWFuZHMuUnVuQ2VsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRSdW5DZWxsTGVucyA9IGxlbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgd2hpY2ggUnVuQ2VsbCBsZW5zIHJhbmdlIG92ZXJsYXBzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzdGFydFxyXG4gICAgICAgICAgICAgICAgaWYgKGxlbnMucmFuZ2UuY29udGFpbnModnNjb2RlXzEud2luZG93LmFjdGl2ZVRleHRFZGl0b3Iuc2VsZWN0aW9uLnN0YXJ0KSAmJiBsZW5zLmNvbW1hbmQgJiYgbGVucy5jb21tYW5kLmNvbW1hbmQgPT09IGNvbnN0YW50c18xLkNvbW1hbmRzLlJ1bkNlbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UnVuQ2VsbExlbnMgPSBsZW5zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UnVuQ2VsbExlbnMpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB1c2UgdGhlIG5leHQgY2VsbCB0aGF0IHdlIGZvdW5kLCBvciBhZGQgYSBuZXcgb25lIGludG8gdGhlIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UnVuQ2VsbExlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0UmFuZ2UgPSB0aGlzLmNyZWF0ZU5ld0NlbGwoY3VycmVudFJ1bkNlbGxMZW5zLnJhbmdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRSYW5nZSA9IG5leHRSdW5DZWxsTGVucy5yYW5nZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VUb1JhbmdlKG5leHRSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSdW4gdGhlIGNlbGwgYWZ0ZXIgbW92aW5nIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucnVuQ2VsbChjdXJyZW50UnVuQ2VsbExlbnMucmFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBVc2VyIGhhcyBwaWNrZWQgcnVuIGFuZCBhZHZhbmNlIG9uIHRoZSBsYXN0IGNlbGwgb2YgYSBkb2N1bWVudFxyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNlbGwgYXQgdGhlIGJvdHRvbSBhbmQgcHV0IHRoZWlyIHNlbGVjdGlvbiB0aGVyZSwgcmVhZHkgdG8gdHlwZVxyXG4gICAgY3JlYXRlTmV3Q2VsbChjdXJyZW50UmFuZ2UpIHtcclxuICAgICAgICBjb25zdCBlZGl0b3IgPSB2c2NvZGVfMS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvcjtcclxuICAgICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG5ldyB2c2NvZGVfMS5Qb3NpdGlvbihjdXJyZW50UmFuZ2UuZW5kLmxpbmUgKyAzLCAwKTsgLy8gKzMgdG8gYWNjb3VudCBmb3IgdGhlIGFkZGVkIHNwYWNlcyBhbmQgdG8gcG9zaXRpb24gYWZ0ZXIgdGhlIG5ldyBtYXJrXHJcbiAgICAgICAgaWYgKGVkaXRvcikge1xyXG4gICAgICAgICAgICBlZGl0b3IuZWRpdCgoZWRpdEJ1aWxkZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGVkaXRCdWlsZGVyLmluc2VydChuZXcgdnNjb2RlXzEuUG9zaXRpb24oY3VycmVudFJhbmdlLmVuZC5saW5lICsgMSwgMCksICdcXG5cXG4jJSVcXG4nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgdnNjb2RlXzEuUmFuZ2UobmV3UG9zaXRpb24sIG5ld1Bvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIC8vIEFkdmFuY2UgdGhlIGN1cnNvciB0byB0aGUgc2VsZWN0ZWQgcmFuZ2VcclxuICAgIGFkdmFuY2VUb1JhbmdlKHRhcmdldFJhbmdlKSB7XHJcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdnNjb2RlXzEud2luZG93LmFjdGl2ZVRleHRFZGl0b3I7XHJcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gbmV3IHZzY29kZV8xLlNlbGVjdGlvbih0YXJnZXRSYW5nZS5zdGFydCwgdGFyZ2V0UmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIGlmIChlZGl0b3IpIHtcclxuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG5ld1NlbGVjdGlvbjtcclxuICAgICAgICAgICAgZWRpdG9yLnJldmVhbFJhbmdlKHRhcmdldFJhbmdlLCB2c2NvZGVfMS5UZXh0RWRpdG9yUmV2ZWFsVHlwZS5EZWZhdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJbXBsbWVudGF0aW9uIG9mIGdldENlbGxzIGhlcmUgYmFzZWQgb24gRG9uJ3MgSnVweXRlciBleHRlbnNpb24gd29ya1xyXG4gICAgZ2V0Q2VsbHMoZG9jdW1lbnQpIHtcclxuICAgICAgICBjb25zdCBjZWxsSWRlbnRpZmllciA9IGNvbnN0YW50c18xLlJlZ0V4cFZhbHVlcy5QeXRob25DZWxsTWFya2VyO1xyXG4gICAgICAgIGNvbnN0IGVkaXRvckNvbnRleHQgPSBuZXcgY29udGV4dEtleV8xLkNvbnRleHRLZXkoY29uc3RhbnRzXzEuRWRpdG9yQ29udGV4dHMuSGFzQ29kZUNlbGxzLCB0aGlzLmNvbW1hbmRNYW5hZ2VyKTtcclxuICAgICAgICBjb25zdCBjZWxscyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkb2N1bWVudC5saW5lQ291bnQ7IGluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IGRvY3VtZW50LmxpbmVBdChpbmRleCk7XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIHJlZ2V4IGNhY2hlXHJcbiAgICAgICAgICAgIGNlbGxJZGVudGlmaWVyLmxhc3RJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBpZiAoY2VsbElkZW50aWZpZXIudGVzdChsaW5lLnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gY2VsbElkZW50aWZpZXIuZXhlYyhsaW5lLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NlbGwgPSBjZWxsc1tjZWxscy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NlbGwucmFuZ2UgPSBuZXcgdnNjb2RlXzEuUmFuZ2UocHJldmlvdXNDZWxsLnJhbmdlLnN0YXJ0LCBkb2N1bWVudC5saW5lQXQoaW5kZXggLSAxKS5yYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGxpbmUucmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiByZXN1bHRzLmxlbmd0aCA+IDEgPyByZXN1bHRzWzJdLnRyaW0oKSA6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA+PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkb2N1bWVudC5saW5lQXQoZG9jdW1lbnQubGluZUNvdW50IC0gMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ2VsbCA9IGNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBwcmV2aW91c0NlbGwucmFuZ2UgPSBuZXcgdnNjb2RlXzEuUmFuZ2UocHJldmlvdXNDZWxsLnJhbmdlLnN0YXJ0LCBsaW5lLnJhbmdlLmVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluZm9ybSB0aGUgZWRpdG9yIGNvbnRleHQgdGhhdCB3ZSBoYXZlIGNlbGxzLCBmaXJlIGFuZCBmb3JnZXQgaXMgb2sgb24gdGhlIHByb21pc2UgaGVyZVxyXG4gICAgICAgIC8vIGFzIHdlIGRvbid0IGNhcmUgdG8gd2FpdCBmb3IgdGhpcyBjb250ZXh0IHRvIGJlIHNldCBhbmQgd2UgY2FuJ3QgZG8gYW55dGhpbmcgaWYgaXQgZmFpbHNcclxuICAgICAgICBlZGl0b3JDb250ZXh0LnNldChjZWxscy5sZW5ndGggPiAwKS5jYXRjaCgpO1xyXG4gICAgICAgIHJldHVybiBjZWxscztcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIHRlbGVtZXRyeV8xLmNhcHR1cmVUZWxlbWV0cnkoY29uc3RhbnRzXzEuVGVsZW1ldHJ5LlJ1bkFsbENlbGxzKVxyXG5dLCBDb2RlV2F0Y2hlci5wcm90b3R5cGUsIFwicnVuQWxsQ2VsbHNcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdGVsZW1ldHJ5XzEuY2FwdHVyZVRlbGVtZXRyeShjb25zdGFudHNfMS5UZWxlbWV0cnkuUnVuQ2VsbClcclxuXSwgQ29kZVdhdGNoZXIucHJvdG90eXBlLCBcInJ1bkNlbGxcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdGVsZW1ldHJ5XzEuY2FwdHVyZVRlbGVtZXRyeShjb25zdGFudHNfMS5UZWxlbWV0cnkuUnVuQ3VycmVudENlbGwpXHJcbl0sIENvZGVXYXRjaGVyLnByb3RvdHlwZSwgXCJydW5DdXJyZW50Q2VsbFwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0ZWxlbWV0cnlfMS5jYXB0dXJlVGVsZW1ldHJ5KGNvbnN0YW50c18xLlRlbGVtZXRyeS5SdW5DdXJyZW50Q2VsbEFuZEFkdmFuY2UpXHJcbl0sIENvZGVXYXRjaGVyLnByb3RvdHlwZSwgXCJydW5DdXJyZW50Q2VsbEFuZEFkdmFuY2VcIiwgbnVsbCk7XHJcbmV4cG9ydHMuQ29kZVdhdGNoZXIgPSBDb2RlV2F0Y2hlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZXdhdGNoZXIuanMubWFwIl19