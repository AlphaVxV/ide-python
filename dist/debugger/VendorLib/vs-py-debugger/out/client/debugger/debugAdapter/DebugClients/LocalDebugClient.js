"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const child_process_1 = require("child_process");

const path = require("path");

const vscode_debugadapter_1 = require("vscode-debugadapter");

const open_1 = require("../../../common/open");

const pathUtils_1 = require("../../../common/platform/pathUtils");

const currentProcess_1 = require("../../../common/process/currentProcess");

const misc_1 = require("../../../common/utils/misc");

const environment_1 = require("../../../common/variables/environment");

const types_1 = require("../../types");

const Utils_1 = require("../Common/Utils");

const LocalDebugServerV2_1 = require("../DebugServers/LocalDebugServerV2");

const DebugClient_1 = require("./DebugClient");

const helper_1 = require("./helper");

const VALID_DEBUG_OPTIONS = ['RedirectOutput', 'DebugStdLib', 'StopOnEntry', 'ShowReturnValue', 'BreakOnSystemExitZero', 'DjangoDebugging', 'Django'];
var DebugServerStatus;

(function (DebugServerStatus) {
  DebugServerStatus[DebugServerStatus["Unknown"] = 1] = "Unknown";
  DebugServerStatus[DebugServerStatus["Running"] = 2] = "Running";
  DebugServerStatus[DebugServerStatus["NotRunning"] = 3] = "NotRunning";
})(DebugServerStatus || (DebugServerStatus = {}));

class LocalDebugClient extends DebugClient_1.DebugClient {
  constructor(args, debugSession, canLaunchTerminal, launcherScriptProvider) {
    super(args, debugSession);
    this.canLaunchTerminal = canLaunchTerminal;
    this.launcherScriptProvider = launcherScriptProvider;
  }

  get debugServerStatus() {
    if (this.debugServer && this.debugServer.IsRunning) {
      return DebugServerStatus.Running;
    }

    if (this.debugServer && !this.debugServer.IsRunning) {
      return DebugServerStatus.NotRunning;
    }

    return DebugServerStatus.Unknown;
  }

  CreateDebugServer(serviceContainer) {
    this.debugServer = new LocalDebugServerV2_1.LocalDebugServerV2(this.debugSession, this.args, serviceContainer);
    return this.debugServer;
  }

  get DebugType() {
    return DebugClient_1.DebugType.Local;
  }

  Stop() {
    if (this.debugServer) {
      this.debugServer.Stop();
      this.debugServer = undefined;
    }

    if (this.pyProc) {
      this.pyProc.kill();
      this.pyProc = undefined;
    }
  } // tslint:disable-next-line:no-any


  displayError(error) {
    const errorMsg = typeof error === 'string' ? error : error.message && error.message.length > 0 ? error.message : '';

    if (errorMsg.length > 0) {
      this.debugSession.sendEvent(new vscode_debugadapter_1.OutputEvent(errorMsg, 'stderr'));
    }
  } // tslint:disable-next-line:max-func-body-length member-ordering no-any


  LaunchApplicationToDebug(dbgServer) {
    return __awaiter(this, void 0, void 0, function* () {
      const pathUtils = new pathUtils_1.PathUtils(Utils_1.IS_WINDOWS);
      const currentProcess = new currentProcess_1.CurrentProcess();
      const environmentVariablesService = new environment_1.EnvironmentVariablesService(pathUtils);
      const helper = new helper_1.DebugClientHelper(environmentVariablesService, pathUtils, currentProcess);
      const environmentVariables = yield helper.getEnvironmentVariables(this.args); // tslint:disable-next-line:max-func-body-length cyclomatic-complexity no-any

      return new Promise((resolve, reject) => {
        const fileDir = this.args && this.args.program ? path.dirname(this.args.program) : '';
        let processCwd = fileDir;

        if (typeof this.args.cwd === 'string' && this.args.cwd.length > 0 && this.args.cwd !== 'null') {
          processCwd = this.args.cwd;
        }

        let pythonPath = 'python';

        if (typeof this.args.pythonPath === 'string' && this.args.pythonPath.trim().length > 0) {
          pythonPath = this.args.pythonPath;
        }

        const args = this.buildLaunchArguments(processCwd, dbgServer.port);

        switch (this.args.console) {
          case 'externalTerminal':
          case 'integratedTerminal':
            {
              const isSudo = Array.isArray(this.args.debugOptions) && this.args.debugOptions.some(opt => opt === 'Sudo');
              this.launchExternalTerminal(isSudo, processCwd, pythonPath, args, environmentVariables).then(resolve).catch(reject);
              break;
            }

          default:
            {
              this.pyProc = child_process_1.spawn(pythonPath, args, {
                cwd: processCwd,
                env: environmentVariables
              });
              this.handleProcessOutput(this.pyProc, reject); // Here we wait for the application to connect to the socket server.
              // Only once connected do we know that the application has successfully launched.

              this.debugServer.DebugClientConnected.then(resolve).catch(ex => console.error('Python Extension: debugServer.DebugClientConnected', ex));
            }
        }
      });
    });
  } // tslint:disable-next-line:member-ordering


  handleProcessOutput(proc, failedToLaunch) {
    proc.on('error', error => {
      // If debug server has started, then don't display errors.
      // The debug adapter will get this info from the debugger (e.g. ptvsd lib).
      const status = this.debugServerStatus;

      if (status === DebugServerStatus.Running) {
        return;
      }

      if (status === DebugServerStatus.NotRunning && typeof error === 'object' && error !== null) {
        return failedToLaunch(error);
      } // This could happen when the debugger didn't launch at all, e.g. python doesn't exist.


      this.displayError(error);
    });
    proc.stderr.setEncoding('utf8');
    proc.stderr.on('data', misc_1.noop);
    proc.stdout.on('data', d => {
      // This is necessary so we read the stdout of the python process,
      // Else it just keep building up (related to issue #203 and #52).
      // tslint:disable-next-line:prefer-const no-unused-variable
      let x = 0;
    });
  }

  buildLaunchArguments(cwd, debugPort) {
    return [...this.buildDebugArguments(cwd, debugPort), ...this.buildStandardArguments()];
  } // tslint:disable-next-line:member-ordering


  buildDebugArguments(cwd, debugPort) {
    const ptVSToolsFilePath = this.launcherScriptProvider.getLauncherFilePath();
    const vsDebugOptions = [types_1.DebugOptions.RedirectOutput];

    if (Array.isArray(this.args.debugOptions)) {
      this.args.debugOptions.filter(opt => VALID_DEBUG_OPTIONS.indexOf(opt) >= 0).forEach(item => vsDebugOptions.push(item));
    }

    const djangoIndex = vsDebugOptions.indexOf(types_1.DebugOptions.Django); // PTVSD expects the string `DjangoDebugging`

    if (djangoIndex >= 0) {
      vsDebugOptions[djangoIndex] = 'DjangoDebugging';
    }

    return [ptVSToolsFilePath, cwd, debugPort.toString(), '34806ad9-833a-4524-8cd6-18ca4aa74f14', vsDebugOptions.join(',')];
  } // tslint:disable-next-line:member-ordering


  buildStandardArguments() {
    const programArgs = Array.isArray(this.args.args) && this.args.args.length > 0 ? this.args.args : [];

    if (typeof this.args.module === 'string' && this.args.module.length > 0) {
      return ['-m', this.args.module, ...programArgs];
    }

    if (this.args.program && this.args.program.length > 0) {
      return [this.args.program, ...programArgs];
    }

    return programArgs;
  }

  launchExternalTerminal(sudo, cwd, pythonPath, args, env) {
    return new Promise((resolve, reject) => {
      if (this.canLaunchTerminal) {
        const command = sudo ? 'sudo' : pythonPath;
        const commandArgs = sudo ? [pythonPath].concat(args) : args;
        const isExternalTerminal = this.args.console === 'externalTerminal';
        const consoleKind = isExternalTerminal ? 'external' : 'integrated';
        const termArgs = {
          kind: consoleKind,
          title: 'Python Debug Console',
          cwd,
          args: [command].concat(commandArgs),
          env
        };
        this.debugSession.runInTerminalRequest(termArgs, 5000, response => {
          if (response.success) {
            resolve();
          } else {
            reject(response);
          }
        });
      } else {
        open_1.open({
          wait: false,
          app: [pythonPath].concat(args),
          cwd,
          env,
          sudo: sudo
        }).then(proc => {
          this.pyProc = proc;
          resolve();
        }, error => {
          if (this.debugServerStatus === DebugServerStatus.Running) {
            return;
          }

          reject(error);
        });
      }
    });
  }

}

exports.LocalDebugClient = LocalDebugClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkxvY2FsRGVidWdDbGllbnQuanMiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImNoaWxkX3Byb2Nlc3NfMSIsInJlcXVpcmUiLCJwYXRoIiwidnNjb2RlX2RlYnVnYWRhcHRlcl8xIiwib3Blbl8xIiwicGF0aFV0aWxzXzEiLCJjdXJyZW50UHJvY2Vzc18xIiwibWlzY18xIiwiZW52aXJvbm1lbnRfMSIsInR5cGVzXzEiLCJVdGlsc18xIiwiTG9jYWxEZWJ1Z1NlcnZlclYyXzEiLCJEZWJ1Z0NsaWVudF8xIiwiaGVscGVyXzEiLCJWQUxJRF9ERUJVR19PUFRJT05TIiwiRGVidWdTZXJ2ZXJTdGF0dXMiLCJMb2NhbERlYnVnQ2xpZW50IiwiRGVidWdDbGllbnQiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJkZWJ1Z1Nlc3Npb24iLCJjYW5MYXVuY2hUZXJtaW5hbCIsImxhdW5jaGVyU2NyaXB0UHJvdmlkZXIiLCJkZWJ1Z1NlcnZlclN0YXR1cyIsImRlYnVnU2VydmVyIiwiSXNSdW5uaW5nIiwiUnVubmluZyIsIk5vdFJ1bm5pbmciLCJVbmtub3duIiwiQ3JlYXRlRGVidWdTZXJ2ZXIiLCJzZXJ2aWNlQ29udGFpbmVyIiwiTG9jYWxEZWJ1Z1NlcnZlclYyIiwiRGVidWdUeXBlIiwiTG9jYWwiLCJTdG9wIiwidW5kZWZpbmVkIiwicHlQcm9jIiwia2lsbCIsImRpc3BsYXlFcnJvciIsImVycm9yIiwiZXJyb3JNc2ciLCJtZXNzYWdlIiwibGVuZ3RoIiwic2VuZEV2ZW50IiwiT3V0cHV0RXZlbnQiLCJMYXVuY2hBcHBsaWNhdGlvblRvRGVidWciLCJkYmdTZXJ2ZXIiLCJwYXRoVXRpbHMiLCJQYXRoVXRpbHMiLCJJU19XSU5ET1dTIiwiY3VycmVudFByb2Nlc3MiLCJDdXJyZW50UHJvY2VzcyIsImVudmlyb25tZW50VmFyaWFibGVzU2VydmljZSIsIkVudmlyb25tZW50VmFyaWFibGVzU2VydmljZSIsImhlbHBlciIsIkRlYnVnQ2xpZW50SGVscGVyIiwiZW52aXJvbm1lbnRWYXJpYWJsZXMiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyIsImZpbGVEaXIiLCJwcm9ncmFtIiwiZGlybmFtZSIsInByb2Nlc3NDd2QiLCJjd2QiLCJweXRob25QYXRoIiwidHJpbSIsImJ1aWxkTGF1bmNoQXJndW1lbnRzIiwicG9ydCIsImNvbnNvbGUiLCJpc1N1ZG8iLCJBcnJheSIsImlzQXJyYXkiLCJkZWJ1Z09wdGlvbnMiLCJzb21lIiwib3B0IiwibGF1bmNoRXh0ZXJuYWxUZXJtaW5hbCIsImNhdGNoIiwic3Bhd24iLCJlbnYiLCJoYW5kbGVQcm9jZXNzT3V0cHV0IiwiRGVidWdDbGllbnRDb25uZWN0ZWQiLCJleCIsInByb2MiLCJmYWlsZWRUb0xhdW5jaCIsIm9uIiwic3RhdHVzIiwic3RkZXJyIiwic2V0RW5jb2RpbmciLCJub29wIiwic3Rkb3V0IiwiZCIsIngiLCJkZWJ1Z1BvcnQiLCJidWlsZERlYnVnQXJndW1lbnRzIiwiYnVpbGRTdGFuZGFyZEFyZ3VtZW50cyIsInB0VlNUb29sc0ZpbGVQYXRoIiwiZ2V0TGF1bmNoZXJGaWxlUGF0aCIsInZzRGVidWdPcHRpb25zIiwiRGVidWdPcHRpb25zIiwiUmVkaXJlY3RPdXRwdXQiLCJmaWx0ZXIiLCJpbmRleE9mIiwiZm9yRWFjaCIsIml0ZW0iLCJwdXNoIiwiZGphbmdvSW5kZXgiLCJEamFuZ28iLCJ0b1N0cmluZyIsImpvaW4iLCJwcm9ncmFtQXJncyIsIm1vZHVsZSIsInN1ZG8iLCJjb21tYW5kIiwiY29tbWFuZEFyZ3MiLCJjb25jYXQiLCJpc0V4dGVybmFsVGVybWluYWwiLCJjb25zb2xlS2luZCIsInRlcm1BcmdzIiwia2luZCIsInRpdGxlIiwicnVuSW5UZXJtaW5hbFJlcXVlc3QiLCJyZXNwb25zZSIsInN1Y2Nlc3MiLCJvcGVuIiwid2FpdCIsImFwcCJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsU0FBUyxHQUFJLFVBQVEsU0FBS0EsU0FBZCxJQUE0QixVQUFVQyxPQUFWLEVBQW1CQyxVQUFuQixFQUErQkMsQ0FBL0IsRUFBa0NDLFNBQWxDLEVBQTZDO0FBQ3JGLFNBQU8sS0FBS0QsQ0FBQyxLQUFLQSxDQUFDLEdBQUdFLE9BQVQsQ0FBTixFQUF5QixVQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUN2RCxhQUFTQyxTQUFULENBQW1CQyxLQUFuQixFQUEwQjtBQUFFLFVBQUk7QUFBRUMsUUFBQUEsSUFBSSxDQUFDTixTQUFTLENBQUNPLElBQVYsQ0FBZUYsS0FBZixDQUFELENBQUo7QUFBOEIsT0FBcEMsQ0FBcUMsT0FBT0csQ0FBUCxFQUFVO0FBQUVMLFFBQUFBLE1BQU0sQ0FBQ0ssQ0FBRCxDQUFOO0FBQVk7QUFBRTs7QUFDM0YsYUFBU0MsUUFBVCxDQUFrQkosS0FBbEIsRUFBeUI7QUFBRSxVQUFJO0FBQUVDLFFBQUFBLElBQUksQ0FBQ04sU0FBUyxDQUFDLE9BQUQsQ0FBVCxDQUFtQkssS0FBbkIsQ0FBRCxDQUFKO0FBQWtDLE9BQXhDLENBQXlDLE9BQU9HLENBQVAsRUFBVTtBQUFFTCxRQUFBQSxNQUFNLENBQUNLLENBQUQsQ0FBTjtBQUFZO0FBQUU7O0FBQzlGLGFBQVNGLElBQVQsQ0FBY0ksTUFBZCxFQUFzQjtBQUFFQSxNQUFBQSxNQUFNLENBQUNDLElBQVAsR0FBY1QsT0FBTyxDQUFDUSxNQUFNLENBQUNMLEtBQVIsQ0FBckIsR0FBc0MsSUFBSU4sQ0FBSixDQUFNLFVBQVVHLE9BQVYsRUFBbUI7QUFBRUEsUUFBQUEsT0FBTyxDQUFDUSxNQUFNLENBQUNMLEtBQVIsQ0FBUDtBQUF3QixPQUFuRCxFQUFxRE8sSUFBckQsQ0FBMERSLFNBQTFELEVBQXFFSyxR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X19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IHZzY29kZV9kZWJ1Z2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtZGVidWdhZGFwdGVyXCIpO1xyXG5jb25zdCBvcGVuXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29tbW9uL29wZW5cIik7XHJcbmNvbnN0IHBhdGhVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbW1vbi9wbGF0Zm9ybS9wYXRoVXRpbHNcIik7XHJcbmNvbnN0IGN1cnJlbnRQcm9jZXNzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29tbW9uL3Byb2Nlc3MvY3VycmVudFByb2Nlc3NcIik7XHJcbmNvbnN0IG1pc2NfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb21tb24vdXRpbHMvbWlzY1wiKTtcclxuY29uc3QgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb21tb24vdmFyaWFibGVzL2Vudmlyb25tZW50XCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xyXG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL0NvbW1vbi9VdGlsc1wiKTtcclxuY29uc3QgTG9jYWxEZWJ1Z1NlcnZlclYyXzEgPSByZXF1aXJlKFwiLi4vRGVidWdTZXJ2ZXJzL0xvY2FsRGVidWdTZXJ2ZXJWMlwiKTtcclxuY29uc3QgRGVidWdDbGllbnRfMSA9IHJlcXVpcmUoXCIuL0RlYnVnQ2xpZW50XCIpO1xyXG5jb25zdCBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcclxuY29uc3QgVkFMSURfREVCVUdfT1BUSU9OUyA9IFtcclxuICAgICdSZWRpcmVjdE91dHB1dCcsXHJcbiAgICAnRGVidWdTdGRMaWInLFxyXG4gICAgJ1N0b3BPbkVudHJ5JyxcclxuICAgICdTaG93UmV0dXJuVmFsdWUnLFxyXG4gICAgJ0JyZWFrT25TeXN0ZW1FeGl0WmVybycsXHJcbiAgICAnRGphbmdvRGVidWdnaW5nJyxcclxuICAgICdEamFuZ28nXHJcbl07XHJcbnZhciBEZWJ1Z1NlcnZlclN0YXR1cztcclxuKGZ1bmN0aW9uIChEZWJ1Z1NlcnZlclN0YXR1cykge1xyXG4gICAgRGVidWdTZXJ2ZXJTdGF0dXNbRGVidWdTZXJ2ZXJTdGF0dXNbXCJVbmtub3duXCJdID0gMV0gPSBcIlVua25vd25cIjtcclxuICAgIERlYnVnU2VydmVyU3RhdHVzW0RlYnVnU2VydmVyU3RhdHVzW1wiUnVubmluZ1wiXSA9IDJdID0gXCJSdW5uaW5nXCI7XHJcbiAgICBEZWJ1Z1NlcnZlclN0YXR1c1tEZWJ1Z1NlcnZlclN0YXR1c1tcIk5vdFJ1bm5pbmdcIl0gPSAzXSA9IFwiTm90UnVubmluZ1wiO1xyXG59KShEZWJ1Z1NlcnZlclN0YXR1cyB8fCAoRGVidWdTZXJ2ZXJTdGF0dXMgPSB7fSkpO1xyXG5jbGFzcyBMb2NhbERlYnVnQ2xpZW50IGV4dGVuZHMgRGVidWdDbGllbnRfMS5EZWJ1Z0NsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcmdzLCBkZWJ1Z1Nlc3Npb24sIGNhbkxhdW5jaFRlcm1pbmFsLCBsYXVuY2hlclNjcmlwdFByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoYXJncywgZGVidWdTZXNzaW9uKTtcclxuICAgICAgICB0aGlzLmNhbkxhdW5jaFRlcm1pbmFsID0gY2FuTGF1bmNoVGVybWluYWw7XHJcbiAgICAgICAgdGhpcy5sYXVuY2hlclNjcmlwdFByb3ZpZGVyID0gbGF1bmNoZXJTY3JpcHRQcm92aWRlcjtcclxuICAgIH1cclxuICAgIGdldCBkZWJ1Z1NlcnZlclN0YXR1cygpIHtcclxuICAgICAgICBpZiAodGhpcy5kZWJ1Z1NlcnZlciAmJiB0aGlzLmRlYnVnU2VydmVyLklzUnVubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gRGVidWdTZXJ2ZXJTdGF0dXMuUnVubmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGVidWdTZXJ2ZXIgJiYgIXRoaXMuZGVidWdTZXJ2ZXIuSXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBEZWJ1Z1NlcnZlclN0YXR1cy5Ob3RSdW5uaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRGVidWdTZXJ2ZXJTdGF0dXMuVW5rbm93bjtcclxuICAgIH1cclxuICAgIENyZWF0ZURlYnVnU2VydmVyKHNlcnZpY2VDb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmRlYnVnU2VydmVyID0gbmV3IExvY2FsRGVidWdTZXJ2ZXJWMl8xLkxvY2FsRGVidWdTZXJ2ZXJWMih0aGlzLmRlYnVnU2Vzc2lvbiwgdGhpcy5hcmdzLCBzZXJ2aWNlQ29udGFpbmVyKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Z1NlcnZlcjtcclxuICAgIH1cclxuICAgIGdldCBEZWJ1Z1R5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIERlYnVnQ2xpZW50XzEuRGVidWdUeXBlLkxvY2FsO1xyXG4gICAgfVxyXG4gICAgU3RvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5kZWJ1Z1NlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnU2VydmVyLlN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5kZWJ1Z1NlcnZlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucHlQcm9jKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHlQcm9jLmtpbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5weVByb2MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgZGlzcGxheUVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiAoKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5sZW5ndGggPiAwKSA/IGVycm9yLm1lc3NhZ2UgOiAnJyk7XHJcbiAgICAgICAgaWYgKGVycm9yTXNnLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5kZWJ1Z1Nlc3Npb24uc2VuZEV2ZW50KG5ldyB2c2NvZGVfZGVidWdhZGFwdGVyXzEuT3V0cHV0RXZlbnQoZXJyb3JNc2csICdzdGRlcnInKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1mdW5jLWJvZHktbGVuZ3RoIG1lbWJlci1vcmRlcmluZyBuby1hbnlcclxuICAgIExhdW5jaEFwcGxpY2F0aW9uVG9EZWJ1ZyhkYmdTZXJ2ZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoVXRpbHMgPSBuZXcgcGF0aFV0aWxzXzEuUGF0aFV0aWxzKFV0aWxzXzEuSVNfV0lORE9XUyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcm9jZXNzID0gbmV3IGN1cnJlbnRQcm9jZXNzXzEuQ3VycmVudFByb2Nlc3MoKTtcclxuICAgICAgICAgICAgY29uc3QgZW52aXJvbm1lbnRWYXJpYWJsZXNTZXJ2aWNlID0gbmV3IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnRWYXJpYWJsZXNTZXJ2aWNlKHBhdGhVdGlscyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlbHBlciA9IG5ldyBoZWxwZXJfMS5EZWJ1Z0NsaWVudEhlbHBlcihlbnZpcm9ubWVudFZhcmlhYmxlc1NlcnZpY2UsIHBhdGhVdGlscywgY3VycmVudFByb2Nlc3MpO1xyXG4gICAgICAgICAgICBjb25zdCBlbnZpcm9ubWVudFZhcmlhYmxlcyA9IHlpZWxkIGhlbHBlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh0aGlzLmFyZ3MpO1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWZ1bmMtYm9keS1sZW5ndGggY3ljbG9tYXRpYy1jb21wbGV4aXR5IG5vLWFueVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZURpciA9IHRoaXMuYXJncyAmJiB0aGlzLmFyZ3MucHJvZ3JhbSA/IHBhdGguZGlybmFtZSh0aGlzLmFyZ3MucHJvZ3JhbSkgOiAnJztcclxuICAgICAgICAgICAgICAgIGxldCBwcm9jZXNzQ3dkID0gZmlsZURpcjtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hcmdzLmN3ZCA9PT0gJ3N0cmluZycgJiYgdGhpcy5hcmdzLmN3ZC5sZW5ndGggPiAwICYmIHRoaXMuYXJncy5jd2QgIT09ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDd2QgPSB0aGlzLmFyZ3MuY3dkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHB5dGhvblBhdGggPSAncHl0aG9uJztcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hcmdzLnB5dGhvblBhdGggPT09ICdzdHJpbmcnICYmIHRoaXMuYXJncy5weXRob25QYXRoLnRyaW0oKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHl0aG9uUGF0aCA9IHRoaXMuYXJncy5weXRob25QYXRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuYnVpbGRMYXVuY2hBcmd1bWVudHMocHJvY2Vzc0N3ZCwgZGJnU2VydmVyLnBvcnQpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmFyZ3MuY29uc29sZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVybmFsVGVybWluYWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ludGVncmF0ZWRUZXJtaW5hbCc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTdWRvID0gQXJyYXkuaXNBcnJheSh0aGlzLmFyZ3MuZGVidWdPcHRpb25zKSAmJiB0aGlzLmFyZ3MuZGVidWdPcHRpb25zLnNvbWUob3B0ID0+IG9wdCA9PT0gJ1N1ZG8nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXVuY2hFeHRlcm5hbFRlcm1pbmFsKGlzU3VkbywgcHJvY2Vzc0N3ZCwgcHl0aG9uUGF0aCwgYXJncywgZW52aXJvbm1lbnRWYXJpYWJsZXMpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5weVByb2MgPSBjaGlsZF9wcm9jZXNzXzEuc3Bhd24ocHl0aG9uUGF0aCwgYXJncywgeyBjd2Q6IHByb2Nlc3NDd2QsIGVudjogZW52aXJvbm1lbnRWYXJpYWJsZXMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUHJvY2Vzc091dHB1dCh0aGlzLnB5UHJvYywgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSB3YWl0IGZvciB0aGUgYXBwbGljYXRpb24gdG8gY29ubmVjdCB0byB0aGUgc29ja2V0IHNlcnZlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBvbmNlIGNvbm5lY3RlZCBkbyB3ZSBrbm93IHRoYXQgdGhlIGFwcGxpY2F0aW9uIGhhcyBzdWNjZXNzZnVsbHkgbGF1bmNoZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdTZXJ2ZXIuRGVidWdDbGllbnRDb25uZWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXggPT4gY29uc29sZS5lcnJvcignUHl0aG9uIEV4dGVuc2lvbjogZGVidWdTZXJ2ZXIuRGVidWdDbGllbnRDb25uZWN0ZWQnLCBleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWVtYmVyLW9yZGVyaW5nXHJcbiAgICBoYW5kbGVQcm9jZXNzT3V0cHV0KHByb2MsIGZhaWxlZFRvTGF1bmNoKSB7XHJcbiAgICAgICAgcHJvYy5vbignZXJyb3InLCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIGRlYnVnIHNlcnZlciBoYXMgc3RhcnRlZCwgdGhlbiBkb24ndCBkaXNwbGF5IGVycm9ycy5cclxuICAgICAgICAgICAgLy8gVGhlIGRlYnVnIGFkYXB0ZXIgd2lsbCBnZXQgdGhpcyBpbmZvIGZyb20gdGhlIGRlYnVnZ2VyIChlLmcuIHB0dnNkIGxpYikuXHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuZGVidWdTZXJ2ZXJTdGF0dXM7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IERlYnVnU2VydmVyU3RhdHVzLlJ1bm5pbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSBEZWJ1Z1NlcnZlclN0YXR1cy5Ob3RSdW5uaW5nICYmIHR5cGVvZiAoZXJyb3IpID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWxlZFRvTGF1bmNoKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGhhcHBlbiB3aGVuIHRoZSBkZWJ1Z2dlciBkaWRuJ3QgbGF1bmNoIGF0IGFsbCwgZS5nLiBweXRob24gZG9lc24ndCBleGlzdC5cclxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByb2Muc3RkZXJyLnNldEVuY29kaW5nKCd1dGY4Jyk7XHJcbiAgICAgICAgcHJvYy5zdGRlcnIub24oJ2RhdGEnLCBtaXNjXzEubm9vcCk7XHJcbiAgICAgICAgcHJvYy5zdGRvdXQub24oJ2RhdGEnLCBkID0+IHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3Nhcnkgc28gd2UgcmVhZCB0aGUgc3Rkb3V0IG9mIHRoZSBweXRob24gcHJvY2VzcyxcclxuICAgICAgICAgICAgLy8gRWxzZSBpdCBqdXN0IGtlZXAgYnVpbGRpbmcgdXAgKHJlbGF0ZWQgdG8gaXNzdWUgIzIwMyBhbmQgIzUyKS5cclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1jb25zdCBuby11bnVzZWQtdmFyaWFibGVcclxuICAgICAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYnVpbGRMYXVuY2hBcmd1bWVudHMoY3dkLCBkZWJ1Z1BvcnQpIHtcclxuICAgICAgICByZXR1cm4gWy4uLnRoaXMuYnVpbGREZWJ1Z0FyZ3VtZW50cyhjd2QsIGRlYnVnUG9ydCksIC4uLnRoaXMuYnVpbGRTdGFuZGFyZEFyZ3VtZW50cygpXTtcclxuICAgIH1cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptZW1iZXItb3JkZXJpbmdcclxuICAgIGJ1aWxkRGVidWdBcmd1bWVudHMoY3dkLCBkZWJ1Z1BvcnQpIHtcclxuICAgICAgICBjb25zdCBwdFZTVG9vbHNGaWxlUGF0aCA9IHRoaXMubGF1bmNoZXJTY3JpcHRQcm92aWRlci5nZXRMYXVuY2hlckZpbGVQYXRoKCk7XHJcbiAgICAgICAgY29uc3QgdnNEZWJ1Z09wdGlvbnMgPSBbdHlwZXNfMS5EZWJ1Z09wdGlvbnMuUmVkaXJlY3RPdXRwdXRdO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYXJncy5kZWJ1Z09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJncy5kZWJ1Z09wdGlvbnMuZmlsdGVyKG9wdCA9PiBWQUxJRF9ERUJVR19PUFRJT05TLmluZGV4T2Yob3B0KSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goaXRlbSA9PiB2c0RlYnVnT3B0aW9ucy5wdXNoKGl0ZW0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGphbmdvSW5kZXggPSB2c0RlYnVnT3B0aW9ucy5pbmRleE9mKHR5cGVzXzEuRGVidWdPcHRpb25zLkRqYW5nbyk7XHJcbiAgICAgICAgLy8gUFRWU0QgZXhwZWN0cyB0aGUgc3RyaW5nIGBEamFuZ29EZWJ1Z2dpbmdgXHJcbiAgICAgICAgaWYgKGRqYW5nb0luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgdnNEZWJ1Z09wdGlvbnNbZGphbmdvSW5kZXhdID0gJ0RqYW5nb0RlYnVnZ2luZyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbcHRWU1Rvb2xzRmlsZVBhdGgsIGN3ZCwgZGVidWdQb3J0LnRvU3RyaW5nKCksICczNDgwNmFkOS04MzNhLTQ1MjQtOGNkNi0xOGNhNGFhNzRmMTQnLCB2c0RlYnVnT3B0aW9ucy5qb2luKCcsJyldO1xyXG4gICAgfVxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1lbWJlci1vcmRlcmluZ1xyXG4gICAgYnVpbGRTdGFuZGFyZEFyZ3VtZW50cygpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtQXJncyA9IEFycmF5LmlzQXJyYXkodGhpcy5hcmdzLmFyZ3MpICYmIHRoaXMuYXJncy5hcmdzLmxlbmd0aCA+IDAgPyB0aGlzLmFyZ3MuYXJncyA6IFtdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5hcmdzLm1vZHVsZSA9PT0gJ3N0cmluZycgJiYgdGhpcy5hcmdzLm1vZHVsZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJy1tJywgdGhpcy5hcmdzLm1vZHVsZSwgLi4ucHJvZ3JhbUFyZ3NdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5hcmdzLnByb2dyYW0gJiYgdGhpcy5hcmdzLnByb2dyYW0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuYXJncy5wcm9ncmFtLCAuLi5wcm9ncmFtQXJnc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9ncmFtQXJncztcclxuICAgIH1cclxuICAgIGxhdW5jaEV4dGVybmFsVGVybWluYWwoc3VkbywgY3dkLCBweXRob25QYXRoLCBhcmdzLCBlbnYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5MYXVuY2hUZXJtaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHN1ZG8gPyAnc3VkbycgOiBweXRob25QYXRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZEFyZ3MgPSBzdWRvID8gW3B5dGhvblBhdGhdLmNvbmNhdChhcmdzKSA6IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0V4dGVybmFsVGVybWluYWwgPSB0aGlzLmFyZ3MuY29uc29sZSA9PT0gJ2V4dGVybmFsVGVybWluYWwnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29uc29sZUtpbmQgPSBpc0V4dGVybmFsVGVybWluYWwgPyAnZXh0ZXJuYWwnIDogJ2ludGVncmF0ZWQnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVybUFyZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogY29uc29sZUtpbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdQeXRob24gRGVidWcgQ29uc29sZScsXHJcbiAgICAgICAgICAgICAgICAgICAgY3dkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtjb21tYW5kXS5jb25jYXQoY29tbWFuZEFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVudlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdTZXNzaW9uLnJ1bkluVGVybWluYWxSZXF1ZXN0KHRlcm1BcmdzLCA1MDAwLCAocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3Blbl8xLm9wZW4oeyB3YWl0OiBmYWxzZSwgYXBwOiBbcHl0aG9uUGF0aF0uY29uY2F0KGFyZ3MpLCBjd2QsIGVudiwgc3Vkbzogc3VkbyB9KS50aGVuKHByb2MgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHlQcm9jID0gcHJvYztcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdTZXJ2ZXJTdGF0dXMgPT09IERlYnVnU2VydmVyU3RhdHVzLlJ1bm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkxvY2FsRGVidWdDbGllbnQgPSBMb2NhbERlYnVnQ2xpZW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2NhbERlYnVnQ2xpZW50LmpzLm1hcCJdfQ==