// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const assert = require("assert");

const fs = require("fs-extra");

const path = require("path");

const constants_1 = require("../../client/common/constants");

const types_1 = require("../../client/common/platform/types");

const jupyterExecution_1 = require("../../client/datascience/jupyterExecution");

const jupyterProcess_1 = require("../../client/datascience/jupyterProcess");

const types_2 = require("../../client/datascience/types");

const cell_1 = require("../../datascience-ui/history-react/cell");

const mainPanelState_1 = require("../../datascience-ui/history-react/mainPanelState");

const dataScienceIocContainer_1 = require("./dataScienceIocContainer"); // tslint:disable:no-any no-multiline-string max-func-body-length no-console


suite('Jupyter notebook tests', () => {
  const disposables = [];
  let jupyterExecution;
  let jupyterServer;
  let ioc;
  setup(() => {
    ioc = new dataScienceIocContainer_1.DataScienceIocContainer();
    ioc.registerDataScienceTypes();
    jupyterServer = ioc.serviceManager.get(types_2.INotebookServer);
    jupyterExecution = ioc.serviceManager.get(types_2.IJupyterExecution);
  });
  teardown(() => {
    disposables.forEach(disposable => {
      if (disposable) {
        disposable.dispose();
      }
    });
    jupyterServer.dispose();
    ioc.dispose();
  });

  function escapePath(p) {
    return p.replace(/\\/g, '\\\\');
  }

  function srcDirectory() {
    return path.join(constants_1.EXTENSION_ROOT_DIR, 'src', 'test', 'datascience');
  }

  function assertThrows(func, message) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield func();
        assert.fail(message); // tslint:disable-next-line:no-empty
      } catch (_a) {}
    });
  }

  function verifySimple(code, expectedValue) {
    return __awaiter(this, void 0, void 0, function* () {
      const cells = yield jupyterServer.execute(code, path.join(srcDirectory(), 'foo.py'), 2);
      assert.equal(cells.length, 1, `Wrong number of cells returned`);
      assert.equal(cells[0].data.cell_type, 'code', `Wrong type of cell returned`);
      const cell = cells[0].data;
      assert.equal(cell.outputs.length, 1, `Cell length not correct`);
      const data = cell.outputs[0].data;
      const error = cell.outputs[0].evalue;

      if (error) {
        assert.fail(`Unexpected error: ${error}`);
      }

      assert.ok(data, `No data object on the cell`);

      if (data) {
        // For linter
        assert.ok(data.hasOwnProperty('text/plain'), `Cell mime type not correct`);
        assert.ok(data['text/plain'], `Cell mime type not correct`);
        assert.equal(data['text/plain'], expectedValue, 'Cell value does not match');
      }
    });
  }

  function verifyError(code, errorString) {
    return __awaiter(this, void 0, void 0, function* () {
      const cells = yield jupyterServer.execute(code, path.join(srcDirectory(), 'foo.py'), 2);
      assert.equal(cells.length, 1, `Wrong number of cells returned`);
      assert.equal(cells[0].data.cell_type, 'code', `Wrong type of cell returned`);
      const cell = cells[0].data;
      assert.equal(cell.outputs.length, 1, `Cell length not correct`);
      const error = cell.outputs[0].evalue;

      if (error) {
        assert.ok(error, 'Error not found when expected');
        assert.equal(error, errorString, 'Unexpected error found');
      }
    });
  }

  function verifyCell(index, code, mimeType, cellType, verifyValue) {
    return __awaiter(this, void 0, void 0, function* () {
      // Verify results of an execute
      const cells = yield jupyterServer.execute(code, path.join(srcDirectory(), 'foo.py'), 2);
      assert.equal(cells.length, 1, `${index}: Wrong number of cells returned`);

      if (cellType === 'code') {
        assert.equal(cells[0].data.cell_type, cellType, `${index}: Wrong type of cell returned`);
        const cell = cells[0].data;
        assert.equal(cell.outputs.length, 1, `${index}: Cell length not correct`);
        const error = cell.outputs[0].evalue;

        if (error) {
          assert.fail(`${index}: Unexpected error: ${error}`);
        }

        const data = cell.outputs[0].data;
        assert.ok(data, `${index}: No data object on the cell`);

        if (data) {
          // For linter
          assert.ok(data.hasOwnProperty(mimeType), `${index}: Cell mime type not correct`);
          assert.ok(data[mimeType], `${index}: Cell mime type not correct`);
          verifyValue(data[mimeType]);
        }
      } else if (cellType === 'markdown') {
        assert.equal(cells[0].data.cell_type, cellType, `${index}: Wrong type of cell returned`);
        const cell = cells[0].data;
        const outputSource = cell_1.Cell.concatMultilineString(cell.source);
        verifyValue(outputSource);
      } else if (cellType === 'error') {
        const cell = cells[0].data;
        assert.equal(cell.outputs.length, 1, `${index}: Cell length not correct`);
        const error = cell.outputs[0].evalue;
        assert.ok(error, 'Error not found when expected');
        verifyValue(error);
      }
    });
  }

  function testMimeTypes(types) {
    runTest('MimeTypes', () => __awaiter(this, void 0, void 0, function* () {
      // Test all mime types together so we don't have to startup and shutdown between
      // each
      const server = yield jupyterServer.start();

      if (!server) {
        assert.fail('Server not created');
      }

      let statusCount = 0;
      jupyterServer.onStatusChanged(bool => {
        statusCount += 1;
      });

      for (let i = 0; i < types.length; i += 1) {
        const prevCount = statusCount;
        yield verifyCell(i, types[i].code, types[i].mimeType, types[i].cellType, types[i].verifyValue);

        if (types[i].cellType !== 'markdown') {
          assert.ok(statusCount > prevCount, 'Status didnt update');
        }
      }
    }));
  }

  function runTest(name, func) {
    test(name, () => __awaiter(this, void 0, void 0, function* () {
      if (yield jupyterExecution.isNotebookSupported()) {
        return func();
      } else {
        // tslint:disable-next-line:no-console
        console.log(`Skipping test ${name}, no jupyter installed.`);
      }
    }));
  }

  runTest('Creation', () => __awaiter(void 0, void 0, void 0, function* () {
    const server = yield jupyterServer.start();

    if (!server) {
      assert.fail('Server not created');
    }
  }));
  runTest('Failure', () => __awaiter(void 0, void 0, void 0, function* () {
    jupyterServer.shutdown().ignoreErrors(); // Make a dummy class that will fail during launch

    class FailedProcess extends jupyterProcess_1.JupyterProcess {
      waitForConnectionInformation() {
        return Promise.reject('Failing');
      }

    }

    ioc.serviceManager.rebind(types_2.INotebookProcess, FailedProcess);
    jupyterServer = ioc.serviceManager.get(types_2.INotebookServer);
    return assertThrows(() => __awaiter(this, void 0, void 0, function* () {
      yield jupyterServer.start();
    }), 'Server start is not throwing');
  }));
  test('Not installed', () => __awaiter(void 0, void 0, void 0, function* () {
    jupyterServer.shutdown().ignoreErrors(); // Make a dummy class that will fail during launch

    class FailedAvailability extends jupyterExecution_1.JupyterExecution {
      constructor() {
        super(...arguments);

        this.isNotebookSupported = () => {
          return Promise.resolve(false);
        };
      }

    }

    ioc.serviceManager.rebind(types_2.IJupyterExecution, FailedAvailability);
    jupyterServer = ioc.serviceManager.get(types_2.INotebookServer);
    return assertThrows(() => __awaiter(this, void 0, void 0, function* () {
      yield jupyterServer.start();
    }), 'Server start is not throwing');
  }));
  runTest('Export/Import', () => __awaiter(void 0, void 0, void 0, function* () {
    const server = yield jupyterServer.start();

    if (!server) {
      assert.fail('Server not created');
    } // Get a bunch of test cells (use our test cells from the react controls)


    const testState = mainPanelState_1.generateTestState(id => {
      return;
    });
    const cells = testState.cellVMs.map((cellVM, index) => {
      return cellVM.cell;
    }); // Translate this into a notebook

    const notebook = yield jupyterServer.translateToNotebook(cells); // Save to a temp file

    const fileSystem = ioc.serviceManager.get(types_1.IFileSystem);
    const importer = ioc.serviceManager.get(types_2.INotebookImporter);
    const temp = yield fileSystem.createTemporaryFile('.ipynb');

    try {
      yield fs.writeFile(temp.filePath, JSON.stringify(notebook), 'utf8'); // Try importing this. This should verify export works and that importing is possible

      yield importer.importFromFile(temp.filePath);
    } finally {
      importer.dispose();
      temp.dispose();
    }
  }));
  runTest('Restart kernel', () => __awaiter(void 0, void 0, void 0, function* () {
    const server = yield jupyterServer.start();

    if (!server) {
      assert.fail('Server not created');
    } // Setup some state and verify output is correct


    yield verifySimple('a=1\r\na', 1);
    yield verifySimple('a+=1\r\na', 2);
    yield verifySimple('a+=4\r\na', 6);
    console.log('Waiting for idle'); // In unit tests we have to wait for status idle before restarting. Unit tests
    // seem to be timing out if the restart throws any exceptions (even if they're caught)

    yield jupyterServer.waitForIdle();
    console.log('Restarting kernel');
    yield jupyterServer.restartKernel();
    console.log('Waiting for idle');
    yield jupyterServer.waitForIdle();
    console.log('Verifying restart');
    yield verifyError('a', `name 'a' is not defined`);
  }));
  testMimeTypes([{
    code: `a=1
a`,
    mimeType: 'text/plain',
    cellType: 'code',
    verifyValue: d => assert.equal(d, 1, 'Plain text invalid')
  }, {
    code: `df = pd.read_csv("${escapePath(path.join(srcDirectory(), 'DefaultSalesReport.csv'))}")
df.head()`,
    mimeType: 'text/html',
    cellType: 'code',
    verifyValue: d => assert.ok(d.toString().includes('</td>'), 'Table not found')
  }, {
    code: `df = pd.read("${escapePath(path.join(srcDirectory(), 'DefaultSalesReport.csv'))}")
df.head()`,
    mimeType: 'text/html',
    cellType: 'error',
    verifyValue: d => assert.equal(d, `module 'pandas' has no attribute 'read'`, 'Unexpected error result')
  }, {
    code: `#%% [markdown]#
# #HEADER`,
    mimeType: 'text/plain',
    cellType: 'markdown',
    verifyValue: d => assert.equal(d, '#HEADER', 'Markdown incorrect')
  }, {
    // Test relative directories too.
    code: `df = pd.read_csv("./DefaultSalesReport.csv")
df.head()`,
    mimeType: 'text/html',
    cellType: 'code',
    verifyValue: d => assert.ok(d.toString().includes('</td>'), 'Table not found')
  }, {
    // Plotly
    code: `import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
import pandas as pd
x = np.linspace(0, 20, 100)
plt.plot(x, np.sin(x))
plt.show()`,
    mimeType: 'image/png',
    cellType: 'code',
    verifyValue: d => {
      return;
    }
  }]); // Tests that should be running:
  // - Creation
  // - Failure
  // - Not installed
  // - Different mime types
  // - Export/import
  // - Auto import
  // - changing directories
  // - Restart
  // - Error types
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vdGVib29rLmZ1bmN0aW9uYWwudGVzdC5qcyJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInZhbHVlIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiYXNzZXJ0IiwicmVxdWlyZSIsImZzIiwicGF0aCIsImNvbnN0YW50c18xIiwidHlwZXNfMSIsImp1cHl0ZXJFeGVjdXRpb25fMSIsImp1cHl0ZXJQcm9jZXNzXzEiLCJ0eXBlc18yIiwiY2VsbF8xIiwibWFpblBhbmVsU3RhdGVfMSIsImRhdGFTY2llbmNlSW9jQ29udGFpbmVyXzEiLCJzdWl0ZSIsImRpc3Bvc2FibGVzIiwianVweXRlckV4ZWN1dGlvbiIsImp1cHl0ZXJTZXJ2ZXIiLCJpb2MiLCJzZXR1cCIsIkRhdGFTY2llbmNlSW9jQ29udGFpbmVyIiwicmVnaXN0ZXJEYXRhU2NpZW5jZVR5cGVzIiwic2VydmljZU1hbmFnZXIiLCJnZXQiLCJJTm90ZWJvb2tTZXJ2ZXIiLCJJSnVweXRlckV4ZWN1dGlvbiIsInRlYXJkb3duIiwiZm9yRWFjaCIsImRpc3Bvc2FibGUiLCJkaXNwb3NlIiwiZXNjYXBlUGF0aCIsInAiLCJyZXBsYWNlIiwic3JjRGlyZWN0b3J5Iiwiam9pbiIsIkVYVEVOU0lPTl9ST09UX0RJUiIsImFzc2VydFRocm93cyIsImZ1bmMiLCJtZXNzYWdlIiwiZmFpbCIsIl9hIiwidmVyaWZ5U2ltcGxlIiwiY29kZSIsImV4cGVjdGVkVmFsdWUiLCJjZWxscyIsImV4ZWN1dGUiLCJlcXVhbCIsImxlbmd0aCIsImRhdGEiLCJjZWxsX3R5cGUiLCJjZWxsIiwib3V0cHV0cyIsImVycm9yIiwiZXZhbHVlIiwib2siLCJoYXNPd25Qcm9wZXJ0eSIsInZlcmlmeUVycm9yIiwiZXJyb3JTdHJpbmciLCJ2ZXJpZnlDZWxsIiwiaW5kZXgiLCJtaW1lVHlwZSIsImNlbGxUeXBlIiwidmVyaWZ5VmFsdWUiLCJvdXRwdXRTb3VyY2UiLCJDZWxsIiwiY29uY2F0TXVsdGlsaW5lU3RyaW5nIiwic291cmNlIiwidGVzdE1pbWVUeXBlcyIsInR5cGVzIiwicnVuVGVzdCIsInNlcnZlciIsInN0YXJ0Iiwic3RhdHVzQ291bnQiLCJvblN0YXR1c0NoYW5nZWQiLCJib29sIiwiaSIsInByZXZDb3VudCIsIm5hbWUiLCJ0ZXN0IiwiaXNOb3RlYm9va1N1cHBvcnRlZCIsImNvbnNvbGUiLCJsb2ciLCJzaHV0ZG93biIsImlnbm9yZUVycm9ycyIsIkZhaWxlZFByb2Nlc3MiLCJKdXB5dGVyUHJvY2VzcyIsIndhaXRGb3JDb25uZWN0aW9uSW5mb3JtYXRpb24iLCJyZWJpbmQiLCJJTm90ZWJvb2tQcm9jZXNzIiwiRmFpbGVkQXZhaWxhYmlsaXR5IiwiSnVweXRlckV4ZWN1dGlvbiIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwidGVzdFN0YXRlIiwiZ2VuZXJhdGVUZXN0U3RhdGUiLCJpZCIsImNlbGxWTXMiLCJtYXAiLCJjZWxsVk0iLCJub3RlYm9vayIsInRyYW5zbGF0ZVRvTm90ZWJvb2siLCJmaWxlU3lzdGVtIiwiSUZpbGVTeXN0ZW0iLCJpbXBvcnRlciIsIklOb3RlYm9va0ltcG9ydGVyIiwidGVtcCIsImNyZWF0ZVRlbXBvcmFyeUZpbGUiLCJ3cml0ZUZpbGUiLCJmaWxlUGF0aCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbXBvcnRGcm9tRmlsZSIsIndhaXRGb3JJZGxlIiwicmVzdGFydEtlcm5lbCIsImQiLCJ0b1N0cmluZyIsImluY2x1ZGVzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsU0FBUyxHQUFJLFVBQVEsU0FBS0EsU0FBZCxJQUE0QixVQUFVQyxPQUFWLEVBQW1CQyxVQUFuQixFQUErQkMsQ0FBL0Is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LHlDQUFqQixFQUEyRCx5QkFBM0Q7QUFMeEIsR0FmVSxFQXNCVjtBQUNJeEUsSUFBQUEsSUFBSSxFQUFHO0FBQ25CLFVBRlE7QUFHSWtCLElBQUFBLFFBQVEsRUFBRSxZQUhkO0FBSUlDLElBQUFBLFFBQVEsRUFBRSxVQUpkO0FBS0lDLElBQUFBLFdBQVcsRUFBR29ELENBQUQsSUFBT2hILE1BQU0sQ0FBQzRDLEtBQVAsQ0FBYW9FLENBQWIsRUFBZ0IsU0FBaEIsRUFBMkIsb0JBQTNCO0FBTHhCLEdBdEJVLEVBNkJWO0FBQ0k7QUFDQXhFLElBQUFBLElBQUksRUFBRztBQUNuQixVQUhRO0FBSUlrQixJQUFBQSxRQUFRLEVBQUUsV0FKZDtBQUtJQyxJQUFBQSxRQUFRLEVBQUUsTUFMZDtBQU1JQyxJQUFBQSxXQUFXLEVBQUdvRCxDQUFELElBQU9oSCxNQUFNLENBQUNvRCxFQUFQLENBQVU0RCxDQUFDLENBQUNDLFFBQUYsR0FBYUMsUUFBYixDQUFzQixPQUF0QixDQUFWLEVBQTBDLGlCQUExQztBQU54QixHQTdCVSxFQXFDVjtBQUNJO0FBQ0ExRSxJQUFBQSxJQUFJLEVBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBUlE7QUFTSWtCLElBQUFBLFFBQVEsRUFBRSxXQVRkO0FBVUlDLElBQUFBLFFBQVEsRUFBRSxNQVZkO0FBV0lDLElBQUFBLFdBQVcsRUFBR29ELENBQUQsSUFBTztBQUFFO0FBQVM7QUFYbkMsR0FyQ1UsQ0FBRCxDQUFiLENBNU5rQyxDQStRbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSCxDQXpSSSxDQUFMIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vY29uc3RhbnRzXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vcGxhdGZvcm0vdHlwZXNcIik7XHJcbmNvbnN0IGp1cHl0ZXJFeGVjdXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnQvZGF0YXNjaWVuY2UvanVweXRlckV4ZWN1dGlvblwiKTtcclxuY29uc3QganVweXRlclByb2Nlc3NfMSA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnQvZGF0YXNjaWVuY2UvanVweXRlclByb2Nlc3NcIik7XHJcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2RhdGFzY2llbmNlL3R5cGVzXCIpO1xyXG5jb25zdCBjZWxsXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0YXNjaWVuY2UtdWkvaGlzdG9yeS1yZWFjdC9jZWxsXCIpO1xyXG5jb25zdCBtYWluUGFuZWxTdGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2RhdGFzY2llbmNlLXVpL2hpc3RvcnktcmVhY3QvbWFpblBhbmVsU3RhdGVcIik7XHJcbmNvbnN0IGRhdGFTY2llbmNlSW9jQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9kYXRhU2NpZW5jZUlvY0NvbnRhaW5lclwiKTtcclxuLy8gdHNsaW50OmRpc2FibGU6bm8tYW55IG5vLW11bHRpbGluZS1zdHJpbmcgbWF4LWZ1bmMtYm9keS1sZW5ndGggbm8tY29uc29sZVxyXG5zdWl0ZSgnSnVweXRlciBub3RlYm9vayB0ZXN0cycsICgpID0+IHtcclxuICAgIGNvbnN0IGRpc3Bvc2FibGVzID0gW107XHJcbiAgICBsZXQganVweXRlckV4ZWN1dGlvbjtcclxuICAgIGxldCBqdXB5dGVyU2VydmVyO1xyXG4gICAgbGV0IGlvYztcclxuICAgIHNldHVwKCgpID0+IHtcclxuICAgICAgICBpb2MgPSBuZXcgZGF0YVNjaWVuY2VJb2NDb250YWluZXJfMS5EYXRhU2NpZW5jZUlvY0NvbnRhaW5lcigpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlckRhdGFTY2llbmNlVHlwZXMoKTtcclxuICAgICAgICBqdXB5dGVyU2VydmVyID0gaW9jLnNlcnZpY2VNYW5hZ2VyLmdldCh0eXBlc18yLklOb3RlYm9va1NlcnZlcik7XHJcbiAgICAgICAganVweXRlckV4ZWN1dGlvbiA9IGlvYy5zZXJ2aWNlTWFuYWdlci5nZXQodHlwZXNfMi5JSnVweXRlckV4ZWN1dGlvbik7XHJcbiAgICB9KTtcclxuICAgIHRlYXJkb3duKCgpID0+IHtcclxuICAgICAgICBkaXNwb3NhYmxlcy5mb3JFYWNoKGRpc3Bvc2FibGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZGlzcG9zYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBqdXB5dGVyU2VydmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICBpb2MuZGlzcG9zZSgpO1xyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBlc2NhcGVQYXRoKHApIHtcclxuICAgICAgICByZXR1cm4gcC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3JjRGlyZWN0b3J5KCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoLmpvaW4oY29uc3RhbnRzXzEuRVhURU5TSU9OX1JPT1RfRElSLCAnc3JjJywgJ3Rlc3QnLCAnZGF0YXNjaWVuY2UnKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzc2VydFRocm93cyhmdW5jLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIGZ1bmMoKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5mYWlsKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHZlcmlmeVNpbXBsZShjb2RlLCBleHBlY3RlZFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSB5aWVsZCBqdXB5dGVyU2VydmVyLmV4ZWN1dGUoY29kZSwgcGF0aC5qb2luKHNyY0RpcmVjdG9yeSgpLCAnZm9vLnB5JyksIDIpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2VsbHMubGVuZ3RoLCAxLCBgV3JvbmcgbnVtYmVyIG9mIGNlbGxzIHJldHVybmVkYCk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChjZWxsc1swXS5kYXRhLmNlbGxfdHlwZSwgJ2NvZGUnLCBgV3JvbmcgdHlwZSBvZiBjZWxsIHJldHVybmVkYCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxsc1swXS5kYXRhO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2VsbC5vdXRwdXRzLmxlbmd0aCwgMSwgYENlbGwgbGVuZ3RoIG5vdCBjb3JyZWN0YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjZWxsLm91dHB1dHNbMF0uZGF0YTtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjZWxsLm91dHB1dHNbMF0uZXZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5mYWlsKGBVbmV4cGVjdGVkIGVycm9yOiAke2Vycm9yfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydC5vayhkYXRhLCBgTm8gZGF0YSBvYmplY3Qgb24gdGhlIGNlbGxgKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEpIHsgLy8gRm9yIGxpbnRlclxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGRhdGEuaGFzT3duUHJvcGVydHkoJ3RleHQvcGxhaW4nKSwgYENlbGwgbWltZSB0eXBlIG5vdCBjb3JyZWN0YCk7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQub2soZGF0YVsndGV4dC9wbGFpbiddLCBgQ2VsbCBtaW1lIHR5cGUgbm90IGNvcnJlY3RgKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhWyd0ZXh0L3BsYWluJ10sIGV4cGVjdGVkVmFsdWUsICdDZWxsIHZhbHVlIGRvZXMgbm90IG1hdGNoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHZlcmlmeUVycm9yKGNvZGUsIGVycm9yU3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSB5aWVsZCBqdXB5dGVyU2VydmVyLmV4ZWN1dGUoY29kZSwgcGF0aC5qb2luKHNyY0RpcmVjdG9yeSgpLCAnZm9vLnB5JyksIDIpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2VsbHMubGVuZ3RoLCAxLCBgV3JvbmcgbnVtYmVyIG9mIGNlbGxzIHJldHVybmVkYCk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChjZWxsc1swXS5kYXRhLmNlbGxfdHlwZSwgJ2NvZGUnLCBgV3JvbmcgdHlwZSBvZiBjZWxsIHJldHVybmVkYCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxsc1swXS5kYXRhO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2VsbC5vdXRwdXRzLmxlbmd0aCwgMSwgYENlbGwgbGVuZ3RoIG5vdCBjb3JyZWN0YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2VsbC5vdXRwdXRzWzBdLmV2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQub2soZXJyb3IsICdFcnJvciBub3QgZm91bmQgd2hlbiBleHBlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGVycm9yLCBlcnJvclN0cmluZywgJ1VuZXhwZWN0ZWQgZXJyb3IgZm91bmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdmVyaWZ5Q2VsbChpbmRleCwgY29kZSwgbWltZVR5cGUsIGNlbGxUeXBlLCB2ZXJpZnlWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSByZXN1bHRzIG9mIGFuIGV4ZWN1dGVcclxuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSB5aWVsZCBqdXB5dGVyU2VydmVyLmV4ZWN1dGUoY29kZSwgcGF0aC5qb2luKHNyY0RpcmVjdG9yeSgpLCAnZm9vLnB5JyksIDIpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2VsbHMubGVuZ3RoLCAxLCBgJHtpbmRleH06IFdyb25nIG51bWJlciBvZiBjZWxscyByZXR1cm5lZGApO1xyXG4gICAgICAgICAgICBpZiAoY2VsbFR5cGUgPT09ICdjb2RlJykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNlbGxzWzBdLmRhdGEuY2VsbF90eXBlLCBjZWxsVHlwZSwgYCR7aW5kZXh9OiBXcm9uZyB0eXBlIG9mIGNlbGwgcmV0dXJuZWRgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxsc1swXS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNlbGwub3V0cHV0cy5sZW5ndGgsIDEsIGAke2luZGV4fTogQ2VsbCBsZW5ndGggbm90IGNvcnJlY3RgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2VsbC5vdXRwdXRzWzBdLmV2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5mYWlsKGAke2luZGV4fTogVW5leHBlY3RlZCBlcnJvcjogJHtlcnJvcn1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjZWxsLm91dHB1dHNbMF0uZGF0YTtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5vayhkYXRhLCBgJHtpbmRleH06IE5vIGRhdGEgb2JqZWN0IG9uIHRoZSBjZWxsYCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkgeyAvLyBGb3IgbGludGVyXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGRhdGEuaGFzT3duUHJvcGVydHkobWltZVR5cGUpLCBgJHtpbmRleH06IENlbGwgbWltZSB0eXBlIG5vdCBjb3JyZWN0YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGRhdGFbbWltZVR5cGVdLCBgJHtpbmRleH06IENlbGwgbWltZSB0eXBlIG5vdCBjb3JyZWN0YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVyaWZ5VmFsdWUoZGF0YVttaW1lVHlwZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNlbGxUeXBlID09PSAnbWFya2Rvd24nKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2VsbHNbMF0uZGF0YS5jZWxsX3R5cGUsIGNlbGxUeXBlLCBgJHtpbmRleH06IFdyb25nIHR5cGUgb2YgY2VsbCByZXR1cm5lZGApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxzWzBdLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRTb3VyY2UgPSBjZWxsXzEuQ2VsbC5jb25jYXRNdWx0aWxpbmVTdHJpbmcoY2VsbC5zb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgdmVyaWZ5VmFsdWUob3V0cHV0U291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjZWxsVHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxzWzBdLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2VsbC5vdXRwdXRzLmxlbmd0aCwgMSwgYCR7aW5kZXh9OiBDZWxsIGxlbmd0aCBub3QgY29ycmVjdGApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjZWxsLm91dHB1dHNbMF0uZXZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGVycm9yLCAnRXJyb3Igbm90IGZvdW5kIHdoZW4gZXhwZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIHZlcmlmeVZhbHVlKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGVzdE1pbWVUeXBlcyh0eXBlcykge1xyXG4gICAgICAgIHJ1blRlc3QoJ01pbWVUeXBlcycsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gVGVzdCBhbGwgbWltZSB0eXBlcyB0b2dldGhlciBzbyB3ZSBkb24ndCBoYXZlIHRvIHN0YXJ0dXAgYW5kIHNodXRkb3duIGJldHdlZW5cclxuICAgICAgICAgICAgLy8gZWFjaFxyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXIgPSB5aWVsZCBqdXB5dGVyU2VydmVyLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIGlmICghc2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbCgnU2VydmVyIG5vdCBjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHN0YXR1c0NvdW50ID0gMDtcclxuICAgICAgICAgICAganVweXRlclNlcnZlci5vblN0YXR1c0NoYW5nZWQoKGJvb2wpID0+IHtcclxuICAgICAgICAgICAgICAgIHN0YXR1c0NvdW50ICs9IDE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q291bnQgPSBzdGF0dXNDb3VudDtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHZlcmlmeUNlbGwoaSwgdHlwZXNbaV0uY29kZSwgdHlwZXNbaV0ubWltZVR5cGUsIHR5cGVzW2ldLmNlbGxUeXBlLCB0eXBlc1tpXS52ZXJpZnlWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZXNbaV0uY2VsbFR5cGUgIT09ICdtYXJrZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soc3RhdHVzQ291bnQgPiBwcmV2Q291bnQsICdTdGF0dXMgZGlkbnQgdXBkYXRlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBydW5UZXN0KG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICB0ZXN0KG5hbWUsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKHlpZWxkIGp1cHl0ZXJFeGVjdXRpb24uaXNOb3RlYm9va1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuYygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTa2lwcGluZyB0ZXN0ICR7bmFtZX0sIG5vIGp1cHl0ZXIgaW5zdGFsbGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgcnVuVGVzdCgnQ3JlYXRpb24nLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyID0geWllbGQganVweXRlclNlcnZlci5zdGFydCgpO1xyXG4gICAgICAgIGlmICghc2VydmVyKSB7XHJcbiAgICAgICAgICAgIGFzc2VydC5mYWlsKCdTZXJ2ZXIgbm90IGNyZWF0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9KSk7XHJcbiAgICBydW5UZXN0KCdGYWlsdXJlJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGp1cHl0ZXJTZXJ2ZXIuc2h1dGRvd24oKS5pZ25vcmVFcnJvcnMoKTtcclxuICAgICAgICAvLyBNYWtlIGEgZHVtbXkgY2xhc3MgdGhhdCB3aWxsIGZhaWwgZHVyaW5nIGxhdW5jaFxyXG4gICAgICAgIGNsYXNzIEZhaWxlZFByb2Nlc3MgZXh0ZW5kcyBqdXB5dGVyUHJvY2Vzc18xLkp1cHl0ZXJQcm9jZXNzIHtcclxuICAgICAgICAgICAgd2FpdEZvckNvbm5lY3Rpb25JbmZvcm1hdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnRmFpbGluZycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlvYy5zZXJ2aWNlTWFuYWdlci5yZWJpbmQodHlwZXNfMi5JTm90ZWJvb2tQcm9jZXNzLCBGYWlsZWRQcm9jZXNzKTtcclxuICAgICAgICBqdXB5dGVyU2VydmVyID0gaW9jLnNlcnZpY2VNYW5hZ2VyLmdldCh0eXBlc18yLklOb3RlYm9va1NlcnZlcik7XHJcbiAgICAgICAgcmV0dXJuIGFzc2VydFRocm93cygoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGp1cHl0ZXJTZXJ2ZXIuc3RhcnQoKTtcclxuICAgICAgICB9KSwgJ1NlcnZlciBzdGFydCBpcyBub3QgdGhyb3dpbmcnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ05vdCBpbnN0YWxsZWQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAganVweXRlclNlcnZlci5zaHV0ZG93bigpLmlnbm9yZUVycm9ycygpO1xyXG4gICAgICAgIC8vIE1ha2UgYSBkdW1teSBjbGFzcyB0aGF0IHdpbGwgZmFpbCBkdXJpbmcgbGF1bmNoXHJcbiAgICAgICAgY2xhc3MgRmFpbGVkQXZhaWxhYmlsaXR5IGV4dGVuZHMganVweXRlckV4ZWN1dGlvbl8xLkp1cHl0ZXJFeGVjdXRpb24ge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTm90ZWJvb2tTdXBwb3J0ZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlvYy5zZXJ2aWNlTWFuYWdlci5yZWJpbmQodHlwZXNfMi5JSnVweXRlckV4ZWN1dGlvbiwgRmFpbGVkQXZhaWxhYmlsaXR5KTtcclxuICAgICAgICBqdXB5dGVyU2VydmVyID0gaW9jLnNlcnZpY2VNYW5hZ2VyLmdldCh0eXBlc18yLklOb3RlYm9va1NlcnZlcik7XHJcbiAgICAgICAgcmV0dXJuIGFzc2VydFRocm93cygoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGp1cHl0ZXJTZXJ2ZXIuc3RhcnQoKTtcclxuICAgICAgICB9KSwgJ1NlcnZlciBzdGFydCBpcyBub3QgdGhyb3dpbmcnKTtcclxuICAgIH0pKTtcclxuICAgIHJ1blRlc3QoJ0V4cG9ydC9JbXBvcnQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyID0geWllbGQganVweXRlclNlcnZlci5zdGFydCgpO1xyXG4gICAgICAgIGlmICghc2VydmVyKSB7XHJcbiAgICAgICAgICAgIGFzc2VydC5mYWlsKCdTZXJ2ZXIgbm90IGNyZWF0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IGEgYnVuY2ggb2YgdGVzdCBjZWxscyAodXNlIG91ciB0ZXN0IGNlbGxzIGZyb20gdGhlIHJlYWN0IGNvbnRyb2xzKVxyXG4gICAgICAgIGNvbnN0IHRlc3RTdGF0ZSA9IG1haW5QYW5lbFN0YXRlXzEuZ2VuZXJhdGVUZXN0U3RhdGUoaWQgPT4geyByZXR1cm47IH0pO1xyXG4gICAgICAgIGNvbnN0IGNlbGxzID0gdGVzdFN0YXRlLmNlbGxWTXMubWFwKChjZWxsVk0sIGluZGV4KSA9PiB7IHJldHVybiBjZWxsVk0uY2VsbDsgfSk7XHJcbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoaXMgaW50byBhIG5vdGVib29rXHJcbiAgICAgICAgY29uc3Qgbm90ZWJvb2sgPSB5aWVsZCBqdXB5dGVyU2VydmVyLnRyYW5zbGF0ZVRvTm90ZWJvb2soY2VsbHMpO1xyXG4gICAgICAgIC8vIFNhdmUgdG8gYSB0ZW1wIGZpbGVcclxuICAgICAgICBjb25zdCBmaWxlU3lzdGVtID0gaW9jLnNlcnZpY2VNYW5hZ2VyLmdldCh0eXBlc18xLklGaWxlU3lzdGVtKTtcclxuICAgICAgICBjb25zdCBpbXBvcnRlciA9IGlvYy5zZXJ2aWNlTWFuYWdlci5nZXQodHlwZXNfMi5JTm90ZWJvb2tJbXBvcnRlcik7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IHlpZWxkIGZpbGVTeXN0ZW0uY3JlYXRlVGVtcG9yYXJ5RmlsZSgnLmlweW5iJyk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgeWllbGQgZnMud3JpdGVGaWxlKHRlbXAuZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KG5vdGVib29rKSwgJ3V0ZjgnKTtcclxuICAgICAgICAgICAgLy8gVHJ5IGltcG9ydGluZyB0aGlzLiBUaGlzIHNob3VsZCB2ZXJpZnkgZXhwb3J0IHdvcmtzIGFuZCB0aGF0IGltcG9ydGluZyBpcyBwb3NzaWJsZVxyXG4gICAgICAgICAgICB5aWVsZCBpbXBvcnRlci5pbXBvcnRGcm9tRmlsZSh0ZW1wLmZpbGVQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIGltcG9ydGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGVtcC5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSkpO1xyXG4gICAgcnVuVGVzdCgnUmVzdGFydCBrZXJuZWwnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyID0geWllbGQganVweXRlclNlcnZlci5zdGFydCgpO1xyXG4gICAgICAgIGlmICghc2VydmVyKSB7XHJcbiAgICAgICAgICAgIGFzc2VydC5mYWlsKCdTZXJ2ZXIgbm90IGNyZWF0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2V0dXAgc29tZSBzdGF0ZSBhbmQgdmVyaWZ5IG91dHB1dCBpcyBjb3JyZWN0XHJcbiAgICAgICAgeWllbGQgdmVyaWZ5U2ltcGxlKCdhPTFcXHJcXG5hJywgMSk7XHJcbiAgICAgICAgeWllbGQgdmVyaWZ5U2ltcGxlKCdhKz0xXFxyXFxuYScsIDIpO1xyXG4gICAgICAgIHlpZWxkIHZlcmlmeVNpbXBsZSgnYSs9NFxcclxcbmEnLCA2KTtcclxuICAgICAgICBjb25zb2xlLmxvZygnV2FpdGluZyBmb3IgaWRsZScpO1xyXG4gICAgICAgIC8vIEluIHVuaXQgdGVzdHMgd2UgaGF2ZSB0byB3YWl0IGZvciBzdGF0dXMgaWRsZSBiZWZvcmUgcmVzdGFydGluZy4gVW5pdCB0ZXN0c1xyXG4gICAgICAgIC8vIHNlZW0gdG8gYmUgdGltaW5nIG91dCBpZiB0aGUgcmVzdGFydCB0aHJvd3MgYW55IGV4Y2VwdGlvbnMgKGV2ZW4gaWYgdGhleSdyZSBjYXVnaHQpXHJcbiAgICAgICAgeWllbGQganVweXRlclNlcnZlci53YWl0Rm9ySWRsZSgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXN0YXJ0aW5nIGtlcm5lbCcpO1xyXG4gICAgICAgIHlpZWxkIGp1cHl0ZXJTZXJ2ZXIucmVzdGFydEtlcm5lbCgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXYWl0aW5nIGZvciBpZGxlJyk7XHJcbiAgICAgICAgeWllbGQganVweXRlclNlcnZlci53YWl0Rm9ySWRsZSgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgcmVzdGFydCcpO1xyXG4gICAgICAgIHlpZWxkIHZlcmlmeUVycm9yKCdhJywgYG5hbWUgJ2EnIGlzIG5vdCBkZWZpbmVkYCk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0TWltZVR5cGVzKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvZGU6IGBhPTFcclxuYWAsXHJcbiAgICAgICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXHJcbiAgICAgICAgICAgIGNlbGxUeXBlOiAnY29kZScsXHJcbiAgICAgICAgICAgIHZlcmlmeVZhbHVlOiAoZCkgPT4gYXNzZXJ0LmVxdWFsKGQsIDEsICdQbGFpbiB0ZXh0IGludmFsaWQnKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb2RlOiBgZGYgPSBwZC5yZWFkX2NzdihcIiR7ZXNjYXBlUGF0aChwYXRoLmpvaW4oc3JjRGlyZWN0b3J5KCksICdEZWZhdWx0U2FsZXNSZXBvcnQuY3N2JykpfVwiKVxyXG5kZi5oZWFkKClgLFxyXG4gICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvaHRtbCcsXHJcbiAgICAgICAgICAgIGNlbGxUeXBlOiAnY29kZScsXHJcbiAgICAgICAgICAgIHZlcmlmeVZhbHVlOiAoZCkgPT4gYXNzZXJ0Lm9rKGQudG9TdHJpbmcoKS5pbmNsdWRlcygnPC90ZD4nKSwgJ1RhYmxlIG5vdCBmb3VuZCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvZGU6IGBkZiA9IHBkLnJlYWQoXCIke2VzY2FwZVBhdGgocGF0aC5qb2luKHNyY0RpcmVjdG9yeSgpLCAnRGVmYXVsdFNhbGVzUmVwb3J0LmNzdicpKX1cIilcclxuZGYuaGVhZCgpYCxcclxuICAgICAgICAgICAgbWltZVR5cGU6ICd0ZXh0L2h0bWwnLFxyXG4gICAgICAgICAgICBjZWxsVHlwZTogJ2Vycm9yJyxcclxuICAgICAgICAgICAgdmVyaWZ5VmFsdWU6IChkKSA9PiBhc3NlcnQuZXF1YWwoZCwgYG1vZHVsZSAncGFuZGFzJyBoYXMgbm8gYXR0cmlidXRlICdyZWFkJ2AsICdVbmV4cGVjdGVkIGVycm9yIHJlc3VsdCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvZGU6IGAjJSUgW21hcmtkb3duXSNcclxuIyAjSEVBREVSYCxcclxuICAgICAgICAgICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcclxuICAgICAgICAgICAgY2VsbFR5cGU6ICdtYXJrZG93bicsXHJcbiAgICAgICAgICAgIHZlcmlmeVZhbHVlOiAoZCkgPT4gYXNzZXJ0LmVxdWFsKGQsICcjSEVBREVSJywgJ01hcmtkb3duIGluY29ycmVjdCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRlc3QgcmVsYXRpdmUgZGlyZWN0b3JpZXMgdG9vLlxyXG4gICAgICAgICAgICBjb2RlOiBgZGYgPSBwZC5yZWFkX2NzdihcIi4vRGVmYXVsdFNhbGVzUmVwb3J0LmNzdlwiKVxyXG5kZi5oZWFkKClgLFxyXG4gICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvaHRtbCcsXHJcbiAgICAgICAgICAgIGNlbGxUeXBlOiAnY29kZScsXHJcbiAgICAgICAgICAgIHZlcmlmeVZhbHVlOiAoZCkgPT4gYXNzZXJ0Lm9rKGQudG9TdHJpbmcoKS5pbmNsdWRlcygnPC90ZD4nKSwgJ1RhYmxlIG5vdCBmb3VuZCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFBsb3RseVxyXG4gICAgICAgICAgICBjb2RlOiBgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdFxyXG5pbXBvcnQgbWF0cGxvdGxpYiBhcyBtcGxcclxuaW1wb3J0IG51bXB5IGFzIG5wXHJcbmltcG9ydCBwYW5kYXMgYXMgcGRcclxueCA9IG5wLmxpbnNwYWNlKDAsIDIwLCAxMDApXHJcbnBsdC5wbG90KHgsIG5wLnNpbih4KSlcclxucGx0LnNob3coKWAsXHJcbiAgICAgICAgICAgIG1pbWVUeXBlOiAnaW1hZ2UvcG5nJyxcclxuICAgICAgICAgICAgY2VsbFR5cGU6ICdjb2RlJyxcclxuICAgICAgICAgICAgdmVyaWZ5VmFsdWU6IChkKSA9PiB7IHJldHVybjsgfVxyXG4gICAgICAgIH1cclxuICAgIF0pO1xyXG4gICAgLy8gVGVzdHMgdGhhdCBzaG91bGQgYmUgcnVubmluZzpcclxuICAgIC8vIC0gQ3JlYXRpb25cclxuICAgIC8vIC0gRmFpbHVyZVxyXG4gICAgLy8gLSBOb3QgaW5zdGFsbGVkXHJcbiAgICAvLyAtIERpZmZlcmVudCBtaW1lIHR5cGVzXHJcbiAgICAvLyAtIEV4cG9ydC9pbXBvcnRcclxuICAgIC8vIC0gQXV0byBpbXBvcnRcclxuICAgIC8vIC0gY2hhbmdpbmcgZGlyZWN0b3JpZXNcclxuICAgIC8vIC0gUmVzdGFydFxyXG4gICAgLy8gLSBFcnJvciB0eXBlc1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90ZWJvb2suZnVuY3Rpb25hbC50ZXN0LmpzLm1hcCJdfQ==