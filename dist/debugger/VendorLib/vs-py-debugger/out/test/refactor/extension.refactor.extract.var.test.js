"use strict"; // tslint:disable:interface-name no-any max-func-body-length estrict-plus-operands no-empty

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const assert = require("assert");

const fs = require("fs-extra");

const path = require("path");

const vscode_1 = require("vscode");

const configSettings_1 = require("../../client/common/configSettings");

const editor_1 = require("../../client/common/editor");

const simpleRefactorProvider_1 = require("../../client/providers/simpleRefactorProvider");

const proxy_1 = require("../../client/refactor/proxy");

const common_1 = require("../common");

const serviceRegistry_1 = require("../unittests/serviceRegistry");

const initialize_1 = require("./../initialize");

const mockClasses_1 = require("./../mockClasses");

const EXTENSION_DIR = path.join(__dirname, '..', '..', '..');
const refactorSourceFile = path.join(__dirname, '..', '..', '..', 'src', 'test', 'pythonFiles', 'refactoring', 'standAlone', 'refactor.py');
const refactorTargetFileDir = path.join(__dirname, '..', '..', '..', 'out', 'test', 'pythonFiles', 'refactoring', 'standAlone');
suite('Variable Extraction', () => {
  // Hack hac hack
  const oldExecuteCommand = vscode_1.commands.executeCommand;
  const options = {
    cursorStyle: vscode_1.TextEditorCursorStyle.Line,
    insertSpaces: true,
    lineNumbers: vscode_1.TextEditorLineNumbersStyle.Off,
    tabSize: 4
  };
  let refactorTargetFile = '';
  let ioc;
  suiteSetup(initialize_1.initialize);
  suiteTeardown(() => {
    vscode_1.commands.executeCommand = oldExecuteCommand;
    return initialize_1.closeActiveWindows();
  });
  setup(() => __awaiter(void 0, void 0, void 0, function* () {
    initializeDI();
    refactorTargetFile = path.join(refactorTargetFileDir, `refactor${new Date().getTime()}.py`);
    fs.copySync(refactorSourceFile, refactorTargetFile, {
      overwrite: true
    });
    yield initialize_1.initializeTest();

    vscode_1.commands.executeCommand = cmd => Promise.resolve();
  }));
  teardown(() => __awaiter(void 0, void 0, void 0, function* () {
    vscode_1.commands.executeCommand = oldExecuteCommand;

    try {
      yield fs.unlink(refactorTargetFile);
    } catch (_a) {}

    yield initialize_1.closeActiveWindows();
  }));

  function initializeDI() {
    ioc = new serviceRegistry_1.UnitTestIocContainer();
    ioc.registerCommonTypes();
    ioc.registerProcessTypes();
    ioc.registerVariableTypes();
  }

  function testingVariableExtraction(shouldError, startPos, endPos) {
    return __awaiter(this, void 0, void 0, function* () {
      const pythonSettings = configSettings_1.PythonSettings.getInstance(vscode_1.Uri.file(refactorTargetFile));
      const rangeOfTextToExtract = new vscode_1.Range(startPos, endPos);
      const proxy = new proxy_1.RefactorProxy(EXTENSION_DIR, pythonSettings, path.dirname(refactorTargetFile), ioc.serviceContainer);
      const DIFF = '--- a/refactor.py\n+++ b/refactor.py\n@@ -232,7 +232,8 @@\n         sys.stdout.flush()\n \n     def watch(self):\n-        self._write_response("STARTED")\n+        myNewVariable = "STARTED"\n+        self._write_response(myNewVariable)\n         while True:\n             try:\n                 self._process_request(self._input.readline())\n';
      const mockTextDoc = yield vscode_1.workspace.openTextDocument(refactorTargetFile);
      const expectedTextEdits = editor_1.getTextEditsFromPatch(mockTextDoc.getText(), DIFF);

      try {
        const response = yield proxy.extractVariable(mockTextDoc, 'myNewVariable', refactorTargetFile, rangeOfTextToExtract, options);

        if (shouldError) {
          assert.fail('No error', 'Error', 'Extraction should fail with an error', '');
        }

        const textEdits = editor_1.getTextEditsFromPatch(mockTextDoc.getText(), DIFF);
        assert.equal(response.results.length, 1, 'Invalid number of items in response');
        assert.equal(textEdits.length, expectedTextEdits.length, 'Invalid number of Text Edits');
        textEdits.forEach(edit => {
          const foundEdit = expectedTextEdits.filter(item => item.newText === edit.newText && item.range.isEqual(edit.range));
          assert.equal(foundEdit.length, 1, 'Edit not found');
        });
      } catch (error) {
        if (!shouldError) {
          assert.equal('Error', 'No error', `${error}`);
        }
      }
    });
  } // tslint:disable-next-line:no-function-expression


  test('Extract Variable', function () {
    return __awaiter(this, void 0, void 0, function* () {
      if (common_1.isPythonVersion('3.7')) {
        // tslint:disable-next-line:no-invalid-this
        return this.skip();
      } else {
        const startPos = new vscode_1.Position(234, 29);
        const endPos = new vscode_1.Position(234, 38);
        yield testingVariableExtraction(false, startPos, endPos);
      }
    });
  });
  test('Extract Variable fails if whole string not selected', () => __awaiter(void 0, void 0, void 0, function* () {
    const startPos = new vscode_1.Position(234, 20);
    const endPos = new vscode_1.Position(234, 38);
    yield testingVariableExtraction(true, startPos, endPos);
  }));

  function testingVariableExtractionEndToEnd(shouldError, startPos, endPos) {
    return __awaiter(this, void 0, void 0, function* () {
      const ch = new mockClasses_1.MockOutputChannel('Python');
      const rangeOfTextToExtract = new vscode_1.Range(startPos, endPos);
      const textDocument = yield vscode_1.workspace.openTextDocument(refactorTargetFile);
      const editor = yield vscode_1.window.showTextDocument(textDocument);
      editor.selections = [new vscode_1.Selection(rangeOfTextToExtract.start, rangeOfTextToExtract.end)];
      editor.selection = new vscode_1.Selection(rangeOfTextToExtract.start, rangeOfTextToExtract.end);

      try {
        yield simpleRefactorProvider_1.extractVariable(EXTENSION_DIR, editor, rangeOfTextToExtract, ch, ioc.serviceContainer);

        if (shouldError) {
          assert.fail('No error', 'Error', 'Extraction should fail with an error', '');
        }

        assert.equal(ch.output.length, 0, 'Output channel is not empty');
        const newVarDefLine = textDocument.lineAt(editor.selection.start);
        const newVarRefLine = textDocument.lineAt(newVarDefLine.lineNumber + 1);
        assert.equal(newVarDefLine.text.trim().indexOf('newvariable'), 0, 'New Variable not created');
        assert.equal(newVarDefLine.text.trim().endsWith('= "STARTED"'), true, 'Started Text Assigned to variable');
        assert.equal(newVarRefLine.text.indexOf('(newvariable') >= 0, true, 'New Variable not being used');
      } catch (error) {
        if (!shouldError) {
          assert.fail('Error', 'No error', `${error}`);
        }
      }
    });
  } // This test fails on linux (text document not getting updated in time)


  if (!initialize_1.IS_CI_SERVER) {
    test('Extract Variable (end to end)', () => __awaiter(void 0, void 0, void 0, function* () {
      const startPos = new vscode_1.Position(234, 29);
      const endPos = new vscode_1.Position(234, 38);
      yield testingVariableExtractionEndToEnd(false, startPos, endPos);
    }));
  }

  test('Extract Variable fails if whole string not selected (end to end)', () => __awaiter(void 0, void 0, void 0, function* () {
    const startPos = new vscode_1.Position(234, 20);
    const endPos = new vscode_1.Position(234, 38);
    yield testingVariableExtractionEndToEnd(true, startPos, endPos);
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV4dGVuc2lvbi5yZWZhY3Rvci5leHRyYWN0LnZhci50ZXN0LmpzIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJhc3NlcnQiLCJyZXF1aXJlIiwiZnMiLCJwYXRoIiwidnNjb2RlXzEiLCJjb25maWdTZXR0aW5nc18xIiwiZWRpdG9yXzEiLCJzaW1wbGVSZWZhY3RvclByb3ZpZGVyXzEiLCJwcm94eV8xIiwiY29tbW9uXzEiLCJzZXJ2aWNlUmVnaXN0cnlfMSIsImluaXRpYWxpemVfMSIsIm1vY2tDbGFzc2VzXzEiLCJFWFRFTlNJT05fRElSIiwiam9pbiIsIl9fZGlybmFtZSIsInJlZmFjdG9yU291cmNlRmlsZSIsInJlZmFjdG9yVGFyZ2V0RmlsZURpciIsInN1aXRlIiwib2xkRXhlY3V0ZUNvbW1hbmQiLCJjb21tYW5kcyIsImV4ZWN1dGVDb21tYW5kIiwib3B0aW9ucyIsImN1cnNvclN0eWxlIiwiVGV4dEVkaXRvckN1cnNvclN0eWxlIiwiTGluZSIsImluc2VydFNwYWNlcyIsImxpbmVOdW1iZXJzIiwiVGV4dEVkaXRvckxpbmVOdW1iZXJzU3R5bGUiLCJPZmYiLCJ0YWJTaXplIiwicmVmYWN0b3JUYXJnZXRGaWxlIiwiaW9jIiwic3VpdGVTZXR1cCIsImluaXRpYWxpemUiLCJzdWl0ZVRlYXJkb3duIiwiY2xvc2VBY3RpdmVXaW5kb3dzIiwic2V0dXAiLCJpbml0aWFsaXplREkiLCJEYXRlIiwiZ2V0VGltZSIsImNvcHlTeW5jIiwib3ZlcndyaXRlIiwiaW5pdGlhbGl6ZVRlc3QiLCJjbWQiLCJ0ZWFyZG93biIsInVubGluayIsIl9hIiwiVW5pdFRlc3RJb2NDb250YWluZXIiLCJyZWdpc3RlckNvbW1vblR5cGVzIiwicmVnaXN0ZXJQcm9jZXNzVHlwZXMiLCJyZWdpc3RlclZhcmlhYmxlVHlwZXMiLCJ0ZXN0aW5nVmFyaWFibGVFeHRyYWN0aW9uIiwic2hvdWxkRXJyb3IiLCJzdGFydFBvcyIsImVuZFBvcyIsInB5dGhvblNldHRpbmdzIiwiUHl0aG9uU2V0dGluZ3MiLCJnZXRJbnN0YW5jZSIsIlVyaSIsImZpbGUiLCJyYW5nZU9mVGV4dFRvRXh0cmFjdCIsIlJhbmdlIiwicHJveHkiLCJSZWZhY3RvclByb3h5IiwiZGlybmFtZSIsInNlcnZpY2VDb250YWluZXIiLCJESUZGIiwibW9ja1RleHREb2MiLCJ3b3Jrc3BhY2UiLCJvcGVuVGV4dERvY3VtZW50IiwiZXhwZWN0ZWRUZXh0RWRpdHMiLCJnZXRUZXh0RWRpdHNGcm9tUGF0Y2giLCJnZXRUZXh0IiwicmVzcG9uc2UiLCJleHRyYWN0VmFyaWFibGUiLCJmYWlsIiwidGV4dEVkaXRzIiwiZXF1YWwiLCJyZXN1bHRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImVkaXQiLCJmb3VuZEVkaXQiLCJmaWx0ZXIiLCJpdGVtIiwibmV3VGV4dCIsInJhbmdlIiwiaXNFcXVhbCIsImVycm9yIiwidGVzdCIsImlzUHl0aG9uVmVyc2lvbiIsInNraXAiLCJQb3NpdGlvbiIsInRlc3RpbmdWYXJpYWJsZUV4dHJhY3Rpb25FbmRUb0VuZCIsImNoIiwiTW9ja091dHB1dENoYW5uZWwiLCJ0ZXh0RG9jdW1lbnQiLCJlZGl0b3IiLCJ3aW5kb3ciLCJzaG93VGV4dERvY3VtZW50Iiwic2VsZWN0aW9ucyIsIlNlbGVjdGlvbiIsInN0YXJ0IiwiZW5kIiwic2VsZWN0aW9uIiwib3V0cHV0IiwibmV3VmFyRGVmTGluZSIsImxpbmVBdCIsIm5ld1ZhclJlZkxpbmUiLCJsaW5lTnVtYmVyIiwidGV4dCIsInRyaW0iLCJpbmRleE9mIiwiZW5kc1dpdGgiLCJJU19DSV9TRVJWRVIiXSwibWFwcGluZ3Mi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LENBQXNCLEdBQXRCLEVBQTJCLEVBQTNCLENBQWpCO0FBQ0EsVUFBTXRDLE1BQU0sR0FBRyxJQUFJbkQsUUFBUSxDQUFDeUYsUUFBYixDQUFzQixHQUF0QixFQUEyQixFQUEzQixDQUFmO0FBQ0EsVUFBTUMsaUNBQWlDLENBQUMsSUFBRCxFQUFPeEMsUUFBUCxFQUFpQkMsTUFBakIsQ0FBdkM7QUFDSCxHQUp1RixDQUFwRixDQUFKO0FBS0gsQ0F2SEksQ0FBTCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZTppbnRlcmZhY2UtbmFtZSBuby1hbnkgbWF4LWZ1bmMtYm9keS1sZW5ndGggZXN0cmljdC1wbHVzLW9wZXJhbmRzIG5vLWVtcHR5XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCBjb25maWdTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vY29uZmlnU2V0dGluZ3NcIik7XHJcbmNvbnN0IGVkaXRvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vZWRpdG9yXCIpO1xyXG5jb25zdCBzaW1wbGVSZWZhY3RvclByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3Byb3ZpZGVycy9zaW1wbGVSZWZhY3RvclByb3ZpZGVyXCIpO1xyXG5jb25zdCBwcm94eV8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9yZWZhY3Rvci9wcm94eVwiKTtcclxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xyXG5jb25zdCBzZXJ2aWNlUmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuLi91bml0dGVzdHMvc2VydmljZVJlZ2lzdHJ5XCIpO1xyXG5jb25zdCBpbml0aWFsaXplXzEgPSByZXF1aXJlKFwiLi8uLi9pbml0aWFsaXplXCIpO1xyXG5jb25zdCBtb2NrQ2xhc3Nlc18xID0gcmVxdWlyZShcIi4vLi4vbW9ja0NsYXNzZXNcIik7XHJcbmNvbnN0IEVYVEVOU0lPTl9ESVIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nKTtcclxuY29uc3QgcmVmYWN0b3JTb3VyY2VGaWxlID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJywgJ3NyYycsICd0ZXN0JywgJ3B5dGhvbkZpbGVzJywgJ3JlZmFjdG9yaW5nJywgJ3N0YW5kQWxvbmUnLCAncmVmYWN0b3IucHknKTtcclxuY29uc3QgcmVmYWN0b3JUYXJnZXRGaWxlRGlyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJywgJ291dCcsICd0ZXN0JywgJ3B5dGhvbkZpbGVzJywgJ3JlZmFjdG9yaW5nJywgJ3N0YW5kQWxvbmUnKTtcclxuc3VpdGUoJ1ZhcmlhYmxlIEV4dHJhY3Rpb24nLCAoKSA9PiB7XHJcbiAgICAvLyBIYWNrIGhhYyBoYWNrXHJcbiAgICBjb25zdCBvbGRFeGVjdXRlQ29tbWFuZCA9IHZzY29kZV8xLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgY3Vyc29yU3R5bGU6IHZzY29kZV8xLlRleHRFZGl0b3JDdXJzb3JTdHlsZS5MaW5lLCBpbnNlcnRTcGFjZXM6IHRydWUsIGxpbmVOdW1iZXJzOiB2c2NvZGVfMS5UZXh0RWRpdG9yTGluZU51bWJlcnNTdHlsZS5PZmYsIHRhYlNpemU6IDQgfTtcclxuICAgIGxldCByZWZhY3RvclRhcmdldEZpbGUgPSAnJztcclxuICAgIGxldCBpb2M7XHJcbiAgICBzdWl0ZVNldHVwKGluaXRpYWxpemVfMS5pbml0aWFsaXplKTtcclxuICAgIHN1aXRlVGVhcmRvd24oKCkgPT4ge1xyXG4gICAgICAgIHZzY29kZV8xLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kID0gb2xkRXhlY3V0ZUNvbW1hbmQ7XHJcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVfMS5jbG9zZUFjdGl2ZVdpbmRvd3MoKTtcclxuICAgIH0pO1xyXG4gICAgc2V0dXAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGluaXRpYWxpemVESSgpO1xyXG4gICAgICAgIHJlZmFjdG9yVGFyZ2V0RmlsZSA9IHBhdGguam9pbihyZWZhY3RvclRhcmdldEZpbGVEaXIsIGByZWZhY3RvciR7bmV3IERhdGUoKS5nZXRUaW1lKCl9LnB5YCk7XHJcbiAgICAgICAgZnMuY29weVN5bmMocmVmYWN0b3JTb3VyY2VGaWxlLCByZWZhY3RvclRhcmdldEZpbGUsIHsgb3ZlcndyaXRlOiB0cnVlIH0pO1xyXG4gICAgICAgIHlpZWxkIGluaXRpYWxpemVfMS5pbml0aWFsaXplVGVzdCgpO1xyXG4gICAgICAgIHZzY29kZV8xLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kID0gKGNtZCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZWFyZG93bigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdnNjb2RlXzEuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmQgPSBvbGRFeGVjdXRlQ29tbWFuZDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB5aWVsZCBmcy51bmxpbmsocmVmYWN0b3JUYXJnZXRGaWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cclxuICAgICAgICB5aWVsZCBpbml0aWFsaXplXzEuY2xvc2VBY3RpdmVXaW5kb3dzKCk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplREkoKSB7XHJcbiAgICAgICAgaW9jID0gbmV3IHNlcnZpY2VSZWdpc3RyeV8xLlVuaXRUZXN0SW9jQ29udGFpbmVyKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyQ29tbW9uVHlwZXMoKTtcclxuICAgICAgICBpb2MucmVnaXN0ZXJQcm9jZXNzVHlwZXMoKTtcclxuICAgICAgICBpb2MucmVnaXN0ZXJWYXJpYWJsZVR5cGVzKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0ZXN0aW5nVmFyaWFibGVFeHRyYWN0aW9uKHNob3VsZEVycm9yLCBzdGFydFBvcywgZW5kUG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHl0aG9uU2V0dGluZ3MgPSBjb25maWdTZXR0aW5nc18xLlB5dGhvblNldHRpbmdzLmdldEluc3RhbmNlKHZzY29kZV8xLlVyaS5maWxlKHJlZmFjdG9yVGFyZ2V0RmlsZSkpO1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZU9mVGV4dFRvRXh0cmFjdCA9IG5ldyB2c2NvZGVfMS5SYW5nZShzdGFydFBvcywgZW5kUG9zKTtcclxuICAgICAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgcHJveHlfMS5SZWZhY3RvclByb3h5KEVYVEVOU0lPTl9ESVIsIHB5dGhvblNldHRpbmdzLCBwYXRoLmRpcm5hbWUocmVmYWN0b3JUYXJnZXRGaWxlKSwgaW9jLnNlcnZpY2VDb250YWluZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBESUZGID0gJy0tLSBhL3JlZmFjdG9yLnB5XFxuKysrIGIvcmVmYWN0b3IucHlcXG5AQCAtMjMyLDcgKzIzMiw4IEBAXFxuICAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpXFxuIFxcbiAgICAgZGVmIHdhdGNoKHNlbGYpOlxcbi0gICAgICAgIHNlbGYuX3dyaXRlX3Jlc3BvbnNlKFwiU1RBUlRFRFwiKVxcbisgICAgICAgIG15TmV3VmFyaWFibGUgPSBcIlNUQVJURURcIlxcbisgICAgICAgIHNlbGYuX3dyaXRlX3Jlc3BvbnNlKG15TmV3VmFyaWFibGUpXFxuICAgICAgICAgd2hpbGUgVHJ1ZTpcXG4gICAgICAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgICAgICAgc2VsZi5fcHJvY2Vzc19yZXF1ZXN0KHNlbGYuX2lucHV0LnJlYWRsaW5lKCkpXFxuJztcclxuICAgICAgICAgICAgY29uc3QgbW9ja1RleHREb2MgPSB5aWVsZCB2c2NvZGVfMS53b3Jrc3BhY2Uub3BlblRleHREb2N1bWVudChyZWZhY3RvclRhcmdldEZpbGUpO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFRleHRFZGl0cyA9IGVkaXRvcl8xLmdldFRleHRFZGl0c0Zyb21QYXRjaChtb2NrVGV4dERvYy5nZXRUZXh0KCksIERJRkYpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBwcm94eS5leHRyYWN0VmFyaWFibGUobW9ja1RleHREb2MsICdteU5ld1ZhcmlhYmxlJywgcmVmYWN0b3JUYXJnZXRGaWxlLCByYW5nZU9mVGV4dFRvRXh0cmFjdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbCgnTm8gZXJyb3InLCAnRXJyb3InLCAnRXh0cmFjdGlvbiBzaG91bGQgZmFpbCB3aXRoIGFuIGVycm9yJywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEVkaXRzID0gZWRpdG9yXzEuZ2V0VGV4dEVkaXRzRnJvbVBhdGNoKG1vY2tUZXh0RG9jLmdldFRleHQoKSwgRElGRik7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVzcG9uc2UucmVzdWx0cy5sZW5ndGgsIDEsICdJbnZhbGlkIG51bWJlciBvZiBpdGVtcyBpbiByZXNwb25zZScpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHRleHRFZGl0cy5sZW5ndGgsIGV4cGVjdGVkVGV4dEVkaXRzLmxlbmd0aCwgJ0ludmFsaWQgbnVtYmVyIG9mIFRleHQgRWRpdHMnKTtcclxuICAgICAgICAgICAgICAgIHRleHRFZGl0cy5mb3JFYWNoKGVkaXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kRWRpdCA9IGV4cGVjdGVkVGV4dEVkaXRzLmZpbHRlcihpdGVtID0+IGl0ZW0ubmV3VGV4dCA9PT0gZWRpdC5uZXdUZXh0ICYmIGl0ZW0ucmFuZ2UuaXNFcXVhbChlZGl0LnJhbmdlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZvdW5kRWRpdC5sZW5ndGgsIDEsICdFZGl0IG5vdCBmb3VuZCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKCdFcnJvcicsICdObyBlcnJvcicsIGAke2Vycm9yfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZnVuY3Rpb24tZXhwcmVzc2lvblxyXG4gICAgdGVzdCgnRXh0cmFjdCBWYXJpYWJsZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoY29tbW9uXzEuaXNQeXRob25WZXJzaW9uKCczLjcnKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGhpc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBuZXcgdnNjb2RlXzEuUG9zaXRpb24oMjM0LCAyOSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRQb3MgPSBuZXcgdnNjb2RlXzEuUG9zaXRpb24oMjM0LCAzOCk7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB0ZXN0aW5nVmFyaWFibGVFeHRyYWN0aW9uKGZhbHNlLCBzdGFydFBvcywgZW5kUG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB0ZXN0KCdFeHRyYWN0IFZhcmlhYmxlIGZhaWxzIGlmIHdob2xlIHN0cmluZyBub3Qgc2VsZWN0ZWQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBuZXcgdnNjb2RlXzEuUG9zaXRpb24oMjM0LCAyMCk7XHJcbiAgICAgICAgY29uc3QgZW5kUG9zID0gbmV3IHZzY29kZV8xLlBvc2l0aW9uKDIzNCwgMzgpO1xyXG4gICAgICAgIHlpZWxkIHRlc3RpbmdWYXJpYWJsZUV4dHJhY3Rpb24odHJ1ZSwgc3RhcnRQb3MsIGVuZFBvcyk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiB0ZXN0aW5nVmFyaWFibGVFeHRyYWN0aW9uRW5kVG9FbmQoc2hvdWxkRXJyb3IsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaCA9IG5ldyBtb2NrQ2xhc3Nlc18xLk1vY2tPdXRwdXRDaGFubmVsKCdQeXRob24nKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VPZlRleHRUb0V4dHJhY3QgPSBuZXcgdnNjb2RlXzEuUmFuZ2Uoc3RhcnRQb3MsIGVuZFBvcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHREb2N1bWVudCA9IHlpZWxkIHZzY29kZV8xLndvcmtzcGFjZS5vcGVuVGV4dERvY3VtZW50KHJlZmFjdG9yVGFyZ2V0RmlsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHlpZWxkIHZzY29kZV8xLndpbmRvdy5zaG93VGV4dERvY3VtZW50KHRleHREb2N1bWVudCk7XHJcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb25zID0gW25ldyB2c2NvZGVfMS5TZWxlY3Rpb24ocmFuZ2VPZlRleHRUb0V4dHJhY3Quc3RhcnQsIHJhbmdlT2ZUZXh0VG9FeHRyYWN0LmVuZCldO1xyXG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbmV3IHZzY29kZV8xLlNlbGVjdGlvbihyYW5nZU9mVGV4dFRvRXh0cmFjdC5zdGFydCwgcmFuZ2VPZlRleHRUb0V4dHJhY3QuZW5kKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHNpbXBsZVJlZmFjdG9yUHJvdmlkZXJfMS5leHRyYWN0VmFyaWFibGUoRVhURU5TSU9OX0RJUiwgZWRpdG9yLCByYW5nZU9mVGV4dFRvRXh0cmFjdCwgY2gsIGlvYy5zZXJ2aWNlQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5mYWlsKCdObyBlcnJvcicsICdFcnJvcicsICdFeHRyYWN0aW9uIHNob3VsZCBmYWlsIHdpdGggYW4gZXJyb3InLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2gub3V0cHV0Lmxlbmd0aCwgMCwgJ091dHB1dCBjaGFubmVsIGlzIG5vdCBlbXB0eScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFyRGVmTGluZSA9IHRleHREb2N1bWVudC5saW5lQXQoZWRpdG9yLnNlbGVjdGlvbi5zdGFydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYXJSZWZMaW5lID0gdGV4dERvY3VtZW50LmxpbmVBdChuZXdWYXJEZWZMaW5lLmxpbmVOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuZXdWYXJEZWZMaW5lLnRleHQudHJpbSgpLmluZGV4T2YoJ25ld3ZhcmlhYmxlJyksIDAsICdOZXcgVmFyaWFibGUgbm90IGNyZWF0ZWQnKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuZXdWYXJEZWZMaW5lLnRleHQudHJpbSgpLmVuZHNXaXRoKCc9IFwiU1RBUlRFRFwiJyksIHRydWUsICdTdGFydGVkIFRleHQgQXNzaWduZWQgdG8gdmFyaWFibGUnKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuZXdWYXJSZWZMaW5lLnRleHQuaW5kZXhPZignKG5ld3ZhcmlhYmxlJykgPj0gMCwgdHJ1ZSwgJ05ldyBWYXJpYWJsZSBub3QgYmVpbmcgdXNlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5mYWlsKCdFcnJvcicsICdObyBlcnJvcicsIGAke2Vycm9yfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIHRlc3QgZmFpbHMgb24gbGludXggKHRleHQgZG9jdW1lbnQgbm90IGdldHRpbmcgdXBkYXRlZCBpbiB0aW1lKVxyXG4gICAgaWYgKCFpbml0aWFsaXplXzEuSVNfQ0lfU0VSVkVSKSB7XHJcbiAgICAgICAgdGVzdCgnRXh0cmFjdCBWYXJpYWJsZSAoZW5kIHRvIGVuZCknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gbmV3IHZzY29kZV8xLlBvc2l0aW9uKDIzNCwgMjkpO1xyXG4gICAgICAgICAgICBjb25zdCBlbmRQb3MgPSBuZXcgdnNjb2RlXzEuUG9zaXRpb24oMjM0LCAzOCk7XHJcbiAgICAgICAgICAgIHlpZWxkIHRlc3RpbmdWYXJpYWJsZUV4dHJhY3Rpb25FbmRUb0VuZChmYWxzZSwgc3RhcnRQb3MsIGVuZFBvcyk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgdGVzdCgnRXh0cmFjdCBWYXJpYWJsZSBmYWlscyBpZiB3aG9sZSBzdHJpbmcgbm90IHNlbGVjdGVkIChlbmQgdG8gZW5kKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBzdGFydFBvcyA9IG5ldyB2c2NvZGVfMS5Qb3NpdGlvbigyMzQsIDIwKTtcclxuICAgICAgICBjb25zdCBlbmRQb3MgPSBuZXcgdnNjb2RlXzEuUG9zaXRpb24oMjM0LCAzOCk7XHJcbiAgICAgICAgeWllbGQgdGVzdGluZ1ZhcmlhYmxlRXh0cmFjdGlvbkVuZFRvRW5kKHRydWUsIHN0YXJ0UG9zLCBlbmRQb3MpO1xyXG4gICAgfSkpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZW5zaW9uLnJlZmFjdG9yLmV4dHJhY3QudmFyLnRlc3QuanMubWFwIl19