"use strict"; // tslint:disable:interface-name no-any max-func-body-length estrict-plus-operands no-empty

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const assert = require("assert");

const fs = require("fs-extra");

const path = require("path");

const vscode = require("vscode");

const configSettings_1 = require("../../client/common/configSettings");

const editor_1 = require("../../client/common/editor");

const simpleRefactorProvider_1 = require("../../client/providers/simpleRefactorProvider");

const proxy_1 = require("../../client/refactor/proxy");

const serviceRegistry_1 = require("../unittests/serviceRegistry");

const initialize_1 = require("./../initialize");

const mockClasses_1 = require("./../mockClasses");

const EXTENSION_DIR = path.join(__dirname, '..', '..', '..');
const refactorSourceFile = path.join(__dirname, '..', '..', '..', 'src', 'test', 'pythonFiles', 'refactoring', 'standAlone', 'refactor.py');
const refactorTargetFileDir = path.join(__dirname, '..', '..', '..', 'out', 'test', 'pythonFiles', 'refactoring', 'standAlone');
suite('Method Extraction', () => {
  // Hack hac hack
  const oldExecuteCommand = vscode.commands.executeCommand;
  const options = {
    cursorStyle: vscode.TextEditorCursorStyle.Line,
    insertSpaces: true,
    lineNumbers: vscode.TextEditorLineNumbersStyle.Off,
    tabSize: 4
  };
  let refactorTargetFile = '';
  let ioc;
  suiteSetup(initialize_1.initialize);
  suiteTeardown(() => {
    vscode.commands.executeCommand = oldExecuteCommand;
    return initialize_1.closeActiveWindows();
  });
  setup(() => __awaiter(void 0, void 0, void 0, function* () {
    initializeDI();
    refactorTargetFile = path.join(refactorTargetFileDir, `refactor${new Date().getTime()}.py`);
    fs.copySync(refactorSourceFile, refactorTargetFile, {
      overwrite: true
    });
    yield initialize_1.initializeTest();

    vscode.commands.executeCommand = cmd => Promise.resolve();
  }));
  teardown(() => __awaiter(void 0, void 0, void 0, function* () {
    vscode.commands.executeCommand = oldExecuteCommand;

    try {
      yield fs.unlink(refactorTargetFile);
    } catch (_a) {}

    yield initialize_1.closeActiveWindows();
  }));

  function initializeDI() {
    ioc = new serviceRegistry_1.UnitTestIocContainer();
    ioc.registerCommonTypes();
    ioc.registerProcessTypes();
    ioc.registerVariableTypes();
  }

  function testingMethodExtraction(shouldError, startPos, endPos) {
    return __awaiter(this, void 0, void 0, function* () {
      const pythonSettings = configSettings_1.PythonSettings.getInstance(vscode.Uri.file(refactorTargetFile));
      const rangeOfTextToExtract = new vscode.Range(startPos, endPos);
      const proxy = new proxy_1.RefactorProxy(EXTENSION_DIR, pythonSettings, path.dirname(refactorTargetFile), ioc.serviceContainer); // tslint:disable-next-line:no-multiline-string

      const DIFF = `--- a/refactor.py\n+++ b/refactor.py\n@@ -237,9 +237,12 @@\n             try:\n                 self._process_request(self._input.readline())\n             except Exception as ex:\n-                message = ex.message + '  \\n' + traceback.format_exc()\n-                sys.stderr.write(str(len(message)) + ':' + message)\n-                sys.stderr.flush()\n+                self.myNewMethod(ex)\n+\n+    def myNewMethod(self, ex):\n+        message = ex.message + '  \\n' + traceback.format_exc()\n+        sys.stderr.write(str(len(message)) + ':' + message)\n+        sys.stderr.flush()\n \n if __name__ == '__main__':\n     RopeRefactoring().watch()\n`;
      const mockTextDoc = yield vscode.workspace.openTextDocument(refactorTargetFile);
      const expectedTextEdits = editor_1.getTextEditsFromPatch(mockTextDoc.getText(), DIFF);

      try {
        const response = yield proxy.extractMethod(mockTextDoc, 'myNewMethod', refactorTargetFile, rangeOfTextToExtract, options);

        if (shouldError) {
          assert.fail('No error', 'Error', 'Extraction should fail with an error', '');
        }

        const textEdits = editor_1.getTextEditsFromPatch(mockTextDoc.getText(), DIFF);
        assert.equal(response.results.length, 1, 'Invalid number of items in response');
        assert.equal(textEdits.length, expectedTextEdits.length, 'Invalid number of Text Edits');
        textEdits.forEach(edit => {
          const foundEdit = expectedTextEdits.filter(item => item.newText === edit.newText && item.range.isEqual(edit.range));
          assert.equal(foundEdit.length, 1, 'Edit not found');
        });
      } catch (error) {
        if (!shouldError) {
          // Wait a minute this shouldn't work, what's going on
          assert.equal('Error', 'No error', `${error}`);
        }
      }
    });
  }

  test('Extract Method', () => __awaiter(void 0, void 0, void 0, function* () {
    const startPos = new vscode.Position(239, 0);
    const endPos = new vscode.Position(241, 35);
    yield testingMethodExtraction(false, startPos, endPos);
  }));
  test('Extract Method will fail if complete statements are not selected', () => __awaiter(void 0, void 0, void 0, function* () {
    const startPos = new vscode.Position(239, 30);
    const endPos = new vscode.Position(241, 35);
    yield testingMethodExtraction(true, startPos, endPos);
  }));

  function testingMethodExtractionEndToEnd(shouldError, startPos, endPos) {
    return __awaiter(this, void 0, void 0, function* () {
      const ch = new mockClasses_1.MockOutputChannel('Python');
      const rangeOfTextToExtract = new vscode.Range(startPos, endPos);
      const textDocument = yield vscode.workspace.openTextDocument(refactorTargetFile);
      const editor = yield vscode.window.showTextDocument(textDocument);
      editor.selections = [new vscode.Selection(rangeOfTextToExtract.start, rangeOfTextToExtract.end)];
      editor.selection = new vscode.Selection(rangeOfTextToExtract.start, rangeOfTextToExtract.end);

      try {
        yield simpleRefactorProvider_1.extractMethod(EXTENSION_DIR, editor, rangeOfTextToExtract, ch, ioc.serviceContainer);

        if (shouldError) {
          assert.fail('No error', 'Error', 'Extraction should fail with an error', '');
        }

        const newMethodRefLine = textDocument.lineAt(editor.selection.start);
        assert.equal(ch.output.length, 0, 'Output channel is not empty');
        assert.equal(textDocument.lineAt(newMethodRefLine.lineNumber + 2).text.trim().indexOf('def newmethod'), 0, 'New Method not created');
        assert.equal(newMethodRefLine.text.trim().startsWith('self.newmethod'), true, 'New Method not being used');
      } catch (error) {
        if (!shouldError) {
          assert.equal('Error', 'No error', `${error}`);
        }
      }
    });
  } // This test fails on linux (text document not getting updated in time)


  test('Extract Method (end to end)', () => __awaiter(void 0, void 0, void 0, function* () {
    const startPos = new vscode.Position(239, 0);
    const endPos = new vscode.Position(241, 35);
    yield testingMethodExtractionEndToEnd(false, startPos, endPos);
  }));
  test('Extract Method will fail if complete statements are not selected', () => __awaiter(void 0, void 0, void 0, function* () {
    const startPos = new vscode.Position(239, 30);
    const endPos = new vscode.Position(241, 35);
    yield testingMethodExtractionEndToEnd(true, startPos, endPos);
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV4dGVuc2lvbi5yZWZhY3Rvci5leHRyYWN0Lm1ldGhvZC50ZXN0LmpzIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJhc3NlcnQiLCJyZXF1aXJlIiwiZnMiLCJwYXRoIiwidnNjb2RlIiwiY29uZmlnU2V0dGluZ3NfMSIsImVkaXRvcl8xIiwic2ltcGxlUmVmYWN0b3JQcm92aWRlcl8xIiwicHJveHlfMSIsInNlcnZpY2VSZWdpc3RyeV8xIiwiaW5pdGlhbGl6ZV8xIiwibW9ja0NsYXNzZXNfMSIsIkVYVEVOU0lPTl9ESVIiLCJqb2luIiwiX19kaXJuYW1lIiwicmVmYWN0b3JTb3VyY2VGaWxlIiwicmVmYWN0b3JUYXJnZXRGaWxlRGlyIiwic3VpdGUiLCJvbGRFeGVjdXRlQ29tbWFuZCIsImNvbW1hbmRzIiwiZXhlY3V0ZUNvbW1hbmQiLCJvcHRpb25zIiwiY3Vyc29yU3R5bGUiLCJUZXh0RWRpdG9yQ3Vyc29yU3R5bGUiLCJMaW5lIiwiaW5zZXJ0U3BhY2VzIiwibGluZU51bWJlcnMiLCJUZXh0RWRpdG9yTGluZU51bWJlcnNTdHlsZSIsIk9mZiIsInRhYlNpemUiLCJyZWZhY3RvclRhcmdldEZpbGUiLCJpb2MiLCJzdWl0ZVNldHVwIiwiaW5pdGlhbGl6ZSIsInN1aXRlVGVhcmRvd24iLCJjbG9zZUFjdGl2ZVdpbmRvd3MiLCJzZXR1cCIsImluaXRpYWxpemVESSIsIkRhdGUiLCJnZXRUaW1lIiwiY29weVN5bmMiLCJvdmVyd3JpdGUiLCJpbml0aWFsaXplVGVzdCIsImNtZCIsInRlYXJkb3duIiwidW5saW5rIiwiX2EiLCJVbml0VGVzdElvY0NvbnRhaW5lciIsInJlZ2lzdGVyQ29tbW9uVHlwZXMiLCJyZWdpc3RlclByb2Nlc3NUeXBlcyIsInJlZ2lzdGVyVmFyaWFibGVUeXBlcyIsInRlc3RpbmdNZXRob2RFeHRyYWN0aW9uIiwic2hvdWxkRXJyb3IiLCJzdGFydFBvcyIsImVuZFBvcyIsInB5dGhvblNldHRpbmdzIiwiUHl0aG9uU2V0dGluZ3MiLCJnZXRJbnN0YW5jZSIsIlVyaSIsImZpbGUiLCJyYW5nZU9mVGV4dFRvRXh0cmFjdCIsIlJhbmdlIiwicHJveHkiLCJSZWZhY3RvclByb3h5IiwiZGlybmFtZSIsInNlcnZpY2VDb250YWluZXIiLCJESUZGIiwibW9ja1RleHREb2MiLCJ3b3Jrc3BhY2UiLCJvcGVuVGV4dERvY3VtZW50IiwiZXhwZWN0ZWRUZXh0RWRpdHMiLCJnZXRUZXh0RWRpdHNGcm9tUGF0Y2giLCJnZXRUZXh0IiwicmVzcG9uc2UiLCJleHRyYWN0TWV0aG9kIiwiZmFpbCIsInRleHRFZGl0cyIsImVxdWFsIiwicmVzdWx0cyIsImxlbmd0aCIsImZvckVhY2giLCJlZGl0IiwiZm91bmRFZGl0IiwiZmlsdGVyIiwiaXRlbSIsIm5ld1RleHQiLCJyYW5nZSIsImlzRXF1YWwiLCJlcnJvciIsInRlc3QiLCJQb3NpdGlvbiIsInRlc3RpbmdNZXRob2RFeHRyYWN0aW9uRW5kVG9FbmQiLCJjaCIsIk1vY2tPdXRwdXRDaGFubmVsIiwidGV4dERvY3VtZW50IiwiZWRpdG9yIiwid2luZG93Iiwic2hvd1RleHREb2N1bWVudCIsInNlbGVjdGlvbnMiLCJTZWxlY3Rpb24iLCJzdGFydCIsImVuZCIsInNlbGVjdGlvbiIsIm5ld01ldGhvZFJlZkxpbmUiLCJsaW5lQXQiLCJvdXRwdXQiLCJsaW5lTnVtYmVyIiwidGV4dCIsInRyaW0iLCJpbmRleE9mIiwic3RhcnRzV2l0aCJdLCJtYXBwaW5ncyI6IkFBQUEsYSxDQUNBOztBQUNBLElBQUlBLFNBQVMsR0FBSSxVQUFRLFNBQUtBLFNBQWQsSUFBNEIsVUFBVUMsT0FB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LENBaUc3Qjs7O0FBQ0FDLEVBQUFBLElBQUksQ0FBQyw2QkFBRCxFQUFnQyxNQUFNOUcsU0FBUyxTQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsYUFBYTtBQUNuRixVQUFNMEUsUUFBUSxHQUFHLElBQUlqRCxNQUFNLENBQUNzRixRQUFYLENBQW9CLEdBQXBCLEVBQXlCLENBQXpCLENBQWpCO0FBQ0EsVUFBTXBDLE1BQU0sR0FBRyxJQUFJbEQsTUFBTSxDQUFDc0YsUUFBWCxDQUFvQixHQUFwQixFQUF5QixFQUF6QixDQUFmO0FBQ0EsVUFBTUMsK0JBQStCLENBQUMsS0FBRCxFQUFRdEMsUUFBUixFQUFrQkMsTUFBbEIsQ0FBckM7QUFDSCxHQUprRCxDQUEvQyxDQUFKO0FBS0FtQyxFQUFBQSxJQUFJLENBQUMsa0VBQUQsRUFBcUUsTUFBTTlHLFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDeEgsVUFBTTBFLFFBQVEsR0FBRyxJQUFJakQsTUFBTSxDQUFDc0YsUUFBWCxDQUFvQixHQUFwQixFQUF5QixFQUF6QixDQUFqQjtBQUNBLFVBQU1wQyxNQUFNLEdBQUcsSUFBSWxELE1BQU0sQ0FBQ3NGLFFBQVgsQ0FBb0IsR0FBcEIsRUFBeUIsRUFBekIsQ0FBZjtBQUNBLFVBQU1DLCtCQUErQixDQUFDLElBQUQsRUFBT3RDLFFBQVAsRUFBaUJDLE1BQWpCLENBQXJDO0FBQ0gsR0FKdUYsQ0FBcEYsQ0FBSjtBQUtILENBNUdJLENBQUwiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLy8gdHNsaW50OmRpc2FibGU6aW50ZXJmYWNlLW5hbWUgbm8tYW55IG1heC1mdW5jLWJvZHktbGVuZ3RoIGVzdHJpY3QtcGx1cy1vcGVyYW5kcyBuby1lbXB0eVxyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IHZzY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IGNvbmZpZ1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbW1vbi9jb25maWdTZXR0aW5nc1wiKTtcclxuY29uc3QgZWRpdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbW1vbi9lZGl0b3JcIik7XHJcbmNvbnN0IHNpbXBsZVJlZmFjdG9yUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnQvcHJvdmlkZXJzL3NpbXBsZVJlZmFjdG9yUHJvdmlkZXJcIik7XHJcbmNvbnN0IHByb3h5XzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3JlZmFjdG9yL3Byb3h5XCIpO1xyXG5jb25zdCBzZXJ2aWNlUmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuLi91bml0dGVzdHMvc2VydmljZVJlZ2lzdHJ5XCIpO1xyXG5jb25zdCBpbml0aWFsaXplXzEgPSByZXF1aXJlKFwiLi8uLi9pbml0aWFsaXplXCIpO1xyXG5jb25zdCBtb2NrQ2xhc3Nlc18xID0gcmVxdWlyZShcIi4vLi4vbW9ja0NsYXNzZXNcIik7XHJcbmNvbnN0IEVYVEVOU0lPTl9ESVIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nKTtcclxuY29uc3QgcmVmYWN0b3JTb3VyY2VGaWxlID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJywgJ3NyYycsICd0ZXN0JywgJ3B5dGhvbkZpbGVzJywgJ3JlZmFjdG9yaW5nJywgJ3N0YW5kQWxvbmUnLCAncmVmYWN0b3IucHknKTtcclxuY29uc3QgcmVmYWN0b3JUYXJnZXRGaWxlRGlyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJywgJ291dCcsICd0ZXN0JywgJ3B5dGhvbkZpbGVzJywgJ3JlZmFjdG9yaW5nJywgJ3N0YW5kQWxvbmUnKTtcclxuc3VpdGUoJ01ldGhvZCBFeHRyYWN0aW9uJywgKCkgPT4ge1xyXG4gICAgLy8gSGFjayBoYWMgaGFja1xyXG4gICAgY29uc3Qgb2xkRXhlY3V0ZUNvbW1hbmQgPSB2c2NvZGUuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmQ7XHJcbiAgICBjb25zdCBvcHRpb25zID0geyBjdXJzb3JTdHlsZTogdnNjb2RlLlRleHRFZGl0b3JDdXJzb3JTdHlsZS5MaW5lLCBpbnNlcnRTcGFjZXM6IHRydWUsIGxpbmVOdW1iZXJzOiB2c2NvZGUuVGV4dEVkaXRvckxpbmVOdW1iZXJzU3R5bGUuT2ZmLCB0YWJTaXplOiA0IH07XHJcbiAgICBsZXQgcmVmYWN0b3JUYXJnZXRGaWxlID0gJyc7XHJcbiAgICBsZXQgaW9jO1xyXG4gICAgc3VpdGVTZXR1cChpbml0aWFsaXplXzEuaW5pdGlhbGl6ZSk7XHJcbiAgICBzdWl0ZVRlYXJkb3duKCgpID0+IHtcclxuICAgICAgICB2c2NvZGUuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmQgPSBvbGRFeGVjdXRlQ29tbWFuZDtcclxuICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZV8xLmNsb3NlQWN0aXZlV2luZG93cygpO1xyXG4gICAgfSk7XHJcbiAgICBzZXR1cCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZURJKCk7XHJcbiAgICAgICAgcmVmYWN0b3JUYXJnZXRGaWxlID0gcGF0aC5qb2luKHJlZmFjdG9yVGFyZ2V0RmlsZURpciwgYHJlZmFjdG9yJHtuZXcgRGF0ZSgpLmdldFRpbWUoKX0ucHlgKTtcclxuICAgICAgICBmcy5jb3B5U3luYyhyZWZhY3RvclNvdXJjZUZpbGUsIHJlZmFjdG9yVGFyZ2V0RmlsZSwgeyBvdmVyd3JpdGU6IHRydWUgfSk7XHJcbiAgICAgICAgeWllbGQgaW5pdGlhbGl6ZV8xLmluaXRpYWxpemVUZXN0KCk7XHJcbiAgICAgICAgdnNjb2RlLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kID0gKGNtZCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZWFyZG93bigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdnNjb2RlLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kID0gb2xkRXhlY3V0ZUNvbW1hbmQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgeWllbGQgZnMudW5saW5rKHJlZmFjdG9yVGFyZ2V0RmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkgeyB9XHJcbiAgICAgICAgeWllbGQgaW5pdGlhbGl6ZV8xLmNsb3NlQWN0aXZlV2luZG93cygpO1xyXG4gICAgfSkpO1xyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZURJKCkge1xyXG4gICAgICAgIGlvYyA9IG5ldyBzZXJ2aWNlUmVnaXN0cnlfMS5Vbml0VGVzdElvY0NvbnRhaW5lcigpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlckNvbW1vblR5cGVzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyUHJvY2Vzc1R5cGVzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyVmFyaWFibGVUeXBlcygpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGVzdGluZ01ldGhvZEV4dHJhY3Rpb24oc2hvdWxkRXJyb3IsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBweXRob25TZXR0aW5ncyA9IGNvbmZpZ1NldHRpbmdzXzEuUHl0aG9uU2V0dGluZ3MuZ2V0SW5zdGFuY2UodnNjb2RlLlVyaS5maWxlKHJlZmFjdG9yVGFyZ2V0RmlsZSkpO1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZU9mVGV4dFRvRXh0cmFjdCA9IG5ldyB2c2NvZGUuUmFuZ2Uoc3RhcnRQb3MsIGVuZFBvcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IHByb3h5XzEuUmVmYWN0b3JQcm94eShFWFRFTlNJT05fRElSLCBweXRob25TZXR0aW5ncywgcGF0aC5kaXJuYW1lKHJlZmFjdG9yVGFyZ2V0RmlsZSksIGlvYy5zZXJ2aWNlQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW11bHRpbGluZS1zdHJpbmdcclxuICAgICAgICAgICAgY29uc3QgRElGRiA9IGAtLS0gYS9yZWZhY3Rvci5weVxcbisrKyBiL3JlZmFjdG9yLnB5XFxuQEAgLTIzNyw5ICsyMzcsMTIgQEBcXG4gICAgICAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgICAgICAgc2VsZi5fcHJvY2Vzc19yZXF1ZXN0KHNlbGYuX2lucHV0LnJlYWRsaW5lKCkpXFxuICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZXg6XFxuLSAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXgubWVzc2FnZSArICcgIFxcXFxuJyArIHRyYWNlYmFjay5mb3JtYXRfZXhjKClcXG4tICAgICAgICAgICAgICAgIHN5cy5zdGRlcnIud3JpdGUoc3RyKGxlbihtZXNzYWdlKSkgKyAnOicgKyBtZXNzYWdlKVxcbi0gICAgICAgICAgICAgICAgc3lzLnN0ZGVyci5mbHVzaCgpXFxuKyAgICAgICAgICAgICAgICBzZWxmLm15TmV3TWV0aG9kKGV4KVxcbitcXG4rICAgIGRlZiBteU5ld01ldGhvZChzZWxmLCBleCk6XFxuKyAgICAgICAgbWVzc2FnZSA9IGV4Lm1lc3NhZ2UgKyAnICBcXFxcbicgKyB0cmFjZWJhY2suZm9ybWF0X2V4YygpXFxuKyAgICAgICAgc3lzLnN0ZGVyci53cml0ZShzdHIobGVuKG1lc3NhZ2UpKSArICc6JyArIG1lc3NhZ2UpXFxuKyAgICAgICAgc3lzLnN0ZGVyci5mbHVzaCgpXFxuIFxcbiBpZiBfX25hbWVfXyA9PSAnX19tYWluX18nOlxcbiAgICAgUm9wZVJlZmFjdG9yaW5nKCkud2F0Y2goKVxcbmA7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tUZXh0RG9jID0geWllbGQgdnNjb2RlLndvcmtzcGFjZS5vcGVuVGV4dERvY3VtZW50KHJlZmFjdG9yVGFyZ2V0RmlsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVGV4dEVkaXRzID0gZWRpdG9yXzEuZ2V0VGV4dEVkaXRzRnJvbVBhdGNoKG1vY2tUZXh0RG9jLmdldFRleHQoKSwgRElGRik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHByb3h5LmV4dHJhY3RNZXRob2QobW9ja1RleHREb2MsICdteU5ld01ldGhvZCcsIHJlZmFjdG9yVGFyZ2V0RmlsZSwgcmFuZ2VPZlRleHRUb0V4dHJhY3QsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmZhaWwoJ05vIGVycm9yJywgJ0Vycm9yJywgJ0V4dHJhY3Rpb24gc2hvdWxkIGZhaWwgd2l0aCBhbiBlcnJvcicsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFZGl0cyA9IGVkaXRvcl8xLmdldFRleHRFZGl0c0Zyb21QYXRjaChtb2NrVGV4dERvYy5nZXRUZXh0KCksIERJRkYpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3BvbnNlLnJlc3VsdHMubGVuZ3RoLCAxLCAnSW52YWxpZCBudW1iZXIgb2YgaXRlbXMgaW4gcmVzcG9uc2UnKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbCh0ZXh0RWRpdHMubGVuZ3RoLCBleHBlY3RlZFRleHRFZGl0cy5sZW5ndGgsICdJbnZhbGlkIG51bWJlciBvZiBUZXh0IEVkaXRzJyk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0RWRpdHMuZm9yRWFjaChlZGl0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEVkaXQgPSBleHBlY3RlZFRleHRFZGl0cy5maWx0ZXIoaXRlbSA9PiBpdGVtLm5ld1RleHQgPT09IGVkaXQubmV3VGV4dCAmJiBpdGVtLnJhbmdlLmlzRXF1YWwoZWRpdC5yYW5nZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmb3VuZEVkaXQubGVuZ3RoLCAxLCAnRWRpdCBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgYSBtaW51dGUgdGhpcyBzaG91bGRuJ3Qgd29yaywgd2hhdCdzIGdvaW5nIG9uXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKCdFcnJvcicsICdObyBlcnJvcicsIGAke2Vycm9yfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0ZXN0KCdFeHRyYWN0IE1ldGhvZCcsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBzdGFydFBvcyA9IG5ldyB2c2NvZGUuUG9zaXRpb24oMjM5LCAwKTtcclxuICAgICAgICBjb25zdCBlbmRQb3MgPSBuZXcgdnNjb2RlLlBvc2l0aW9uKDI0MSwgMzUpO1xyXG4gICAgICAgIHlpZWxkIHRlc3RpbmdNZXRob2RFeHRyYWN0aW9uKGZhbHNlLCBzdGFydFBvcywgZW5kUG9zKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0V4dHJhY3QgTWV0aG9kIHdpbGwgZmFpbCBpZiBjb21wbGV0ZSBzdGF0ZW1lbnRzIGFyZSBub3Qgc2VsZWN0ZWQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBuZXcgdnNjb2RlLlBvc2l0aW9uKDIzOSwgMzApO1xyXG4gICAgICAgIGNvbnN0IGVuZFBvcyA9IG5ldyB2c2NvZGUuUG9zaXRpb24oMjQxLCAzNSk7XHJcbiAgICAgICAgeWllbGQgdGVzdGluZ01ldGhvZEV4dHJhY3Rpb24odHJ1ZSwgc3RhcnRQb3MsIGVuZFBvcyk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiB0ZXN0aW5nTWV0aG9kRXh0cmFjdGlvbkVuZFRvRW5kKHNob3VsZEVycm9yLCBzdGFydFBvcywgZW5kUG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgY2ggPSBuZXcgbW9ja0NsYXNzZXNfMS5Nb2NrT3V0cHV0Q2hhbm5lbCgnUHl0aG9uJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlT2ZUZXh0VG9FeHRyYWN0ID0gbmV3IHZzY29kZS5SYW5nZShzdGFydFBvcywgZW5kUG9zKTtcclxuICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50ID0geWllbGQgdnNjb2RlLndvcmtzcGFjZS5vcGVuVGV4dERvY3VtZW50KHJlZmFjdG9yVGFyZ2V0RmlsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHlpZWxkIHZzY29kZS53aW5kb3cuc2hvd1RleHREb2N1bWVudCh0ZXh0RG9jdW1lbnQpO1xyXG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9ucyA9IFtuZXcgdnNjb2RlLlNlbGVjdGlvbihyYW5nZU9mVGV4dFRvRXh0cmFjdC5zdGFydCwgcmFuZ2VPZlRleHRUb0V4dHJhY3QuZW5kKV07XHJcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBuZXcgdnNjb2RlLlNlbGVjdGlvbihyYW5nZU9mVGV4dFRvRXh0cmFjdC5zdGFydCwgcmFuZ2VPZlRleHRUb0V4dHJhY3QuZW5kKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHNpbXBsZVJlZmFjdG9yUHJvdmlkZXJfMS5leHRyYWN0TWV0aG9kKEVYVEVOU0lPTl9ESVIsIGVkaXRvciwgcmFuZ2VPZlRleHRUb0V4dHJhY3QsIGNoLCBpb2Muc2VydmljZUNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbCgnTm8gZXJyb3InLCAnRXJyb3InLCAnRXh0cmFjdGlvbiBzaG91bGQgZmFpbCB3aXRoIGFuIGVycm9yJywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TWV0aG9kUmVmTGluZSA9IHRleHREb2N1bWVudC5saW5lQXQoZWRpdG9yLnNlbGVjdGlvbi5zdGFydCk7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2gub3V0cHV0Lmxlbmd0aCwgMCwgJ091dHB1dCBjaGFubmVsIGlzIG5vdCBlbXB0eScpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHRleHREb2N1bWVudC5saW5lQXQobmV3TWV0aG9kUmVmTGluZS5saW5lTnVtYmVyICsgMikudGV4dC50cmltKCkuaW5kZXhPZignZGVmIG5ld21ldGhvZCcpLCAwLCAnTmV3IE1ldGhvZCBub3QgY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5ld01ldGhvZFJlZkxpbmUudGV4dC50cmltKCkuc3RhcnRzV2l0aCgnc2VsZi5uZXdtZXRob2QnKSwgdHJ1ZSwgJ05ldyBNZXRob2Qgbm90IGJlaW5nIHVzZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoJ0Vycm9yJywgJ05vIGVycm9yJywgYCR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgdGVzdCBmYWlscyBvbiBsaW51eCAodGV4dCBkb2N1bWVudCBub3QgZ2V0dGluZyB1cGRhdGVkIGluIHRpbWUpXHJcbiAgICB0ZXN0KCdFeHRyYWN0IE1ldGhvZCAoZW5kIHRvIGVuZCknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBuZXcgdnNjb2RlLlBvc2l0aW9uKDIzOSwgMCk7XHJcbiAgICAgICAgY29uc3QgZW5kUG9zID0gbmV3IHZzY29kZS5Qb3NpdGlvbigyNDEsIDM1KTtcclxuICAgICAgICB5aWVsZCB0ZXN0aW5nTWV0aG9kRXh0cmFjdGlvbkVuZFRvRW5kKGZhbHNlLCBzdGFydFBvcywgZW5kUG9zKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0V4dHJhY3QgTWV0aG9kIHdpbGwgZmFpbCBpZiBjb21wbGV0ZSBzdGF0ZW1lbnRzIGFyZSBub3Qgc2VsZWN0ZWQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBuZXcgdnNjb2RlLlBvc2l0aW9uKDIzOSwgMzApO1xyXG4gICAgICAgIGNvbnN0IGVuZFBvcyA9IG5ldyB2c2NvZGUuUG9zaXRpb24oMjQxLCAzNSk7XHJcbiAgICAgICAgeWllbGQgdGVzdGluZ01ldGhvZEV4dHJhY3Rpb25FbmRUb0VuZCh0cnVlLCBzdGFydFBvcywgZW5kUG9zKTtcclxuICAgIH0pKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuc2lvbi5yZWZhY3Rvci5leHRyYWN0Lm1ldGhvZC50ZXN0LmpzLm1hcCJdfQ==