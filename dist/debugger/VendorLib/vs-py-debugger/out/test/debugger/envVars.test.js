"use strict"; // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
}); // tslint:disable:no-string-literal no-unused-expression chai-vague-errors max-func-body-length no-any

const chai_1 = require("chai");

const chaiAsPromised = require("chai-as-promised");

const path = require("path");

const shortid = require("shortid");

const types_1 = require("../../client/common/types");

const types_2 = require("../../client/common/variables/types");

const helper_1 = require("../../client/debugger/debugAdapter/DebugClients/helper");

const initialize_1 = require("../initialize");

const serviceRegistry_1 = require("../unittests/serviceRegistry");

chai_1.use(chaiAsPromised);
suite('Resolving Environment Variables when Debugging', () => {
  let ioc;
  let helper;
  let pathVariableName;
  let mockProcess;
  suiteSetup(initialize_1.initialize);
  setup(() => __awaiter(void 0, void 0, void 0, function* () {
    initializeDI();
    yield initialize_1.initializeTest();
    const envParser = ioc.serviceContainer.get(types_2.IEnvironmentVariablesService);
    const pathUtils = ioc.serviceContainer.get(types_1.IPathUtils);
    mockProcess = ioc.serviceContainer.get(types_1.ICurrentProcess);
    helper = new helper_1.DebugClientHelper(envParser, pathUtils, mockProcess);
    pathVariableName = pathUtils.getPathVariableName();
  }));
  suiteTeardown(initialize_1.closeActiveWindows);
  teardown(() => __awaiter(void 0, void 0, void 0, function* () {
    ioc.dispose();
    yield initialize_1.closeActiveWindows();
  }));

  function initializeDI() {
    ioc = new serviceRegistry_1.UnitTestIocContainer();
    ioc.registerProcessTypes();
    ioc.registerVariableTypes();
    ioc.registerMockProcess();
  }

  function testBasicProperties(console, expectedNumberOfVariables) {
    return __awaiter(this, void 0, void 0, function* () {
      const args = {
        program: '',
        pythonPath: '',
        args: [],
        envFile: '',
        console // tslint:disable-next-line:no-any

      };
      const envVars = yield helper.getEnvironmentVariables(args);
      chai_1.expect(envVars).not.be.undefined;
      chai_1.expect(Object.keys(envVars)).lengthOf(expectedNumberOfVariables, 'Incorrect number of variables');
      chai_1.expect(envVars).to.have.property('PYTHONUNBUFFERED', '1', 'Property not found');
      chai_1.expect(envVars).to.have.property('PYTHONIOENCODING', 'UTF-8', 'Property not found');
    });
  }

  test('Confirm basic environment variables exist when launched in external terminal', () => testBasicProperties('externalTerminal', 2));
  test('Confirm basic environment variables exist when launched in intergrated terminal', () => testBasicProperties('integratedTerminal', 2));
  test('Confirm basic environment variables exist when launched in debug console', () => __awaiter(void 0, void 0, void 0, function* () {
    let expectedNumberOfVariables = Object.keys(mockProcess.env).length;

    if (mockProcess.env['PYTHONUNBUFFERED'] === undefined) {
      expectedNumberOfVariables += 1;
    }

    if (mockProcess.env['PYTHONIOENCODING'] === undefined) {
      expectedNumberOfVariables += 1;
    }

    yield testBasicProperties('none', expectedNumberOfVariables);
  }));

  function testJsonEnvVariables(console, expectedNumberOfVariables) {
    return __awaiter(this, void 0, void 0, function* () {
      const prop1 = shortid.generate();
      const prop2 = shortid.generate();
      const prop3 = shortid.generate();
      const env = {};
      env[prop1] = prop1;
      env[prop2] = prop2;
      mockProcess.env[prop3] = prop3;
      const args = {
        program: '',
        pythonPath: '',
        args: [],
        envFile: '',
        console,
        env // tslint:disable-next-line:no-any

      };
      const envVars = yield helper.getEnvironmentVariables(args); // tslint:disable-next-line:no-unused-expression chai-vague-errors

      chai_1.expect(envVars).not.be.undefined;
      chai_1.expect(Object.keys(envVars)).lengthOf(expectedNumberOfVariables, 'Incorrect number of variables');
      chai_1.expect(envVars).to.have.property('PYTHONUNBUFFERED', '1', 'Property not found');
      chai_1.expect(envVars).to.have.property('PYTHONIOENCODING', 'UTF-8', 'Property not found');
      chai_1.expect(envVars).to.have.property(prop1, prop1, 'Property not found');
      chai_1.expect(envVars).to.have.property(prop2, prop2, 'Property not found');

      if (console === 'none') {
        chai_1.expect(envVars).to.have.property(prop3, prop3, 'Property not found');
      } else {
        chai_1.expect(envVars).not.to.have.property(prop3, prop3, 'Property not found');
      }
    });
  }

  test('Confirm json environment variables exist when launched in external terminal', () => testJsonEnvVariables('externalTerminal', 2 + 2));
  test('Confirm json environment variables exist when launched in intergrated terminal', () => testJsonEnvVariables('integratedTerminal', 2 + 2));
  test('Confirm json environment variables exist when launched in debug console', () => __awaiter(void 0, void 0, void 0, function* () {
    // Add 3 for the 3 new json env variables
    let expectedNumberOfVariables = Object.keys(mockProcess.env).length + 3;

    if (mockProcess.env['PYTHONUNBUFFERED'] === undefined) {
      expectedNumberOfVariables += 1;
    }

    if (mockProcess.env['PYTHONIOENCODING'] === undefined) {
      expectedNumberOfVariables += 1;
    }

    yield testJsonEnvVariables('none', expectedNumberOfVariables);
  }));

  function testAppendingOfPaths(console, expectedNumberOfVariables, removePythonPath) {
    return __awaiter(this, void 0, void 0, function* () {
      if (removePythonPath && mockProcess.env.PYTHONPATH !== undefined) {
        delete mockProcess.env.PYTHONPATH;
      }

      const customPathToAppend = shortid.generate();
      const customPythonPathToAppend = shortid.generate();
      const prop1 = shortid.generate();
      const prop2 = shortid.generate();
      const prop3 = shortid.generate();
      const env = {};
      env[pathVariableName] = customPathToAppend;
      env['PYTHONPATH'] = customPythonPathToAppend;
      env[prop1] = prop1;
      env[prop2] = prop2;
      mockProcess.env[prop3] = prop3;
      const args = {
        program: '',
        pythonPath: '',
        args: [],
        envFile: '',
        console,
        env
      };
      const envVars = yield helper.getEnvironmentVariables(args);
      chai_1.expect(envVars).not.be.undefined;
      chai_1.expect(Object.keys(envVars)).lengthOf(expectedNumberOfVariables, 'Incorrect number of variables');
      chai_1.expect(envVars).to.have.property('PYTHONPATH');
      chai_1.expect(envVars).to.have.property(pathVariableName);
      chai_1.expect(envVars).to.have.property('PYTHONUNBUFFERED', '1', 'Property not found');
      chai_1.expect(envVars).to.have.property('PYTHONIOENCODING', 'UTF-8', 'Property not found');
      chai_1.expect(envVars).to.have.property(prop1, prop1, 'Property not found');
      chai_1.expect(envVars).to.have.property(prop2, prop2, 'Property not found');

      if (console === 'none') {
        chai_1.expect(envVars).to.have.property(prop3, prop3, 'Property not found');
      } else {
        chai_1.expect(envVars).not.to.have.property(prop3, prop3, 'Property not found');
      } // Confirm the paths have been appended correctly.


      const expectedPath = customPathToAppend + path.delimiter + mockProcess.env[pathVariableName];
      chai_1.expect(envVars).to.have.property(pathVariableName, expectedPath, 'PATH is not correct'); // Confirm the paths have been appended correctly.

      let expectedPythonPath = customPythonPathToAppend;

      if (typeof mockProcess.env.PYTHONPATH === 'string' && mockProcess.env.PYTHONPATH.length > 0) {
        expectedPythonPath = customPythonPathToAppend + path.delimiter + mockProcess.env.PYTHONPATH;
      }

      chai_1.expect(envVars).to.have.property('PYTHONPATH', expectedPythonPath, 'PYTHONPATH is not correct');

      if (console === 'none') {
        // All variables in current process must be in here
        chai_1.expect(Object.keys(envVars).length).greaterThan(Object.keys(mockProcess.env).length, 'Variables is not a subset');
        Object.keys(mockProcess.env).forEach(key => {
          if (key === pathVariableName || key === 'PYTHONPATH') {
            return;
          }

          chai_1.expect(mockProcess.env[key]).equal(envVars[key], `Value for the environment variable '${key}' is incorrect.`);
        });
      }
    });
  }

  test('Confirm paths get appended correctly when using json variables and launched in external terminal', () => testAppendingOfPaths('externalTerminal', 6, false));
  test('Confirm paths get appended correctly when using json variables and launched in integrated terminal', () => testAppendingOfPaths('integratedTerminal', 6, false));
  test('Confirm paths get appended correctly when using json variables and launched in debug console', () => __awaiter(void 0, void 0, void 0, function* () {
    // Add 3 for the 3 new json env variables
    let expectedNumberOfVariables = Object.keys(mockProcess.env).length + 3;

    if (mockProcess.env['PYTHONUNBUFFERED'] === undefined) {
      expectedNumberOfVariables += 1;
    }

    if (mockProcess.env['PYTHONPATH'] === undefined) {
      expectedNumberOfVariables += 1;
    }

    if (mockProcess.env['PYTHONIOENCODING'] === undefined) {
      expectedNumberOfVariables += 1;
    }

    yield testAppendingOfPaths('none', expectedNumberOfVariables, false);
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVudlZhcnMudGVzdC5qcyJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInZhbHVlIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiY2hhaV8xIiwicmVxdWlyZSIsImNoYWlBc1Byb21pc2VkIiwicGF0aCIsInNob3J0aWQiLCJ0eXBlc18xIiwidHlwZXNfMiIsImhlbHBlcl8xIiwiaW5pdGlhbGl6ZV8xIiwic2VydmljZVJlZ2lzdHJ5XzEiLCJ1c2UiLCJzdWl0ZSIsImlvYyIsImhlbHBlciIsInBhdGhWYXJpYWJsZU5hbWUiLCJtb2NrUHJvY2VzcyIsInN1aXRlU2V0dXAiLCJpbml0aWFsaXplIiwic2V0dXAiLCJpbml0aWFsaXplREkiLCJpbml0aWFsaXplVGVzdCIsImVudlBhcnNlciIsInNlcnZpY2VDb250YWluZXIiLCJnZXQiLCJJRW52aXJvbm1lbnRWYXJpYWJsZXNTZXJ2aWNlIiwicGF0aFV0aWxzIiwiSVBhdGhVdGlscyIsIklDdXJyZW50UHJvY2VzcyIsIkRlYnVnQ2xpZW50SGVscGVyIiwiZ2V0UGF0aFZhcmlhYmxlTmFtZSIsInN1aXRlVGVhcmRvd24iLCJjbG9zZUFjdGl2ZVdpbmRvd3MiLCJ0ZWFyZG93biIsImRpc3Bvc2UiLCJVbml0VGVzdElvY0NvbnRhaW5lciIsInJlZ2lzdGVyUHJvY2Vzc1R5cGVzIiwicmVnaXN0ZXJWYXJpYWJsZVR5cGVzIiwicmVnaXN0ZXJNb2NrUHJvY2VzcyIsInRlc3RCYXNpY1Byb3BlcnRpZXMiLCJjb25zb2xlIiwiZXhwZWN0ZWROdW1iZXJPZlZhcmlhYmxlcyIsImFyZ3MiLCJwcm9ncmFtIiwicHl0aG9uUGF0aCIsImVudkZpbGUiLCJlbnZWYXJzIiwiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMiLCJleHBlY3QiLCJub3QiLCJiZSIsInVuZGVmaW5lZCIsImtleXMiLCJsZW5ndGhPZiIsInRvIiwiaGF2ZSIsInByb3BlcnR5IiwidGVzdCIsImVudiIsImxlbmd0aCIsInRlc3RKc29uRW52VmFyaWFibGVzIiwicHJvcDEiLCJnZW5lcmF0ZSIsInByb3AyIiwicHJvcDMiLCJ0ZXN0QXBwZW5kaW5nT2ZQYXRocyIsInJlbW92ZVB5dGhvblBhdGgiLCJQWVRIT05QQVRIIiwiY3VzdG9tUGF0aFRvQXBwZW5kIiwiY3VzdG9tUHl0aG9uUGF0aFRvQXBwZW5kIiwiZXhwZWN0ZWRQYXRoIiwiZGVsaW1pdGVyIiwiZXhwZWN0ZWRQeXRob25QYXRoIiwiZ3JlYXRlclRoYW4iLCJmb3JFYWNoIiwia2V5IiwiZXF1YWwiXSwibWFwcGluZ3MiOiJBQUFBLGEsQ0FDQTtBQUNBOztBQUNBLElBQUlBLFNBQVMsR0FBSSxVQUFRLFNBQUtBLFNBQWQsSUFBNEIsVUFBVUMsT0FBVixFQUFtQkMsVUFBbkIsRUFBK0JDLENBQS9CLEVBQWtDQyxTQUFsQyxFQUE2QztBQUNyRixTQUFPLEtBQUtELENBQUMsS0FBS0EsQ0FBQyxHQUFHRSxPQUFULENBQU4sRUFBeUIsVUFBVUMsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7QUFDdkQsYUFBU0MsU0FBVCxDQUFtQkMsS0FBbkIsRUFBMEI7QUFBRSxVQUFJO0FBQUVDLFFBQUFBLElBQUksQ0FBQ04sU0FBUyxDQUFDTyxJQUFWLENBQWVGLEtBQWYsQ0FBRCxDQUFKO0FBQThCLE9BQXBDLENBQXFDLE9BQU9HLENBQVAsRUFBVTtBQUFFTCxRQUFBQSxNQUFNLENBQUNLLENBQUQsQ0FBTjtBQUFZO0FBQUU7O0FBQzNGLGFBQVNDLFFBQVQsQ0FBa0JKLEtBQWxCLEVBQXlCO0FBQUUsVUFBSTtBQUFFQyxRQUFBQSxJQUFJLENBQUNOLFNBQVMsQ0FBQyxPQUFELENBQVQsQ0FBbUJLLEtBQW5CLENBQUQsQ0FBSjtBQUFrQyxPQUF4QyxD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dCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1zdHJpbmctbGl0ZXJhbCBuby11bnVzZWQtZXhwcmVzc2lvbiBjaGFpLXZhZ3VlLWVycm9ycyBtYXgtZnVuYy1ib2R5LWxlbmd0aCBuby1hbnlcclxuY29uc3QgY2hhaV8xID0gcmVxdWlyZShcImNoYWlcIik7XHJcbmNvbnN0IGNoYWlBc1Byb21pc2VkID0gcmVxdWlyZShcImNoYWktYXMtcHJvbWlzZWRcIik7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3Qgc2hvcnRpZCA9IHJlcXVpcmUoXCJzaG9ydGlkXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vdHlwZXNcIik7XHJcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbW1vbi92YXJpYWJsZXMvdHlwZXNcIik7XHJcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9kZWJ1Z2dlci9kZWJ1Z0FkYXB0ZXIvRGVidWdDbGllbnRzL2hlbHBlclwiKTtcclxuY29uc3QgaW5pdGlhbGl6ZV8xID0gcmVxdWlyZShcIi4uL2luaXRpYWxpemVcIik7XHJcbmNvbnN0IHNlcnZpY2VSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4uL3VuaXR0ZXN0cy9zZXJ2aWNlUmVnaXN0cnlcIik7XHJcbmNoYWlfMS51c2UoY2hhaUFzUHJvbWlzZWQpO1xyXG5zdWl0ZSgnUmVzb2x2aW5nIEVudmlyb25tZW50IFZhcmlhYmxlcyB3aGVuIERlYnVnZ2luZycsICgpID0+IHtcclxuICAgIGxldCBpb2M7XHJcbiAgICBsZXQgaGVscGVyO1xyXG4gICAgbGV0IHBhdGhWYXJpYWJsZU5hbWU7XHJcbiAgICBsZXQgbW9ja1Byb2Nlc3M7XHJcbiAgICBzdWl0ZVNldHVwKGluaXRpYWxpemVfMS5pbml0aWFsaXplKTtcclxuICAgIHNldHVwKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpbml0aWFsaXplREkoKTtcclxuICAgICAgICB5aWVsZCBpbml0aWFsaXplXzEuaW5pdGlhbGl6ZVRlc3QoKTtcclxuICAgICAgICBjb25zdCBlbnZQYXJzZXIgPSBpb2Muc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMi5JRW52aXJvbm1lbnRWYXJpYWJsZXNTZXJ2aWNlKTtcclxuICAgICAgICBjb25zdCBwYXRoVXRpbHMgPSBpb2Muc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JUGF0aFV0aWxzKTtcclxuICAgICAgICBtb2NrUHJvY2VzcyA9IGlvYy5zZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18xLklDdXJyZW50UHJvY2Vzcyk7XHJcbiAgICAgICAgaGVscGVyID0gbmV3IGhlbHBlcl8xLkRlYnVnQ2xpZW50SGVscGVyKGVudlBhcnNlciwgcGF0aFV0aWxzLCBtb2NrUHJvY2Vzcyk7XHJcbiAgICAgICAgcGF0aFZhcmlhYmxlTmFtZSA9IHBhdGhVdGlscy5nZXRQYXRoVmFyaWFibGVOYW1lKCk7XHJcbiAgICB9KSk7XHJcbiAgICBzdWl0ZVRlYXJkb3duKGluaXRpYWxpemVfMS5jbG9zZUFjdGl2ZVdpbmRvd3MpO1xyXG4gICAgdGVhcmRvd24oKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGlvYy5kaXNwb3NlKCk7XHJcbiAgICAgICAgeWllbGQgaW5pdGlhbGl6ZV8xLmNsb3NlQWN0aXZlV2luZG93cygpO1xyXG4gICAgfSkpO1xyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZURJKCkge1xyXG4gICAgICAgIGlvYyA9IG5ldyBzZXJ2aWNlUmVnaXN0cnlfMS5Vbml0VGVzdElvY0NvbnRhaW5lcigpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlclByb2Nlc3NUeXBlcygpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlclZhcmlhYmxlVHlwZXMoKTtcclxuICAgICAgICBpb2MucmVnaXN0ZXJNb2NrUHJvY2VzcygpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGVzdEJhc2ljUHJvcGVydGllcyhjb25zb2xlLCBleHBlY3RlZE51bWJlck9mVmFyaWFibGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJncyA9IHtcclxuICAgICAgICAgICAgICAgIHByb2dyYW06ICcnLCBweXRob25QYXRoOiAnJywgYXJnczogW10sIGVudkZpbGU6ICcnLFxyXG4gICAgICAgICAgICAgICAgY29uc29sZVxyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBlbnZWYXJzID0geWllbGQgaGVscGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKGFyZ3MpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLm5vdC5iZS51bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QoT2JqZWN0LmtleXMoZW52VmFycykpLmxlbmd0aE9mKGV4cGVjdGVkTnVtYmVyT2ZWYXJpYWJsZXMsICdJbmNvcnJlY3QgbnVtYmVyIG9mIHZhcmlhYmxlcycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlVOQlVGRkVSRUQnLCAnMScsICdQcm9wZXJ0eSBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05JT0VOQ09ESU5HJywgJ1VURi04JywgJ1Byb3BlcnR5IG5vdCBmb3VuZCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVzdCgnQ29uZmlybSBiYXNpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZXhpc3Qgd2hlbiBsYXVuY2hlZCBpbiBleHRlcm5hbCB0ZXJtaW5hbCcsICgpID0+IHRlc3RCYXNpY1Byb3BlcnRpZXMoJ2V4dGVybmFsVGVybWluYWwnLCAyKSk7XHJcbiAgICB0ZXN0KCdDb25maXJtIGJhc2ljIGVudmlyb25tZW50IHZhcmlhYmxlcyBleGlzdCB3aGVuIGxhdW5jaGVkIGluIGludGVyZ3JhdGVkIHRlcm1pbmFsJywgKCkgPT4gdGVzdEJhc2ljUHJvcGVydGllcygnaW50ZWdyYXRlZFRlcm1pbmFsJywgMikpO1xyXG4gICAgdGVzdCgnQ29uZmlybSBiYXNpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZXhpc3Qgd2hlbiBsYXVuY2hlZCBpbiBkZWJ1ZyBjb25zb2xlJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBleHBlY3RlZE51bWJlck9mVmFyaWFibGVzID0gT2JqZWN0LmtleXMobW9ja1Byb2Nlc3MuZW52KS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKG1vY2tQcm9jZXNzLmVudlsnUFlUSE9OVU5CVUZGRVJFRCddID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXhwZWN0ZWROdW1iZXJPZlZhcmlhYmxlcyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9ja1Byb2Nlc3MuZW52WydQWVRIT05JT0VOQ09ESU5HJ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBleHBlY3RlZE51bWJlck9mVmFyaWFibGVzICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIHRlc3RCYXNpY1Byb3BlcnRpZXMoJ25vbmUnLCBleHBlY3RlZE51bWJlck9mVmFyaWFibGVzKTtcclxuICAgIH0pKTtcclxuICAgIGZ1bmN0aW9uIHRlc3RKc29uRW52VmFyaWFibGVzKGNvbnNvbGUsIGV4cGVjdGVkTnVtYmVyT2ZWYXJpYWJsZXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wMSA9IHNob3J0aWQuZ2VuZXJhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvcDIgPSBzaG9ydGlkLmdlbmVyYXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3AzID0gc2hvcnRpZC5nZW5lcmF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBlbnYgPSB7fTtcclxuICAgICAgICAgICAgZW52W3Byb3AxXSA9IHByb3AxO1xyXG4gICAgICAgICAgICBlbnZbcHJvcDJdID0gcHJvcDI7XHJcbiAgICAgICAgICAgIG1vY2tQcm9jZXNzLmVudltwcm9wM10gPSBwcm9wMztcclxuICAgICAgICAgICAgY29uc3QgYXJncyA9IHtcclxuICAgICAgICAgICAgICAgIHByb2dyYW06ICcnLCBweXRob25QYXRoOiAnJywgYXJnczogW10sIGVudkZpbGU6ICcnLFxyXG4gICAgICAgICAgICAgICAgY29uc29sZSwgZW52XHJcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGVudlZhcnMgPSB5aWVsZCBoZWxwZXIuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoYXJncyk7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvbiBjaGFpLXZhZ3VlLWVycm9yc1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLm5vdC5iZS51bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QoT2JqZWN0LmtleXMoZW52VmFycykpLmxlbmd0aE9mKGV4cGVjdGVkTnVtYmVyT2ZWYXJpYWJsZXMsICdJbmNvcnJlY3QgbnVtYmVyIG9mIHZhcmlhYmxlcycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlVOQlVGRkVSRUQnLCAnMScsICdQcm9wZXJ0eSBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05JT0VOQ09ESU5HJywgJ1VURi04JywgJ1Byb3BlcnR5IG5vdCBmb3VuZCcpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLnRvLmhhdmUucHJvcGVydHkocHJvcDEsIHByb3AxLCAnUHJvcGVydHkgbm90IGZvdW5kJyk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QoZW52VmFycykudG8uaGF2ZS5wcm9wZXJ0eShwcm9wMiwgcHJvcDIsICdQcm9wZXJ0eSBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgaWYgKGNvbnNvbGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS50by5oYXZlLnByb3BlcnR5KHByb3AzLCBwcm9wMywgJ1Byb3BlcnR5IG5vdCBmb3VuZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS5ub3QudG8uaGF2ZS5wcm9wZXJ0eShwcm9wMywgcHJvcDMsICdQcm9wZXJ0eSBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVzdCgnQ29uZmlybSBqc29uIGVudmlyb25tZW50IHZhcmlhYmxlcyBleGlzdCB3aGVuIGxhdW5jaGVkIGluIGV4dGVybmFsIHRlcm1pbmFsJywgKCkgPT4gdGVzdEpzb25FbnZWYXJpYWJsZXMoJ2V4dGVybmFsVGVybWluYWwnLCAyICsgMikpO1xyXG4gICAgdGVzdCgnQ29uZmlybSBqc29uIGVudmlyb25tZW50IHZhcmlhYmxlcyBleGlzdCB3aGVuIGxhdW5jaGVkIGluIGludGVyZ3JhdGVkIHRlcm1pbmFsJywgKCkgPT4gdGVzdEpzb25FbnZWYXJpYWJsZXMoJ2ludGVncmF0ZWRUZXJtaW5hbCcsIDIgKyAyKSk7XHJcbiAgICB0ZXN0KCdDb25maXJtIGpzb24gZW52aXJvbm1lbnQgdmFyaWFibGVzIGV4aXN0IHdoZW4gbGF1bmNoZWQgaW4gZGVidWcgY29uc29sZScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBBZGQgMyBmb3IgdGhlIDMgbmV3IGpzb24gZW52IHZhcmlhYmxlc1xyXG4gICAgICAgIGxldCBleHBlY3RlZE51bWJlck9mVmFyaWFibGVzID0gT2JqZWN0LmtleXMobW9ja1Byb2Nlc3MuZW52KS5sZW5ndGggKyAzO1xyXG4gICAgICAgIGlmIChtb2NrUHJvY2Vzcy5lbnZbJ1BZVEhPTlVOQlVGRkVSRUQnXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkTnVtYmVyT2ZWYXJpYWJsZXMgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vY2tQcm9jZXNzLmVudlsnUFlUSE9OSU9FTkNPRElORyddID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXhwZWN0ZWROdW1iZXJPZlZhcmlhYmxlcyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCB0ZXN0SnNvbkVudlZhcmlhYmxlcygnbm9uZScsIGV4cGVjdGVkTnVtYmVyT2ZWYXJpYWJsZXMpO1xyXG4gICAgfSkpO1xyXG4gICAgZnVuY3Rpb24gdGVzdEFwcGVuZGluZ09mUGF0aHMoY29uc29sZSwgZXhwZWN0ZWROdW1iZXJPZlZhcmlhYmxlcywgcmVtb3ZlUHl0aG9uUGF0aCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChyZW1vdmVQeXRob25QYXRoICYmIG1vY2tQcm9jZXNzLmVudi5QWVRIT05QQVRIICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtb2NrUHJvY2Vzcy5lbnYuUFlUSE9OUEFUSDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjdXN0b21QYXRoVG9BcHBlbmQgPSBzaG9ydGlkLmdlbmVyYXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbVB5dGhvblBhdGhUb0FwcGVuZCA9IHNob3J0aWQuZ2VuZXJhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvcDEgPSBzaG9ydGlkLmdlbmVyYXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3AyID0gc2hvcnRpZC5nZW5lcmF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wMyA9IHNob3J0aWQuZ2VuZXJhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgZW52ID0ge307XHJcbiAgICAgICAgICAgIGVudltwYXRoVmFyaWFibGVOYW1lXSA9IGN1c3RvbVBhdGhUb0FwcGVuZDtcclxuICAgICAgICAgICAgZW52WydQWVRIT05QQVRIJ10gPSBjdXN0b21QeXRob25QYXRoVG9BcHBlbmQ7XHJcbiAgICAgICAgICAgIGVudltwcm9wMV0gPSBwcm9wMTtcclxuICAgICAgICAgICAgZW52W3Byb3AyXSA9IHByb3AyO1xyXG4gICAgICAgICAgICBtb2NrUHJvY2Vzcy5lbnZbcHJvcDNdID0gcHJvcDM7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtOiAnJywgcHl0aG9uUGF0aDogJycsIGFyZ3M6IFtdLCBlbnZGaWxlOiAnJyxcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUsIGVudlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBlbnZWYXJzID0geWllbGQgaGVscGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKGFyZ3MpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLm5vdC5iZS51bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QoT2JqZWN0LmtleXMoZW52VmFycykpLmxlbmd0aE9mKGV4cGVjdGVkTnVtYmVyT2ZWYXJpYWJsZXMsICdJbmNvcnJlY3QgbnVtYmVyIG9mIHZhcmlhYmxlcycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlBBVEgnKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS50by5oYXZlLnByb3BlcnR5KHBhdGhWYXJpYWJsZU5hbWUpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlVOQlVGRkVSRUQnLCAnMScsICdQcm9wZXJ0eSBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05JT0VOQ09ESU5HJywgJ1VURi04JywgJ1Byb3BlcnR5IG5vdCBmb3VuZCcpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLnRvLmhhdmUucHJvcGVydHkocHJvcDEsIHByb3AxLCAnUHJvcGVydHkgbm90IGZvdW5kJyk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QoZW52VmFycykudG8uaGF2ZS5wcm9wZXJ0eShwcm9wMiwgcHJvcDIsICdQcm9wZXJ0eSBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgaWYgKGNvbnNvbGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS50by5oYXZlLnByb3BlcnR5KHByb3AzLCBwcm9wMywgJ1Byb3BlcnR5IG5vdCBmb3VuZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS5ub3QudG8uaGF2ZS5wcm9wZXJ0eShwcm9wMywgcHJvcDMsICdQcm9wZXJ0eSBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDb25maXJtIHRoZSBwYXRocyBoYXZlIGJlZW4gYXBwZW5kZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFBhdGggPSBjdXN0b21QYXRoVG9BcHBlbmQgKyBwYXRoLmRlbGltaXRlciArIG1vY2tQcm9jZXNzLmVudltwYXRoVmFyaWFibGVOYW1lXTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChlbnZWYXJzKS50by5oYXZlLnByb3BlcnR5KHBhdGhWYXJpYWJsZU5hbWUsIGV4cGVjdGVkUGF0aCwgJ1BBVEggaXMgbm90IGNvcnJlY3QnKTtcclxuICAgICAgICAgICAgLy8gQ29uZmlybSB0aGUgcGF0aHMgaGF2ZSBiZWVuIGFwcGVuZGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgbGV0IGV4cGVjdGVkUHl0aG9uUGF0aCA9IGN1c3RvbVB5dGhvblBhdGhUb0FwcGVuZDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2NrUHJvY2Vzcy5lbnYuUFlUSE9OUEFUSCA9PT0gJ3N0cmluZycgJiYgbW9ja1Byb2Nlc3MuZW52LlBZVEhPTlBBVEgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRQeXRob25QYXRoID0gY3VzdG9tUHl0aG9uUGF0aFRvQXBwZW5kICsgcGF0aC5kZWxpbWl0ZXIgKyBtb2NrUHJvY2Vzcy5lbnYuUFlUSE9OUEFUSDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KGVudlZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlBBVEgnLCBleHBlY3RlZFB5dGhvblBhdGgsICdQWVRIT05QQVRIIGlzIG5vdCBjb3JyZWN0Jyk7XHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFsbCB2YXJpYWJsZXMgaW4gY3VycmVudCBwcm9jZXNzIG11c3QgYmUgaW4gaGVyZVxyXG4gICAgICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChPYmplY3Qua2V5cyhlbnZWYXJzKS5sZW5ndGgpLmdyZWF0ZXJUaGFuKE9iamVjdC5rZXlzKG1vY2tQcm9jZXNzLmVudikubGVuZ3RoLCAnVmFyaWFibGVzIGlzIG5vdCBhIHN1YnNldCcpO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobW9ja1Byb2Nlc3MuZW52KS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gcGF0aFZhcmlhYmxlTmFtZSB8fCBrZXkgPT09ICdQWVRIT05QQVRIJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QobW9ja1Byb2Nlc3MuZW52W2tleV0pLmVxdWFsKGVudlZhcnNba2V5XSwgYFZhbHVlIGZvciB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgJyR7a2V5fScgaXMgaW5jb3JyZWN0LmApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRlc3QoJ0NvbmZpcm0gcGF0aHMgZ2V0IGFwcGVuZGVkIGNvcnJlY3RseSB3aGVuIHVzaW5nIGpzb24gdmFyaWFibGVzIGFuZCBsYXVuY2hlZCBpbiBleHRlcm5hbCB0ZXJtaW5hbCcsICgpID0+IHRlc3RBcHBlbmRpbmdPZlBhdGhzKCdleHRlcm5hbFRlcm1pbmFsJywgNiwgZmFsc2UpKTtcclxuICAgIHRlc3QoJ0NvbmZpcm0gcGF0aHMgZ2V0IGFwcGVuZGVkIGNvcnJlY3RseSB3aGVuIHVzaW5nIGpzb24gdmFyaWFibGVzIGFuZCBsYXVuY2hlZCBpbiBpbnRlZ3JhdGVkIHRlcm1pbmFsJywgKCkgPT4gdGVzdEFwcGVuZGluZ09mUGF0aHMoJ2ludGVncmF0ZWRUZXJtaW5hbCcsIDYsIGZhbHNlKSk7XHJcbiAgICB0ZXN0KCdDb25maXJtIHBhdGhzIGdldCBhcHBlbmRlZCBjb3JyZWN0bHkgd2hlbiB1c2luZyBqc29uIHZhcmlhYmxlcyBhbmQgbGF1bmNoZWQgaW4gZGVidWcgY29uc29sZScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBBZGQgMyBmb3IgdGhlIDMgbmV3IGpzb24gZW52IHZhcmlhYmxlc1xyXG4gICAgICAgIGxldCBleHBlY3RlZE51bWJlck9mVmFyaWFibGVzID0gT2JqZWN0LmtleXMobW9ja1Byb2Nlc3MuZW52KS5sZW5ndGggKyAzO1xyXG4gICAgICAgIGlmIChtb2NrUHJvY2Vzcy5lbnZbJ1BZVEhPTlVOQlVGRkVSRUQnXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkTnVtYmVyT2ZWYXJpYWJsZXMgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vY2tQcm9jZXNzLmVudlsnUFlUSE9OUEFUSCddID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXhwZWN0ZWROdW1iZXJPZlZhcmlhYmxlcyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9ja1Byb2Nlc3MuZW52WydQWVRIT05JT0VOQ09ESU5HJ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBleHBlY3RlZE51bWJlck9mVmFyaWFibGVzICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIHRlc3RBcHBlbmRpbmdPZlBhdGhzKCdub25lJywgZXhwZWN0ZWROdW1iZXJPZlZhcmlhYmxlcywgZmFsc2UpO1xyXG4gICAgfSkpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52VmFycy50ZXN0LmpzLm1hcCJdfQ==