// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

require("../../client/common/extensions");

const child_process_1 = require("child_process");

const getFreePort = require("get-port");

const path = require("path");

const TypeMoq = require("typemoq");

const vscode_1 = require("vscode");

const constants_1 = require("../../client/common/constants");

const types_1 = require("../../client/common/platform/types");

const util_1 = require("../../client/common/util");

const constants_2 = require("../../client/debugger/constants");

const pythonV2Provider_1 = require("../../client/debugger/extension/configProviders/pythonV2Provider");

const types_2 = require("../../client/debugger/types");

const common_1 = require("../common");

const initialize_1 = require("../initialize");

const utils_1 = require("./utils"); // tslint:disable:no-invalid-this max-func-body-length no-empty no-increment-decrement no-unused-variable no-console


const fileToDebug = path.join(constants_1.EXTENSION_ROOT_DIR, 'src', 'testMultiRootWkspc', 'workspace5', 'remoteDebugger-start-with-ptvsd.py');
suite('Attach Debugger', () => {
  let debugClient;
  let proc;
  setup(function () {
    return __awaiter(this, void 0, void 0, function* () {
      if (!initialize_1.IS_MULTI_ROOT_TEST || !initialize_1.TEST_DEBUGGER) {
        this.skip();
      }

      this.timeout(30000);
      const coverageDirectory = path.join(constants_1.EXTENSION_ROOT_DIR, 'debug_coverage_attach_ptvsd');
      debugClient = yield utils_1.createDebugAdapter(coverageDirectory);
    });
  });
  teardown(() => __awaiter(void 0, void 0, void 0, function* () {
    // Wait for a second before starting another test (sometimes, sockets take a while to get closed).
    yield common_1.sleep(1000);

    try {
      yield debugClient.stop().catch(() => {});
    } catch (ex) {}

    if (proc) {
      try {
        proc.kill();
      } catch (_a) {}
    }
  }));

  function testAttachingToRemoteProcess(localRoot, remoteRoot, isLocalHostWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const localHostPathSeparator = isLocalHostWindows ? '\\' : '/';
      const port = yield getFreePort({
        host: 'localhost',
        port: 3000
      });
      const env = Object.assign({}, process.env); // Set the path for PTVSD to be picked up.
      // tslint:disable-next-line:no-string-literal

      env['PYTHONPATH'] = constants_2.PTVSD_PATH;
      const pythonArgs = ['-m', 'ptvsd', '--host', 'localhost', '--wait', '--port', `${port}`, '--file', fileToDebug.fileToCommandArgument()];
      proc = child_process_1.spawn(common_1.PYTHON_PATH, pythonArgs, {
        env: env,
        cwd: path.dirname(fileToDebug)
      });
      const exited = new Promise(resolve => proc.once('close', resolve));
      yield common_1.sleep(3000); // Send initialize, attach

      const initializePromise = debugClient.initializeRequest({
        adapterID: constants_2.DebuggerTypeName,
        linesStartAt1: true,
        columnsStartAt1: true,
        supportsRunInTerminalRequest: true,
        pathFormat: 'path',
        supportsVariableType: true,
        supportsVariablePaging: true
      });
      const options = {
        name: 'attach',
        request: 'attach',
        localRoot,
        remoteRoot,
        type: constants_2.DebuggerTypeName,
        port: port,
        host: 'localhost',
        logToFile: false,
        debugOptions: [types_2.DebugOptions.RedirectOutput]
      };
      const platformService = TypeMoq.Mock.ofType();
      platformService.setup(p => p.isWindows).returns(() => isLocalHostWindows);
      const serviceContainer = TypeMoq.Mock.ofType();
      serviceContainer.setup(c => c.get(types_1.IPlatformService, TypeMoq.It.isAny())).returns(() => platformService.object);
      const configProvider = new pythonV2Provider_1.PythonV2DebugConfigurationProvider(serviceContainer.object);
      yield configProvider.resolveDebugConfiguration({
        index: 0,
        name: 'root',
        uri: vscode_1.Uri.file(localRoot)
      }, options);
      const attachPromise = debugClient.attachRequest(options);
      yield Promise.all([initializePromise, attachPromise, debugClient.waitForEvent('initialized')]);
      const stdOutPromise = debugClient.assertOutput('stdout', 'this is stdout');
      const stdErrPromise = debugClient.assertOutput('stderr', 'this is stderr'); // Don't use path utils, as we're building the paths manually (mimic windows paths on unix test servers and vice versa).

      const localFileName = `${localRoot}${localHostPathSeparator}${path.basename(fileToDebug)}`;
      const breakpointLocation = {
        path: localFileName,
        column: 1,
        line: 12
      };
      const breakpointPromise = debugClient.setBreakpointsRequest({
        lines: [breakpointLocation.line],
        breakpoints: [{
          line: breakpointLocation.line,
          column: breakpointLocation.column
        }],
        source: {
          path: breakpointLocation.path
        }
      });
      const exceptionBreakpointPromise = debugClient.setExceptionBreakpointsRequest({
        filters: []
      });
      const breakpointStoppedPromise = debugClient.assertStoppedLocation('breakpoint', breakpointLocation);
      yield Promise.all([breakpointPromise, exceptionBreakpointPromise, debugClient.configurationDoneRequest(), debugClient.threadsRequest(), stdOutPromise, stdErrPromise, breakpointStoppedPromise]);
      yield utils_1.continueDebugging(debugClient);
      yield exited;
    });
  }

  test('Confirm we are able to attach to a running program', () => __awaiter(void 0, void 0, void 0, function* () {
    yield testAttachingToRemoteProcess(path.dirname(fileToDebug), path.dirname(fileToDebug), util_1.IS_WINDOWS);
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImF0dGFjaC5wdHZzZC50ZXN0LmpzIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiY2hpbGRfcHJvY2Vzc18xIiwiZ2V0RnJlZVBvcnQiLCJwYXRoIiwiVHlwZU1vcSIsInZzY29kZV8xIiwiY29uc3RhbnRzXzEiLCJ0eXBlc18xIiwidXRpbF8xIiwiY29uc3RhbnRzXzIiLCJweXRob25WMlByb3ZpZGVyXzEiLCJ0eXBlc18yIiwiY29tbW9uXzEiLCJpbml0aWFsaXplXzEiLCJ1dGlsc18xIiwiZmlsZVRvRGVidWciLCJqb2luIiwiRVhURU5TSU9OX1JPT1RfRElSIiwic3VpdGUiLCJkZWJ1Z0NsaWVudCIsInByb2MiLCJzZXR1cCIsIklTX01VTFRJX1JPT1RfVEVTVCIsIlRFU1RfREVCVUdHRVIiLCJza2lwIiwidGltZW91dCIsImNvdmVyYWdlRGlyZWN0b3J5IiwiY3JlYXRlRGVidWdBZGFwdGVyIiwidGVhcmRvd24iLCJzbGVlcCIsInN0b3AiLCJjYXRjaCIsImV4Iiwia2lsbCIsIl9hIiwidGVzdEF0dGFjaGluZ1RvUmVtb3RlUHJvY2VzcyIsImxvY2FsUm9vdCIsInJlbW90ZVJvb3QiLCJpc0xvY2FsSG9zdFdpbmRvd3MiLCJsb2NhbEhvc3RQYXRoU2VwYXJhdG9yIiwicG9ydCIsImhvc3QiLCJlbnYiLCJhc3NpZ24iLCJwcm9jZXNzIiwiUFRWU0RfUEFUSCIsInB5dGhvbkFyZ3MiLCJmaWxlVG9Db21tYW5kQXJndW1lbnQiLCJzcGF3biIsIlBZVEhPTl9QQVRIIiwiY3dkIiwiZGlybmFtZSIsImV4aXRlZCIsIm9uY2UiLCJpbml0aWFsaXplUHJvbWlzZSIsImluaXRpYWxpemVSZXF1ZXN0IiwiYWRhcHRlcklEIiwiRGVidWdnZXJUeXBlTmFtZSIsImxpbmVzU3RhcnRBdDEiLCJjb2x1bW5zU3RhcnRBdDEiLCJzdXBwb3J0c1J1bkluVGVybWluYWxSZXF1ZXN0IiwicGF0aEZvcm1hdCIsInN1cHBvcnRzVmFyaWFibGVUeXBlIiwic3VwcG9ydHNWYXJpYWJsZVBhZ2luZyIsIm9wdGlvbnMiLCJuYW1lIiwicmVxdWVzdCIsInR5cGUiLCJsb2dUb0ZpbGUiLCJkZWJ1Z09wdGlvbnMiLCJEZWJ1Z09wdGlvbnMiLCJSZWRpcmVjdE91dHB1dCIsInBsYXRmb3JtU2VydmljZSIsIk1vY2siLCJvZlR5cGUiLCJwIiwiaXNXaW5kb3dzIiwicmV0dXJucyIsInNlcnZpY2VDb250YWluZXIiLCJjIiwiZ2V0IiwiSVBsYXRmb3JtU2VydmljZSIsIkl0IiwiaXNBbnkiLCJvYmplY3QiLCJjb25maWdQcm92aWRlciIsIlB5dGhvblYyRGVidWdDb25maWd1cmF0aW9uUHJvdmlkZXIiLCJyZXNvbHZlRGVidWdDb25maWd1cmF0aW9uIiwiaW5kZXgiLCJ1cmkiLCJVcmkiLCJmaWxlIiwiYXR0YWNoUHJvbWlzZSIsImF0dGFjaFJlcXVlc3QiLCJhbGwiLCJ3YWl0Rm9yRXZlbnQiLCJzdGRPdXRQcm9taXNlIiwiYXNzZXJ0T3V0cHV0Iiwic3RkRXJyUHJvbWlzZSIsImxvY2FsRmlsZU5hbWUiLCJiYXNlbmFtZSIsImJyZWFrcG9pbnRMb2NhdGlvbiIsImNvbHVtbiIsImxpbmUiLCJicmVha3BvaW50UHJvbWlzZSIsInNldEJyZWFrcG9pbnRzUmVxdWVzdCIsImxpbmVzIiwiYnJlYWtwb2ludHMiLCJzb3VyY2UiLCJleGNlcHRpb25CcmVha3BvaW50UHJvbWlzZSIsInNldEV4Y2VwdGlvbkJyZWFrcG9pbnRzUmVxdWVzdCIsImZpbHRlcnMiLCJicmVha3BvaW50U3RvcHBlZFByb21pc2UiLCJhc3NlcnRTdG9wcGVkTG9jYXRpb24iLCJjb25maWd1cmF0aW9uRG9uZVJlcXVlc3QiLCJ0aHJlYWRzUmVxdWVzdCIsImNvbnRpbnVlRGVidWdnaW5nIiwidGVzdCIsIklTX1dJTkRPV1MiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQSxTQUFTLEdBQUksVUFBUSxTQUFLQSxTQUFkLElBQTRCLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxDQUEvQixFQUFrQ0MsU0FBbEMsRUFBNkM7QUFDckYsU0FBTyxLQUFLRCxDQUFDLEtBQUtBLENBQUMsR0FBR0UsT0FBVCxDQUFOLEVBQXlCLFVBQVVDLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTJCO0FBQ3ZELGFBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO0FBQUUsVUFBSTtBQUFFQyxRQUFBQSxJQUFJLENBQUNOLFNBQVMsQ0FBQ08sSUFBVixDQUFlRixLQUFmLENBQUQsQ0FBSjtBQUE4QixPQUFwQyxDQUFxQyxPQUFPRyxDQUFQLEVBQVU7QUFBRUwsUUFBQUEsTUFBTSxDQUFDSyxDQUFELENBQU47QUFBWTtBQUFFOztBQUMzRixhQUFTQyxRQUFULENBQWtCSixLQUFsQixFQUF5QjtBQUFFLFVBQUk7QUFBRUMsUUFBQUEsSUFBSSxDQUFDTixTQUFTLENBQUMsT0FBRCxDQUFULENBQW1CSyxLQUFuQixDQUFELENBQUo7QUFBa0MsT0FBeEMsQ0FBeUMsT0FBT0csQ0FBUCxFQUFVO0FBQUVMLFFBQUFBLE1BQU0sQ0FBQ0ssQ0FBRCxDQUFOO0FBQVk7QUFBRTs7QUFDOUYsYUFBU0YsSUFBVCxDQUFjSSxNQUFkLEVBQXNCO0FBQUVBLE1BQUFBLE1BQU0sQ0FBQ0MsSUFBUCxHQUFjVCxPQUFPLENBQUNRLE1BQU0sQ0FBQ0wsS0FBUixDQUFyQixHQUFzQyxJQUFJTixDQUFKLENBQU0sVUFBVUcsT0FBVixFQUFtQjtBQUFFQSxRQUFBQSxPQUFPLENBQUNRLE1BQU0sQ0FBQ0wsS0FBUixDQUFQO0FBQXdCLE9BQW5ELEVBQXFETyxJQUFyRCxDQUEwRFIsU0FBMUQsRUFBcUVLLFFB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LENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDMUcsVUFBTXdELDRCQUE0QixDQUFDaEMsSUFBSSxDQUFDZ0QsT0FBTCxDQUFhcEMsV0FBYixDQUFELEVBQTRCWixJQUFJLENBQUNnRCxPQUFMLENBQWFwQyxXQUFiLENBQTVCLEVBQXVEUCxNQUFNLENBQUM4RyxVQUE5RCxDQUFsQztBQUNILEdBRnlFLENBQXRFLENBQUo7QUFHSCxDQWpHSSxDQUFMIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnJlcXVpcmUoXCIuLi8uLi9jbGllbnQvY29tbW9uL2V4dGVuc2lvbnNcIik7XHJcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xyXG5jb25zdCBnZXRGcmVlUG9ydCA9IHJlcXVpcmUoXCJnZXQtcG9ydFwiKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBUeXBlTW9xID0gcmVxdWlyZShcInR5cGVtb3FcIik7XHJcbmNvbnN0IHZzY29kZV8xID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbW1vbi9jb25zdGFudHNcIik7XHJcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbW1vbi9wbGF0Zm9ybS90eXBlc1wiKTtcclxuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vdXRpbFwiKTtcclxuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2RlYnVnZ2VyL2NvbnN0YW50c1wiKTtcclxuY29uc3QgcHl0aG9uVjJQcm92aWRlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9kZWJ1Z2dlci9leHRlbnNpb24vY29uZmlnUHJvdmlkZXJzL3B5dGhvblYyUHJvdmlkZXJcIik7XHJcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2RlYnVnZ2VyL3R5cGVzXCIpO1xyXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XHJcbmNvbnN0IGluaXRpYWxpemVfMSA9IHJlcXVpcmUoXCIuLi9pbml0aWFsaXplXCIpO1xyXG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XHJcbi8vIHRzbGludDpkaXNhYmxlOm5vLWludmFsaWQtdGhpcyBtYXgtZnVuYy1ib2R5LWxlbmd0aCBuby1lbXB0eSBuby1pbmNyZW1lbnQtZGVjcmVtZW50IG5vLXVudXNlZC12YXJpYWJsZSBuby1jb25zb2xlXHJcbmNvbnN0IGZpbGVUb0RlYnVnID0gcGF0aC5qb2luKGNvbnN0YW50c18xLkVYVEVOU0lPTl9ST09UX0RJUiwgJ3NyYycsICd0ZXN0TXVsdGlSb290V2tzcGMnLCAnd29ya3NwYWNlNScsICdyZW1vdGVEZWJ1Z2dlci1zdGFydC13aXRoLXB0dnNkLnB5Jyk7XHJcbnN1aXRlKCdBdHRhY2ggRGVidWdnZXInLCAoKSA9PiB7XHJcbiAgICBsZXQgZGVidWdDbGllbnQ7XHJcbiAgICBsZXQgcHJvYztcclxuICAgIHNldHVwKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxpemVfMS5JU19NVUxUSV9ST09UX1RFU1QgfHwgIWluaXRpYWxpemVfMS5URVNUX0RFQlVHR0VSKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQoMzAwMDApO1xyXG4gICAgICAgICAgICBjb25zdCBjb3ZlcmFnZURpcmVjdG9yeSA9IHBhdGguam9pbihjb25zdGFudHNfMS5FWFRFTlNJT05fUk9PVF9ESVIsICdkZWJ1Z19jb3ZlcmFnZV9hdHRhY2hfcHR2c2QnKTtcclxuICAgICAgICAgICAgZGVidWdDbGllbnQgPSB5aWVsZCB1dGlsc18xLmNyZWF0ZURlYnVnQWRhcHRlcihjb3ZlcmFnZURpcmVjdG9yeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHRlYXJkb3duKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBXYWl0IGZvciBhIHNlY29uZCBiZWZvcmUgc3RhcnRpbmcgYW5vdGhlciB0ZXN0IChzb21ldGltZXMsIHNvY2tldHMgdGFrZSBhIHdoaWxlIHRvIGdldCBjbG9zZWQpLlxyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLnNsZWVwKDEwMDApO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGRlYnVnQ2xpZW50LnN0b3AoKS5jYXRjaCgoKSA9PiB7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXgpIHsgfVxyXG4gICAgICAgIGlmIChwcm9jKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jLmtpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgICAgIH1cclxuICAgIH0pKTtcclxuICAgIGZ1bmN0aW9uIHRlc3RBdHRhY2hpbmdUb1JlbW90ZVByb2Nlc3MobG9jYWxSb290LCByZW1vdGVSb290LCBpc0xvY2FsSG9zdFdpbmRvd3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhbEhvc3RQYXRoU2VwYXJhdG9yID0gaXNMb2NhbEhvc3RXaW5kb3dzID8gJ1xcXFwnIDogJy8nO1xyXG4gICAgICAgICAgICBjb25zdCBwb3J0ID0geWllbGQgZ2V0RnJlZVBvcnQoeyBob3N0OiAnbG9jYWxob3N0JywgcG9ydDogMzAwMCB9KTtcclxuICAgICAgICAgICAgY29uc3QgZW52ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYpO1xyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHBhdGggZm9yIFBUVlNEIHRvIGJlIHBpY2tlZCB1cC5cclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN0cmluZy1saXRlcmFsXHJcbiAgICAgICAgICAgIGVudlsnUFlUSE9OUEFUSCddID0gY29uc3RhbnRzXzIuUFRWU0RfUEFUSDtcclxuICAgICAgICAgICAgY29uc3QgcHl0aG9uQXJncyA9IFsnLW0nLCAncHR2c2QnLCAnLS1ob3N0JywgJ2xvY2FsaG9zdCcsICctLXdhaXQnLCAnLS1wb3J0JywgYCR7cG9ydH1gLCAnLS1maWxlJywgZmlsZVRvRGVidWcuZmlsZVRvQ29tbWFuZEFyZ3VtZW50KCldO1xyXG4gICAgICAgICAgICBwcm9jID0gY2hpbGRfcHJvY2Vzc18xLnNwYXduKGNvbW1vbl8xLlBZVEhPTl9QQVRILCBweXRob25BcmdzLCB7IGVudjogZW52LCBjd2Q6IHBhdGguZGlybmFtZShmaWxlVG9EZWJ1ZykgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXRlZCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gcHJvYy5vbmNlKCdjbG9zZScsIHJlc29sdmUpKTtcclxuICAgICAgICAgICAgeWllbGQgY29tbW9uXzEuc2xlZXAoMzAwMCk7XHJcbiAgICAgICAgICAgIC8vIFNlbmQgaW5pdGlhbGl6ZSwgYXR0YWNoXHJcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxpemVQcm9taXNlID0gZGVidWdDbGllbnQuaW5pdGlhbGl6ZVJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgYWRhcHRlcklEOiBjb25zdGFudHNfMi5EZWJ1Z2dlclR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgbGluZXNTdGFydEF0MTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbHVtbnNTdGFydEF0MTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1cHBvcnRzUnVuSW5UZXJtaW5hbFJlcXVlc3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwYXRoRm9ybWF0OiAncGF0aCcsXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1ZhcmlhYmxlVHlwZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1cHBvcnRzVmFyaWFibGVQYWdpbmc6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXR0YWNoJyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICdhdHRhY2gnLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxSb290LFxyXG4gICAgICAgICAgICAgICAgcmVtb3RlUm9vdCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IGNvbnN0YW50c18yLkRlYnVnZ2VyVHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBwb3J0OiBwb3J0LFxyXG4gICAgICAgICAgICAgICAgaG9zdDogJ2xvY2FsaG9zdCcsXHJcbiAgICAgICAgICAgICAgICBsb2dUb0ZpbGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZGVidWdPcHRpb25zOiBbdHlwZXNfMi5EZWJ1Z09wdGlvbnMuUmVkaXJlY3RPdXRwdXRdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYXRmb3JtU2VydmljZSA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICAgICAgcGxhdGZvcm1TZXJ2aWNlLnNldHVwKHAgPT4gcC5pc1dpbmRvd3MpLnJldHVybnMoKCkgPT4gaXNMb2NhbEhvc3RXaW5kb3dzKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmljZUNvbnRhaW5lciA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICAgICAgc2VydmljZUNvbnRhaW5lci5zZXR1cChjID0+IGMuZ2V0KHR5cGVzXzEuSVBsYXRmb3JtU2VydmljZSwgVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucygoKSA9PiBwbGF0Zm9ybVNlcnZpY2Uub2JqZWN0KTtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnUHJvdmlkZXIgPSBuZXcgcHl0aG9uVjJQcm92aWRlcl8xLlB5dGhvblYyRGVidWdDb25maWd1cmF0aW9uUHJvdmlkZXIoc2VydmljZUNvbnRhaW5lci5vYmplY3QpO1xyXG4gICAgICAgICAgICB5aWVsZCBjb25maWdQcm92aWRlci5yZXNvbHZlRGVidWdDb25maWd1cmF0aW9uKHsgaW5kZXg6IDAsIG5hbWU6ICdyb290JywgdXJpOiB2c2NvZGVfMS5VcmkuZmlsZShsb2NhbFJvb3QpIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBhdHRhY2hQcm9taXNlID0gZGVidWdDbGllbnQuYXR0YWNoUmVxdWVzdChvcHRpb25zKTtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZVByb21pc2UsXHJcbiAgICAgICAgICAgICAgICBhdHRhY2hQcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgZGVidWdDbGllbnQud2FpdEZvckV2ZW50KCdpbml0aWFsaXplZCcpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICBjb25zdCBzdGRPdXRQcm9taXNlID0gZGVidWdDbGllbnQuYXNzZXJ0T3V0cHV0KCdzdGRvdXQnLCAndGhpcyBpcyBzdGRvdXQnKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RkRXJyUHJvbWlzZSA9IGRlYnVnQ2xpZW50LmFzc2VydE91dHB1dCgnc3RkZXJyJywgJ3RoaXMgaXMgc3RkZXJyJyk7XHJcbiAgICAgICAgICAgIC8vIERvbid0IHVzZSBwYXRoIHV0aWxzLCBhcyB3ZSdyZSBidWlsZGluZyB0aGUgcGF0aHMgbWFudWFsbHkgKG1pbWljIHdpbmRvd3MgcGF0aHMgb24gdW5peCB0ZXN0IHNlcnZlcnMgYW5kIHZpY2UgdmVyc2EpLlxyXG4gICAgICAgICAgICBjb25zdCBsb2NhbEZpbGVOYW1lID0gYCR7bG9jYWxSb290fSR7bG9jYWxIb3N0UGF0aFNlcGFyYXRvcn0ke3BhdGguYmFzZW5hbWUoZmlsZVRvRGVidWcpfWA7XHJcbiAgICAgICAgICAgIGNvbnN0IGJyZWFrcG9pbnRMb2NhdGlvbiA9IHsgcGF0aDogbG9jYWxGaWxlTmFtZSwgY29sdW1uOiAxLCBsaW5lOiAxMiB9O1xyXG4gICAgICAgICAgICBjb25zdCBicmVha3BvaW50UHJvbWlzZSA9IGRlYnVnQ2xpZW50LnNldEJyZWFrcG9pbnRzUmVxdWVzdCh7XHJcbiAgICAgICAgICAgICAgICBsaW5lczogW2JyZWFrcG9pbnRMb2NhdGlvbi5saW5lXSxcclxuICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzOiBbeyBsaW5lOiBicmVha3BvaW50TG9jYXRpb24ubGluZSwgY29sdW1uOiBicmVha3BvaW50TG9jYXRpb24uY29sdW1uIH1dLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiB7IHBhdGg6IGJyZWFrcG9pbnRMb2NhdGlvbi5wYXRoIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4Y2VwdGlvbkJyZWFrcG9pbnRQcm9taXNlID0gZGVidWdDbGllbnQuc2V0RXhjZXB0aW9uQnJlYWtwb2ludHNSZXF1ZXN0KHsgZmlsdGVyczogW10gfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJyZWFrcG9pbnRTdG9wcGVkUHJvbWlzZSA9IGRlYnVnQ2xpZW50LmFzc2VydFN0b3BwZWRMb2NhdGlvbignYnJlYWtwb2ludCcsIGJyZWFrcG9pbnRMb2NhdGlvbik7XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRQcm9taXNlLCBleGNlcHRpb25CcmVha3BvaW50UHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIGRlYnVnQ2xpZW50LmNvbmZpZ3VyYXRpb25Eb25lUmVxdWVzdCgpLCBkZWJ1Z0NsaWVudC50aHJlYWRzUmVxdWVzdCgpLFxyXG4gICAgICAgICAgICAgICAgc3RkT3V0UHJvbWlzZSwgc3RkRXJyUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRTdG9wcGVkUHJvbWlzZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgeWllbGQgdXRpbHNfMS5jb250aW51ZURlYnVnZ2luZyhkZWJ1Z0NsaWVudCk7XHJcbiAgICAgICAgICAgIHlpZWxkIGV4aXRlZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRlc3QoJ0NvbmZpcm0gd2UgYXJlIGFibGUgdG8gYXR0YWNoIHRvIGEgcnVubmluZyBwcm9ncmFtJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIHRlc3RBdHRhY2hpbmdUb1JlbW90ZVByb2Nlc3MocGF0aC5kaXJuYW1lKGZpbGVUb0RlYnVnKSwgcGF0aC5kaXJuYW1lKGZpbGVUb0RlYnVnKSwgdXRpbF8xLklTX1dJTkRPV1MpO1xyXG4gICAgfSkpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0YWNoLnB0dnNkLnRlc3QuanMubWFwIl19