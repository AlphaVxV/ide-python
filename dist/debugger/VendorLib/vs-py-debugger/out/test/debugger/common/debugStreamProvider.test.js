"use strict"; // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const chai_1 = require("chai");

const getFreePort = require("get-port");

const net = require("net");

const TypeMoq = require("typemoq");

const types_1 = require("../../../client/common/types");

const debugStreamProvider_1 = require("../../../client/debugger/debugAdapter/Common/debugStreamProvider");

const common_1 = require("../../common"); // tslint:disable-next-line:max-func-body-length


suite('Debugging - Stream Provider', () => {
  let streamProvider;
  let serviceContainer;
  setup(() => {
    serviceContainer = TypeMoq.Mock.ofType();
    streamProvider = new debugStreamProvider_1.DebugStreamProvider(serviceContainer.object);
  });
  test('Process is returned as is if there is no port number if args', () => __awaiter(void 0, void 0, void 0, function* () {
    const mockProcess = {
      argv: [],
      env: [],
      stdin: '1234',
      stdout: '5678'
    };
    serviceContainer.setup(c => c.get(TypeMoq.It.isValue(types_1.ICurrentProcess))).returns(() => mockProcess);
    const streams = yield streamProvider.getInputAndOutputStreams();
    chai_1.expect(streams.input).to.be.equal(mockProcess.stdin);
    chai_1.expect(streams.output).to.be.equal(mockProcess.stdout);
  }));
  test('Starts a socketserver on the port provided and returns the client socket', () => __awaiter(void 0, void 0, void 0, function* () {
    const port = yield getFreePort({
      host: 'localhost',
      port: 3000
    });
    const mockProcess = {
      argv: ['node', 'index.js', `--server=${port}`],
      env: [],
      stdin: '1234',
      stdout: '5678'
    };
    serviceContainer.setup(c => c.get(TypeMoq.It.isValue(types_1.ICurrentProcess))).returns(() => mockProcess);
    const streamsPromise = streamProvider.getInputAndOutputStreams();
    yield common_1.sleep(1);
    yield new Promise(resolve => {
      net.connect({
        port,
        host: 'localhost'
      }, resolve);
    });
    const streams = yield streamsPromise;
    chai_1.expect(streams.input).to.not.be.equal(mockProcess.stdin);
    chai_1.expect(streams.output).to.not.be.equal(mockProcess.stdout);
  }));
  test('Ensure existence of port is identified', () => __awaiter(void 0, void 0, void 0, function* () {
    const port = yield getFreePort({
      host: 'localhost',
      port: 3000
    });
    const mockProcess = {
      argv: ['node', 'index.js', `--server=${port}`],
      env: [],
      stdin: '1234',
      stdout: '5678'
    };
    serviceContainer.setup(c => c.get(TypeMoq.It.isValue(types_1.ICurrentProcess))).returns(() => mockProcess);
    chai_1.expect(streamProvider.useDebugSocketStream).to.be.equal(true, 'incorrect');
  }));
  test('Ensure non-existence of port is identified', () => __awaiter(void 0, void 0, void 0, function* () {
    const port = yield getFreePort({
      host: 'localhost',
      port: 3000
    });
    const mockProcess = {
      argv: ['node', 'index.js', `--other=${port}`],
      env: [],
      stdin: '1234',
      stdout: '5678'
    };
    serviceContainer.setup(c => c.get(TypeMoq.It.isValue(types_1.ICurrentProcess))).returns(() => mockProcess);
    chai_1.expect(streamProvider.useDebugSocketStream).to.not.be.equal(true, 'incorrect');
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlYnVnU3RyZWFtUHJvdmlkZXIudGVzdC5qcyJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInZhbHVlIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiY2hhaV8xIiwicmVxdWlyZSIsImdldEZyZWVQb3J0IiwibmV0IiwiVHlwZU1vcSIsInR5cGVzXzEiLCJkZWJ1Z1N0cmVhbVByb3ZpZGVyXzEiLCJjb21tb25fMSIsInN1aXRlIiwic3RyZWFtUHJvdmlkZXIiLCJzZXJ2aWNlQ29udGFpbmVyIiwic2V0dXAiLCJNb2NrIiwib2ZUeXBlIiwiRGVidWdTdHJlYW1Qcm92aWRlciIsIm9iamVjdCIsInRlc3QiLCJtb2NrUHJvY2VzcyIsImFyZ3YiLCJlbnYiLCJzdGRpbiIsInN0ZG91dCIsImMiLCJnZXQiLCJJdCIsImlzVmFsdWUiLCJJQ3VycmVudFByb2Nlc3MiLCJyZXR1cm5zIiwic3RyZWFtcyIsImdldElucHV0QW5kT3V0cHV0U3RyZWFtcyIsImV4cGVjdCIsImlucHV0IiwidG8iLCJiZSIsImVxdWFsIiwib3V0cHV0IiwicG9ydCIsImhvc3QiLCJzdHJlYW1zUHJvbWlzZSIsInNsZWVwIiwiY29ubmVjdCIsIm5vdCIsInVzZURlYnVnU29ja2V0U3RyZWFtIl0sIm1hcHBpbmdzIjoiQUFBQSxhLENBQ0E7QUFDQTs7QUFDQSxJQUFJQSxTQUFTLEdBQUksVUFBUSxTQUFLQSxTQUFkLElBQTRCLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxDQUEvQixFQUFrQ0MsU0FBbEMsRUFBNkM7QUFDckYsU0FBTyxLQUFLRCxDQUFDLEtBQUtBLENBQUMsR0FBR0UsT0FBVCxDQUFOLEVBQXlC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d0YsTUFBTVYsV0FBOUY7QUFDQWpCLElBQUFBLE1BQU0sQ0FBQzhCLE1BQVAsQ0FBY3JCLGNBQWMsQ0FBQ2lDLG9CQUE3QixFQUFtRFYsRUFBbkQsQ0FBc0RTLEdBQXRELENBQTBEUixFQUExRCxDQUE2REMsS0FBN0QsQ0FBbUUsSUFBbkUsRUFBeUUsV0FBekU7QUFDSCxHQUxpRSxDQUE5RCxDQUFKO0FBTUgsQ0F2Q0ksQ0FBTCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNoYWlfMSA9IHJlcXVpcmUoXCJjaGFpXCIpO1xyXG5jb25zdCBnZXRGcmVlUG9ydCA9IHJlcXVpcmUoXCJnZXQtcG9ydFwiKTtcclxuY29uc3QgbmV0ID0gcmVxdWlyZShcIm5ldFwiKTtcclxuY29uc3QgVHlwZU1vcSA9IHJlcXVpcmUoXCJ0eXBlbW9xXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vdHlwZXNcIik7XHJcbmNvbnN0IGRlYnVnU3RyZWFtUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvZGVidWdnZXIvZGVidWdBZGFwdGVyL0NvbW1vbi9kZWJ1Z1N0cmVhbVByb3ZpZGVyXCIpO1xyXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtZnVuYy1ib2R5LWxlbmd0aFxyXG5zdWl0ZSgnRGVidWdnaW5nIC0gU3RyZWFtIFByb3ZpZGVyJywgKCkgPT4ge1xyXG4gICAgbGV0IHN0cmVhbVByb3ZpZGVyO1xyXG4gICAgbGV0IHNlcnZpY2VDb250YWluZXI7XHJcbiAgICBzZXR1cCgoKSA9PiB7XHJcbiAgICAgICAgc2VydmljZUNvbnRhaW5lciA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICBzdHJlYW1Qcm92aWRlciA9IG5ldyBkZWJ1Z1N0cmVhbVByb3ZpZGVyXzEuRGVidWdTdHJlYW1Qcm92aWRlcihzZXJ2aWNlQ29udGFpbmVyLm9iamVjdCk7XHJcbiAgICB9KTtcclxuICAgIHRlc3QoJ1Byb2Nlc3MgaXMgcmV0dXJuZWQgYXMgaXMgaWYgdGhlcmUgaXMgbm8gcG9ydCBudW1iZXIgaWYgYXJncycsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBtb2NrUHJvY2VzcyA9IHsgYXJndjogW10sIGVudjogW10sIHN0ZGluOiAnMTIzNCcsIHN0ZG91dDogJzU2NzgnIH07XHJcbiAgICAgICAgc2VydmljZUNvbnRhaW5lci5zZXR1cChjID0+IGMuZ2V0KFR5cGVNb3EuSXQuaXNWYWx1ZSh0eXBlc18xLklDdXJyZW50UHJvY2VzcykpKS5yZXR1cm5zKCgpID0+IG1vY2tQcm9jZXNzKTtcclxuICAgICAgICBjb25zdCBzdHJlYW1zID0geWllbGQgc3RyZWFtUHJvdmlkZXIuZ2V0SW5wdXRBbmRPdXRwdXRTdHJlYW1zKCk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdChzdHJlYW1zLmlucHV0KS50by5iZS5lcXVhbChtb2NrUHJvY2Vzcy5zdGRpbik7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdChzdHJlYW1zLm91dHB1dCkudG8uYmUuZXF1YWwobW9ja1Byb2Nlc3Muc3Rkb3V0KTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ1N0YXJ0cyBhIHNvY2tldHNlcnZlciBvbiB0aGUgcG9ydCBwcm92aWRlZCBhbmQgcmV0dXJucyB0aGUgY2xpZW50IHNvY2tldCcsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBwb3J0ID0geWllbGQgZ2V0RnJlZVBvcnQoeyBob3N0OiAnbG9jYWxob3N0JywgcG9ydDogMzAwMCB9KTtcclxuICAgICAgICBjb25zdCBtb2NrUHJvY2VzcyA9IHsgYXJndjogWydub2RlJywgJ2luZGV4LmpzJywgYC0tc2VydmVyPSR7cG9ydH1gXSwgZW52OiBbXSwgc3RkaW46ICcxMjM0Jywgc3Rkb3V0OiAnNTY3OCcgfTtcclxuICAgICAgICBzZXJ2aWNlQ29udGFpbmVyLnNldHVwKGMgPT4gYy5nZXQoVHlwZU1vcS5JdC5pc1ZhbHVlKHR5cGVzXzEuSUN1cnJlbnRQcm9jZXNzKSkpLnJldHVybnMoKCkgPT4gbW9ja1Byb2Nlc3MpO1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbXNQcm9taXNlID0gc3RyZWFtUHJvdmlkZXIuZ2V0SW5wdXRBbmRPdXRwdXRTdHJlYW1zKCk7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEuc2xlZXAoMSk7XHJcbiAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIG5ldC5jb25uZWN0KHsgcG9ydCwgaG9zdDogJ2xvY2FsaG9zdCcgfSwgcmVzb2x2ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtcyA9IHlpZWxkIHN0cmVhbXNQcm9taXNlO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3Qoc3RyZWFtcy5pbnB1dCkudG8ubm90LmJlLmVxdWFsKG1vY2tQcm9jZXNzLnN0ZGluKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHN0cmVhbXMub3V0cHV0KS50by5ub3QuYmUuZXF1YWwobW9ja1Byb2Nlc3Muc3Rkb3V0KTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0Vuc3VyZSBleGlzdGVuY2Ugb2YgcG9ydCBpcyBpZGVudGlmaWVkJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHBvcnQgPSB5aWVsZCBnZXRGcmVlUG9ydCh7IGhvc3Q6ICdsb2NhbGhvc3QnLCBwb3J0OiAzMDAwIH0pO1xyXG4gICAgICAgIGNvbnN0IG1vY2tQcm9jZXNzID0geyBhcmd2OiBbJ25vZGUnLCAnaW5kZXguanMnLCBgLS1zZXJ2ZXI9JHtwb3J0fWBdLCBlbnY6IFtdLCBzdGRpbjogJzEyMzQnLCBzdGRvdXQ6ICc1Njc4JyB9O1xyXG4gICAgICAgIHNlcnZpY2VDb250YWluZXIuc2V0dXAoYyA9PiBjLmdldChUeXBlTW9xLkl0LmlzVmFsdWUodHlwZXNfMS5JQ3VycmVudFByb2Nlc3MpKSkucmV0dXJucygoKSA9PiBtb2NrUHJvY2Vzcyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdChzdHJlYW1Qcm92aWRlci51c2VEZWJ1Z1NvY2tldFN0cmVhbSkudG8uYmUuZXF1YWwodHJ1ZSwgJ2luY29ycmVjdCcpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnRW5zdXJlIG5vbi1leGlzdGVuY2Ugb2YgcG9ydCBpcyBpZGVudGlmaWVkJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHBvcnQgPSB5aWVsZCBnZXRGcmVlUG9ydCh7IGhvc3Q6ICdsb2NhbGhvc3QnLCBwb3J0OiAzMDAwIH0pO1xyXG4gICAgICAgIGNvbnN0IG1vY2tQcm9jZXNzID0geyBhcmd2OiBbJ25vZGUnLCAnaW5kZXguanMnLCBgLS1vdGhlcj0ke3BvcnR9YF0sIGVudjogW10sIHN0ZGluOiAnMTIzNCcsIHN0ZG91dDogJzU2NzgnIH07XHJcbiAgICAgICAgc2VydmljZUNvbnRhaW5lci5zZXR1cChjID0+IGMuZ2V0KFR5cGVNb3EuSXQuaXNWYWx1ZSh0eXBlc18xLklDdXJyZW50UHJvY2VzcykpKS5yZXR1cm5zKCgpID0+IG1vY2tQcm9jZXNzKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHN0cmVhbVByb3ZpZGVyLnVzZURlYnVnU29ja2V0U3RyZWFtKS50by5ub3QuYmUuZXF1YWwodHJ1ZSwgJ2luY29ycmVjdCcpO1xyXG4gICAgfSkpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWdTdHJlYW1Qcm92aWRlci50ZXN0LmpzLm1hcCJdfQ==