"use strict"; // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const chai_1 = require("chai");

const stream_1 = require("stream");

const async_1 = require("../../../client/common/utils/async");

const protocolParser_1 = require("../../../client/debugger/debugAdapter/Common/protocolParser");

const common_1 = require("../../common");

suite('Debugging - Protocol Parser', () => {
  test('Test request, response and event messages', () => __awaiter(void 0, void 0, void 0, function* () {
    const stream = new stream_1.PassThrough();
    const protocolParser = new protocolParser_1.ProtocolParser();
    protocolParser.connect(stream);
    let messagesDetected = 0;
    protocolParser.on('data', () => messagesDetected += 1);
    const requestDetected = new Promise(resolve => {
      protocolParser.on('request_initialize', () => resolve(true));
    });
    const responseDetected = new Promise(resolve => {
      protocolParser.on('response_initialize', () => resolve(true));
    });
    const eventDetected = new Promise(resolve => {
      protocolParser.on('event_initialized', () => resolve(true));
    });
    stream.write('Content-Length: 289\r\n\r\n{"command":"initialize","arguments":{"clientID":"vscode","adapterID":"pythonExperiment","pathFormat":"path","linesStartAt1":true,"columnsStartAt1":true,"supportsVariableType":true,"supportsVariablePaging":true,"supportsRunInTerminalRequest":true,"locale":"en-us"},"type":"request","seq":1}');
    yield chai_1.expect(requestDetected).to.eventually.equal(true, 'request not parsed');
    stream.write('Content-Length: 265\r\n\r\n{"seq":1,"type":"response","request_seq":1,"command":"initialize","success":true,"body":{"supportsEvaluateForHovers":false,"supportsConditionalBreakpoints":true,"supportsConfigurationDoneRequest":true,"supportsFunctionBreakpoints":false,"supportsSetVariable":true}}');
    yield chai_1.expect(responseDetected).to.eventually.equal(true, 'response not parsed');
    stream.write('Content-Length: 63\r\n\r\n{"type": "event", "seq": 1, "event": "initialized", "body": {}}');
    yield chai_1.expect(eventDetected).to.eventually.equal(true, 'event not parsed');
    chai_1.expect(messagesDetected).to.be.equal(3, 'incorrect number of protocol messages');
  }));
  test('Ensure messages are not received after disposing the parser', () => __awaiter(void 0, void 0, void 0, function* () {
    const stream = new stream_1.PassThrough();
    const protocolParser = new protocolParser_1.ProtocolParser();
    protocolParser.connect(stream);
    let messagesDetected = 0;
    protocolParser.on('data', () => messagesDetected += 1);
    const requestDetected = new Promise(resolve => {
      protocolParser.on('request_initialize', () => resolve(true));
    });
    stream.write('Content-Length: 289\r\n\r\n{"command":"initialize","arguments":{"clientID":"vscode","adapterID":"pythonExperiment","pathFormat":"path","linesStartAt1":true,"columnsStartAt1":true,"supportsVariableType":true,"supportsVariablePaging":true,"supportsRunInTerminalRequest":true,"locale":"en-us"},"type":"request","seq":1}');
    yield chai_1.expect(requestDetected).to.eventually.equal(true, 'request not parsed');
    protocolParser.dispose();
    const responseDetected = async_1.createDeferred();
    protocolParser.on('response_initialize', () => responseDetected.resolve(true));
    stream.write('Content-Length: 265\r\n\r\n{"seq":1,"type":"response","request_seq":1,"command":"initialize","success":true,"body":{"supportsEvaluateForHovers":false,"supportsConditionalBreakpoints":true,"supportsConfigurationDoneRequest":true,"supportsFunctionBreakpoints":false,"supportsSetVariable":true}}'); // Wait for messages to go through and get parsed (unnecenssary, but add for testing edge cases).

    yield common_1.sleep(1000);
    chai_1.expect(responseDetected.completed).to.be.equal(false, 'Promise should not have resolved');
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByb3RvY29scGFyc2VyLnRlc3QuanMiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImNoYWlfMSIsInJlcXVpcmUiLCJzdHJlYW1fMSIsImFzeW5jXzEiLCJwcm90b2NvbFBhcnNlcl8xIiwiY29tbW9uXzEiLCJzdWl0ZSIsInRlc3QiLCJzdHJlYW0iLCJQYXNzVGhyb3VnaCIsInByb3RvY29sUGFyc2VyIiwiUHJvdG9jb2xQYXJzZXIiLCJjb25uZWN0IiwibWVzc2FnZXNEZXRlY3RlZCIsIm9uIiwicmVxdWVzdERldGVjdGVkIiwicmVzcG9uc2VEZXRlY3RlZCIsImV2ZW50RGV0ZWN0ZWQiLCJ3cml0ZSIsImV4cGVjdCIsInRvIiwiZXZlbnR1YWxseSIsImVxdWFsIiwiYmUiLCJkaXNwb3NlIiwiY3JlYXRlRGVmZXJyZWQiLCJzbGVlcCIsImNvbXBsZXRlZCJdLCJtYXBwaW5ncyI6IkFBQUEsYSxDQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsU0FBUyxHQUFJLFVBQVEsU0FBS0EsU0FBZCxJQUE0QixVQUFVQyxPQUFWLEVBQW1CQyxVQUFuQixFQUErQkMsQ0FBL0IsRUFBa0NDLFNBQWxDLEVBQTZDO0FBQ3JGLFNBQU8sS0FBS0QsQ0FBQyxLQUFLQSxDQUFDLEdBQUdFLE9BQVQsQ0FBTixFQUF5QixVQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUN2RCxhQUFTQyxTQUFULENBQW1CQyxLQUFuQixFQUEwQjtBQUFFLFVBQUk7QUFBRUMsUUFBQUEsSUFBSSxDQUFDTixTQUFTLENBQUNPLElBQVYsQ0FBZUYsS0FBZixDQUFELENBQUo7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QUkvQixPQUFKLENBQVlDLE9BQU8sSUFBSTtBQUMzQ3lCLE1BQUFBLGNBQWMsQ0FBQ0ksRUFBZixDQUFrQixvQkFBbEIsRUFBd0MsTUFBTTdCLE9BQU8sQ0FBQyxJQUFELENBQXJEO0FBQ0gsS0FGdUIsQ0FBeEI7QUFHQXVCLElBQUFBLE1BQU0sQ0FBQ1UsS0FBUCxDQUFhLDhUQUFiO0FBQ0EsVUFBTWxCLE1BQU0sQ0FBQ21CLE1BQVAsQ0FBY0osZUFBZCxFQUErQkssRUFBL0IsQ0FBa0NDLFVBQWxDLENBQTZDQyxLQUE3QyxDQUFtRCxJQUFuRCxFQUF5RCxvQkFBekQsQ0FBTjtBQUNBWixJQUFBQSxjQUFjLENBQUNjLE9BQWY7QUFDQSxVQUFNUixnQkFBZ0IsR0FBR2IsT0FBTyxDQUFDc0IsY0FBUixFQUF6QjtBQUNBZixJQUFBQSxjQUFjLENBQUNJLEVBQWYsQ0FBa0IscUJBQWxCLEVBQXlDLE1BQU1FLGdCQUFnQixDQUFDL0IsT0FBakIsQ0FBeUIsSUFBekIsQ0FBL0M7QUFDQXVCLElBQUFBLE1BQU0sQ0FBQ1UsS0FBUCxDQUFhLHNTQUFiLEVBZG1ILENBZW5IOztBQUNBLFVBQU1iLFFBQVEsQ0FBQ3FCLEtBQVQsQ0FBZSxJQUFmLENBQU47QUFDQTFCLElBQUFBLE1BQU0sQ0FBQ21CLE1BQVAsQ0FBY0gsZ0JBQWdCLENBQUNXLFNBQS9CLEVBQTBDUCxFQUExQyxDQUE2Q0csRUFBN0MsQ0FBZ0RELEtBQWhELENBQXNELEtBQXRELEVBQTZELGtDQUE3RDtBQUNILEdBbEJrRixDQUEvRSxDQUFKO0FBbUJILENBM0NJLENBQUwiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjaGFpXzEgPSByZXF1aXJlKFwiY2hhaVwiKTtcclxuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xyXG5jb25zdCBhc3luY18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vdXRpbHMvYXN5bmNcIik7XHJcbmNvbnN0IHByb3RvY29sUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2RlYnVnZ2VyL2RlYnVnQWRhcHRlci9Db21tb24vcHJvdG9jb2xQYXJzZXJcIik7XHJcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vblwiKTtcclxuc3VpdGUoJ0RlYnVnZ2luZyAtIFByb3RvY29sIFBhcnNlcicsICgpID0+IHtcclxuICAgIHRlc3QoJ1Rlc3QgcmVxdWVzdCwgcmVzcG9uc2UgYW5kIGV2ZW50IG1lc3NhZ2VzJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzdHJlYW1fMS5QYXNzVGhyb3VnaCgpO1xyXG4gICAgICAgIGNvbnN0IHByb3RvY29sUGFyc2VyID0gbmV3IHByb3RvY29sUGFyc2VyXzEuUHJvdG9jb2xQYXJzZXIoKTtcclxuICAgICAgICBwcm90b2NvbFBhcnNlci5jb25uZWN0KHN0cmVhbSk7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2VzRGV0ZWN0ZWQgPSAwO1xyXG4gICAgICAgIHByb3RvY29sUGFyc2VyLm9uKCdkYXRhJywgKCkgPT4gbWVzc2FnZXNEZXRlY3RlZCArPSAxKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0RGV0ZWN0ZWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgcHJvdG9jb2xQYXJzZXIub24oJ3JlcXVlc3RfaW5pdGlhbGl6ZScsICgpID0+IHJlc29sdmUodHJ1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGV0ZWN0ZWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgcHJvdG9jb2xQYXJzZXIub24oJ3Jlc3BvbnNlX2luaXRpYWxpemUnLCAoKSA9PiByZXNvbHZlKHRydWUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBldmVudERldGVjdGVkID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIHByb3RvY29sUGFyc2VyLm9uKCdldmVudF9pbml0aWFsaXplZCcsICgpID0+IHJlc29sdmUodHJ1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbS53cml0ZSgnQ29udGVudC1MZW5ndGg6IDI4OVxcclxcblxcclxcbntcImNvbW1hbmRcIjpcImluaXRpYWxpemVcIixcImFyZ3VtZW50c1wiOntcImNsaWVudElEXCI6XCJ2c2NvZGVcIixcImFkYXB0ZXJJRFwiOlwicHl0aG9uRXhwZXJpbWVudFwiLFwicGF0aEZvcm1hdFwiOlwicGF0aFwiLFwibGluZXNTdGFydEF0MVwiOnRydWUsXCJjb2x1bW5zU3RhcnRBdDFcIjp0cnVlLFwic3VwcG9ydHNWYXJpYWJsZVR5cGVcIjp0cnVlLFwic3VwcG9ydHNWYXJpYWJsZVBhZ2luZ1wiOnRydWUsXCJzdXBwb3J0c1J1bkluVGVybWluYWxSZXF1ZXN0XCI6dHJ1ZSxcImxvY2FsZVwiOlwiZW4tdXNcIn0sXCJ0eXBlXCI6XCJyZXF1ZXN0XCIsXCJzZXFcIjoxfScpO1xyXG4gICAgICAgIHlpZWxkIGNoYWlfMS5leHBlY3QocmVxdWVzdERldGVjdGVkKS50by5ldmVudHVhbGx5LmVxdWFsKHRydWUsICdyZXF1ZXN0IG5vdCBwYXJzZWQnKTtcclxuICAgICAgICBzdHJlYW0ud3JpdGUoJ0NvbnRlbnQtTGVuZ3RoOiAyNjVcXHJcXG5cXHJcXG57XCJzZXFcIjoxLFwidHlwZVwiOlwicmVzcG9uc2VcIixcInJlcXVlc3Rfc2VxXCI6MSxcImNvbW1hbmRcIjpcImluaXRpYWxpemVcIixcInN1Y2Nlc3NcIjp0cnVlLFwiYm9keVwiOntcInN1cHBvcnRzRXZhbHVhdGVGb3JIb3ZlcnNcIjpmYWxzZSxcInN1cHBvcnRzQ29uZGl0aW9uYWxCcmVha3BvaW50c1wiOnRydWUsXCJzdXBwb3J0c0NvbmZpZ3VyYXRpb25Eb25lUmVxdWVzdFwiOnRydWUsXCJzdXBwb3J0c0Z1bmN0aW9uQnJlYWtwb2ludHNcIjpmYWxzZSxcInN1cHBvcnRzU2V0VmFyaWFibGVcIjp0cnVlfX0nKTtcclxuICAgICAgICB5aWVsZCBjaGFpXzEuZXhwZWN0KHJlc3BvbnNlRGV0ZWN0ZWQpLnRvLmV2ZW50dWFsbHkuZXF1YWwodHJ1ZSwgJ3Jlc3BvbnNlIG5vdCBwYXJzZWQnKTtcclxuICAgICAgICBzdHJlYW0ud3JpdGUoJ0NvbnRlbnQtTGVuZ3RoOiA2M1xcclxcblxcclxcbntcInR5cGVcIjogXCJldmVudFwiLCBcInNlcVwiOiAxLCBcImV2ZW50XCI6IFwiaW5pdGlhbGl6ZWRcIiwgXCJib2R5XCI6IHt9fScpO1xyXG4gICAgICAgIHlpZWxkIGNoYWlfMS5leHBlY3QoZXZlbnREZXRlY3RlZCkudG8uZXZlbnR1YWxseS5lcXVhbCh0cnVlLCAnZXZlbnQgbm90IHBhcnNlZCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QobWVzc2FnZXNEZXRlY3RlZCkudG8uYmUuZXF1YWwoMywgJ2luY29ycmVjdCBudW1iZXIgb2YgcHJvdG9jb2wgbWVzc2FnZXMnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0Vuc3VyZSBtZXNzYWdlcyBhcmUgbm90IHJlY2VpdmVkIGFmdGVyIGRpc3Bvc2luZyB0aGUgcGFyc2VyJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzdHJlYW1fMS5QYXNzVGhyb3VnaCgpO1xyXG4gICAgICAgIGNvbnN0IHByb3RvY29sUGFyc2VyID0gbmV3IHByb3RvY29sUGFyc2VyXzEuUHJvdG9jb2xQYXJzZXIoKTtcclxuICAgICAgICBwcm90b2NvbFBhcnNlci5jb25uZWN0KHN0cmVhbSk7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2VzRGV0ZWN0ZWQgPSAwO1xyXG4gICAgICAgIHByb3RvY29sUGFyc2VyLm9uKCdkYXRhJywgKCkgPT4gbWVzc2FnZXNEZXRlY3RlZCArPSAxKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0RGV0ZWN0ZWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgcHJvdG9jb2xQYXJzZXIub24oJ3JlcXVlc3RfaW5pdGlhbGl6ZScsICgpID0+IHJlc29sdmUodHJ1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbS53cml0ZSgnQ29udGVudC1MZW5ndGg6IDI4OVxcclxcblxcclxcbntcImNvbW1hbmRcIjpcImluaXRpYWxpemVcIixcImFyZ3VtZW50c1wiOntcImNsaWVudElEXCI6XCJ2c2NvZGVcIixcImFkYXB0ZXJJRFwiOlwicHl0aG9uRXhwZXJpbWVudFwiLFwicGF0aEZvcm1hdFwiOlwicGF0aFwiLFwibGluZXNTdGFydEF0MVwiOnRydWUsXCJjb2x1bW5zU3RhcnRBdDFcIjp0cnVlLFwic3VwcG9ydHNWYXJpYWJsZVR5cGVcIjp0cnVlLFwic3VwcG9ydHNWYXJpYWJsZVBhZ2luZ1wiOnRydWUsXCJzdXBwb3J0c1J1bkluVGVybWluYWxSZXF1ZXN0XCI6dHJ1ZSxcImxvY2FsZVwiOlwiZW4tdXNcIn0sXCJ0eXBlXCI6XCJyZXF1ZXN0XCIsXCJzZXFcIjoxfScpO1xyXG4gICAgICAgIHlpZWxkIGNoYWlfMS5leHBlY3QocmVxdWVzdERldGVjdGVkKS50by5ldmVudHVhbGx5LmVxdWFsKHRydWUsICdyZXF1ZXN0IG5vdCBwYXJzZWQnKTtcclxuICAgICAgICBwcm90b2NvbFBhcnNlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZXRlY3RlZCA9IGFzeW5jXzEuY3JlYXRlRGVmZXJyZWQoKTtcclxuICAgICAgICBwcm90b2NvbFBhcnNlci5vbigncmVzcG9uc2VfaW5pdGlhbGl6ZScsICgpID0+IHJlc3BvbnNlRGV0ZWN0ZWQucmVzb2x2ZSh0cnVlKSk7XHJcbiAgICAgICAgc3RyZWFtLndyaXRlKCdDb250ZW50LUxlbmd0aDogMjY1XFxyXFxuXFxyXFxue1wic2VxXCI6MSxcInR5cGVcIjpcInJlc3BvbnNlXCIsXCJyZXF1ZXN0X3NlcVwiOjEsXCJjb21tYW5kXCI6XCJpbml0aWFsaXplXCIsXCJzdWNjZXNzXCI6dHJ1ZSxcImJvZHlcIjp7XCJzdXBwb3J0c0V2YWx1YXRlRm9ySG92ZXJzXCI6ZmFsc2UsXCJzdXBwb3J0c0NvbmRpdGlvbmFsQnJlYWtwb2ludHNcIjp0cnVlLFwic3VwcG9ydHNDb25maWd1cmF0aW9uRG9uZVJlcXVlc3RcIjp0cnVlLFwic3VwcG9ydHNGdW5jdGlvbkJyZWFrcG9pbnRzXCI6ZmFsc2UsXCJzdXBwb3J0c1NldFZhcmlhYmxlXCI6dHJ1ZX19Jyk7XHJcbiAgICAgICAgLy8gV2FpdCBmb3IgbWVzc2FnZXMgdG8gZ28gdGhyb3VnaCBhbmQgZ2V0IHBhcnNlZCAodW5uZWNlbnNzYXJ5LCBidXQgYWRkIGZvciB0ZXN0aW5nIGVkZ2UgY2FzZXMpLlxyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLnNsZWVwKDEwMDApO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QocmVzcG9uc2VEZXRlY3RlZC5jb21wbGV0ZWQpLnRvLmJlLmVxdWFsKGZhbHNlLCAnUHJvbWlzZSBzaG91bGQgbm90IGhhdmUgcmVzb2x2ZWQnKTtcclxuICAgIH0pKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3RvY29scGFyc2VyLnRlc3QuanMubWFwIl19