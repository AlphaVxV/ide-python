"use strict"; // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const chai_1 = require("chai");

const chaiAsPromised = require("chai-as-promised");

const getFreePort = require("get-port");

const net = require("net");

const path = require("path");

const vscode_debugadapter_testsupport_1 = require("vscode-debugadapter-testsupport");

const misc_1 = require("../../client/common/utils/misc");

const constants_1 = require("../../client/debugger/constants");

const types_1 = require("../../client/debugger/types");

const common_1 = require("../common");

const initialize_1 = require("../initialize");

const constants_2 = require("./common/constants");

chai_1.use(chaiAsPromised);
const debugFilesPath = path.join(__dirname, '..', '..', '..', 'src', 'test', 'pythonFiles', 'debugging');
const EXPERIMENTAL_DEBUG_ADAPTER = path.join(__dirname, '..', '..', 'client', 'debugger', 'debugAdapter', 'main.js');
const testAdapterFilePath = EXPERIMENTAL_DEBUG_ADAPTER;
const debuggerType = constants_1.DebuggerTypeName; // tslint:disable-next-line:max-func-body-length

suite(`Standard Debugging of ports and hosts: ${debuggerType}`, () => {
  let debugClient;
  setup(function () {
    return __awaiter(this, void 0, void 0, function* () {
      if (!initialize_1.IS_MULTI_ROOT_TEST || !initialize_1.TEST_DEBUGGER) {
        // tslint:disable-next-line:no-invalid-this
        this.skip();
      }

      yield new Promise(resolve => setTimeout(resolve, 1000));
      debugClient = new vscode_debugadapter_testsupport_1.DebugClient('node', testAdapterFilePath, debuggerType);
      debugClient.defaultTimeout = constants_2.DEBUGGER_TIMEOUT;
      yield debugClient.start();
    });
  });
  teardown(() => __awaiter(void 0, void 0, void 0, function* () {
    // Wait for a second before starting another test (sometimes, sockets take a while to get closed).
    yield new Promise(resolve => setTimeout(resolve, 1000));

    try {
      debugClient.stop().catch(misc_1.noop); // tslint:disable-next-line:no-empty
    } catch (ex) {}
  }));

  function buildLaunchArgs(pythonFile, stopOnEntry = false, port, host, showReturnValue = false) {
    return {
      program: path.join(debugFilesPath, pythonFile),
      cwd: debugFilesPath,
      stopOnEntry,
      showReturnValue,
      logToFile: true,
      debugOptions: [types_1.DebugOptions.RedirectOutput],
      pythonPath: common_1.PYTHON_PATH,
      args: [],
      envFile: '',
      host,
      port,
      type: debuggerType,
      name: '',
      request: 'launch'
    };
  }

  function testDebuggingWithProvidedPort(port, host) {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.all([debugClient.configurationSequence(), debugClient.launch(buildLaunchArgs('startAndWait.py', false, port, host)), debugClient.waitForEvent('initialized')]); // Confirm port is in use (if one was provided).

      if (typeof port === 'number' && port > 0) {
        // We know the port 'debuggerPort' was free, now that the debugger has started confirm that this port is no longer free.
        const portBasedOnDebuggerPort = yield getFreePort({
          host: 'localhost',
          port
        });
        chai_1.expect(portBasedOnDebuggerPort).is.not.equal(port, 'Port assigned to debugger not used by the debugger');
      }
    });
  }

  test('Confirm debuggig works if both port and host are not provided', () => __awaiter(void 0, void 0, void 0, function* () {
    yield testDebuggingWithProvidedPort();
  }));
  test('Confirm debuggig works if port=0', () => __awaiter(void 0, void 0, void 0, function* () {
    yield testDebuggingWithProvidedPort(0, 'localhost');
  }));
  test('Confirm debuggig works if port=0 or host=localhost', () => __awaiter(void 0, void 0, void 0, function* () {
    yield testDebuggingWithProvidedPort(0, 'localhost');
  }));
  test('Confirm debuggig works if port=0 or host=127.0.0.1', () => __awaiter(void 0, void 0, void 0, function* () {
    yield testDebuggingWithProvidedPort(0, '127.0.0.1');
  }));
  test('Confirm debuggig fails when an invalid host is provided', () => __awaiter(void 0, void 0, void 0, function* () {
    const promise = testDebuggingWithProvidedPort(0, 'xyz123409924ple_ewf');
    let exception;

    try {
      yield promise;
    } catch (ex) {
      exception = ex;
    }

    chai_1.expect(exception.message).contains('ENOTFOUND', 'Debugging failed for some other reason');
  }));
  test('Confirm debuggig fails when provided port is in use', () => __awaiter(void 0, void 0, void 0, function* () {
    const server = net.createServer(misc_1.noop);
    const port = yield new Promise((resolve, reject) => server.listen({
      host: 'localhost',
      port: 0
    }, () => resolve(server.address().port)));
    let exception;

    try {
      yield testDebuggingWithProvidedPort(port);
    } catch (ex) {
      exception = ex;
    } finally {
      server.close();
    }

    chai_1.expect(exception.message).contains('EADDRINUSE', 'Debugging failed for some other reason');
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBvcnRBbmRIb3N0LnRlc3QuanMiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImNoYWlfMSIsInJlcXVpcmUiLCJjaGFpQXNQcm9taXNlZCIsImdldEZyZWVQb3J0IiwibmV0IiwicGF0aCIsInZzY29kZV9kZWJ1Z2FkYXB0ZXJfdGVzdHN1cHBvcnRfMSIsIm1pc2NfMSIsImNvbnN0YW50c18xIiwidHlwZXNfMSIsImNvbW1vbl8xIiwiaW5pdGlhbGl6ZV8xIiwiY29uc3RhbnRzXzIiLCJ1c2UiLCJkZWJ1Z0ZpbGVzUGF0aCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJFWFBFUklNRU5UQUxfREVCVUdfQURBUFRFUiIsInRlc3RBZGFwdGVyRmlsZVBhdGgiLCJkZWJ1Z2dlclR5cGUiLCJEZWJ1Z2dlclR5cGVOYW1lIiwic3VpdGUiLCJkZWJ1Z0NsaWVudCIsInNldHVwIiwiSVNfTVVMVElfUk9PVF9URVNUIiwiVEVTVF9ERUJVR0dFUiIsInNraXAiLCJzZXRUaW1lb3V0IiwiRGVidWdDbGllbnQiLCJkZWZhdWx0VGltZW91dCIsIkRFQlVHR0VSX1RJTUVPVVQiLCJzdGFydCIsInRlYXJkb3duIiwic3RvcCIsImNhdGNoIiwibm9vcCIsImV4IiwiYnVpbGRMYXVuY2hBcmdzIiwicHl0aG9uRmlsZSIsInN0b3BPbkVudHJ5IiwicG9ydCIsImhvc3QiLCJzaG93UmV0dXJuVmFsdWUiLCJwcm9ncmFtIiwiY3dkIiwibG9nVG9GaWxlIiwiZGVidWdPcHRpb25zIiwiRGVidWdPcHRpb25zIiwiUmVkaXJlY3RPdXRwdXQiLCJweXRob25QYXRoIiwiUFlUSE9OX1BBVEgiLCJhcmdzIiwiZW52RmlsZSIsInR5cGUiLCJuYW1lIiwicmVxdWVzdCIsInRlc3REZWJ1Z2dpbmdXaXRoUHJvdmlkZWRQb3J0IiwiYWxsIiwiY29uZmlndXJhdGlvblNlcXVlbmNlIiwibGF1bmNoIiwid2FpdEZvckV2ZW50IiwicG9ydEJhc2VkT25EZWJ1Z2dlclBvcnQiLCJleHBlY3QiLCJpcyIsIm5vdCIsImVxdWFsIiwidGVzdCIsInByb21pc2UiLCJleGNlcHRpb24iLCJtZXNzYWdlIiwiY29udGFpbnMiLCJzZXJ2ZXIiLCJjcmVhdGVTZXJ2ZXIiLCJsaXN0ZW4iLCJhZGRyZXNzIiwiY2xvc2UiXSwibWFwcGluZ3MiOiJBQUFBLGEsQ0FDQTtBQUNBOztBQUNBLElBQUlBLFNBQVMsR0FBSSxVQUFRLFNBQUtBLFNBQWQsSUFBNEIsVUFBVUMsT0FBVixFQUFtQkMsVUFBbkIsRUFBK0JDLENBQS9CLEVBQWtDQyxTQUFsQyxFQUE2QztBQUNyRixTQUFPLEtBQUtELENBQUMsS0FBS0EsQ0FBQyxHQUFHRSxPQUFULENBQU4sRUFBeUIsVUFBVUMsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7QUFDdkQsYUFBU0MsU0FBVCxDQUFtQkMsS0FBbkIsRUFBMEI7QUFBRSxVQUFJO0FBQUVDLFFBQUFBLElBQUksQ0FBQ04sU0FBUyxDQUFDTyxJQUFWLENBQWVGLEtBQWYsQ0FBRCxDQUFKO0FBQThCLE9BQXBDLENBQXFDLE9BQU9HLENBQVAsRUFBVTtBQUFFTCxRQUFBQSxNQUFNLENBQUNLLENBQUQsQ0FBTjtBQUFZO0FBQUU7O0FBQzNGLGFBQVNDLFFBQVQsQ0FBa0JKLEtBQWxCLEVBQXlCO0FBQUUsVUFBSTtBQUFFQyxRQUFBQSxJQUFJLENBQUNOLFNBQVMsQ0FBQyxPQUFELENBQVQsQ0FBbUJLLEtBQW5CLENBQUQsQ0FBSjtBQUFrQyxPQUF4QyxDQUF5QyxPQUFPRyxDQUFQLEVBQVU7QUFBRUwsUUFBQUEsTUFBTSxDQUFDSyxDQUFELENBQU47QUFBWTtBQUFFOztBQUM5RixhQUFTRixJQUFULENBQWNJLE1BQWQsRUFBc0I7QUFBRUEsTUFBQUEsTUFBTSxDQUFDQyxJQUFQLEdBQWNULE9BQU8sQ0FBQ1EsTUFBTSxDQUFDTCxLQUFSLENBQXJCLEdBQXNDLElBQUlOLENBQUosQ0FBTSxVQUFVRyxPQUFWLEVBQW1CO0FBQUVBLFFBQUFBLE9BQU8sQ0FBQ1EsTUFBTSxDQUFDTCxLQUFSLENBQVA7QUFBd0IsT0FBbkQsRUFBcURPLElBQXJELENBQTBEUixTQUExRCxFQUFxRUssUUFBckUsQ0FBdEM7QUFBdUg7O0FBQy9JSCxJQUFBQSxJQUFJLENBQUMsQ0FBQ04sU0FBUyxHQUFHQSxTQUFTLENBQUNhLEtBQVYsQ0FBZ0JoQixPQUFoQixFQUF5QkMsVUFBVSxJQUFJLEVBQXZDLENBQWIsRUFBeURTLElBQXpELEVBQUQsQ0FBSjtBQUNILEdBTE0sQ0FBUDtBQU1ILENBUEQ7O0FBUUFPLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRVgsRUFBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsTUFBTVksTUFBTSxHQUFHQyxPQUFPLENBQUMsTUFBRCxDQUF0Qjs7QUFDQSxNQUFNQyxjQUFjLEdBQUdELE9BQU8sQ0FBQyxrQkFBRCxDQUE5Qjs7QUFDQSxNQUFNRSxXQUFXLEdBQUdGLE9BQU8sQ0FBQyxVQUFELENBQTNCOztBQUNBLE1BQU1HLEdBQUcsR0FBR0gsT0FBTyxDQUFDLEtBQUQsQ0FBbkI7O0FBQ0EsTUFBTUksSUFBSSxHQUFHSixPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxNQUFNSyxpQ0FBaUMsR0FBR0wsT0FBTyxDQUFDLGlDQUFELENBQWpEOztBQUNBLE1BQU1NLE1BQU0sR0FBR04sT0FBTyxDQUFDLGdDQUFELENBQXRCOztBQUNBLE1BQU1PLFdBQVcsR0FBR1AsT0FBTyxDQUFDLGlDQUFELENBQTNCOztBQUNBLE1BQU1RLE9BQU8sR0FBR1IsT0FBTyxDQUFDLDZCQUFELENBQXZCOztBQUNBLE1BQU1TLFFBQVEsR0FBR1QsT0FBTyxDQUFDLFdBQUQsQ0FBeEI7O0FBQ0EsTUFBTVUsWUFBWSxHQUFHVixPQUFPLENBQUMsZUFBRCxDQUE1Qjs7QUFDQSxNQUFNVyxXQUFXLEdBQUdYLE9BQU8sQ0FBQyxvQkFBRCxDQUEzQjs7QUFDQUQsTUFBTSxDQUFDYSxHQUFQLENBQVdYLGNBQVg7QUFDQSxNQUFNWSxjQUFjLEdBQUdULElBQUksQ0FBQ1UsSUFBTCxDQUFVQyxTQUFWLEVBQXFCLElBQXJCLEVBQTJCLElBQTNCLEVBQWlDLElBQWpDLEVBQXVDLEtBQXZDLEVBQThDLE1BQTlDLEVBQXNELGFBQXRELEVBQXFFLFdBQXJFLENBQXZCO0FBQ0EsTUFBTUMsMEJBQTBCLEdBQUdaLElBQUksQ0FBQ1UsSUFBTCxDQUFVQyxTQUFWLEVBQXFCLElBQXJCLEVBQTJCLElBQTNCLEVBQWlDLFFBQWpDLEVBQTJDLFVBQTNDLEVBQXVELGNBQXZELEVBQXVFLFNBQXZFLENBQW5DO0FBQ0EsTUFBTUUsbUJBQW1CLEdBQUdELDBCQUE1QjtBQUNBLE1BQU1FLFlBQVksR0FBR1gsV0FBVyxDQUFDWSxnQkFBakMsQyxDQUNBOztBQUNBQyxLQUFLLENBQUUsMENBQXlDRixZQUFhLEVBQXhELEVBQTJELE1BQU07QUFDbEUsTUFBSUcsV0FBSjtBQUNBQyxFQUFBQSxLQUFLLENBQUMsWUFBWTtBQUNkLFdBQU81QyxTQUFTLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsYUFBYTtBQUNoRCxVQUFJLENBQUNnQyxZQUFZLENBQUNhLGtCQUFkLElBQW9DLENBQUNiLFlBQVksQ0FBQ2MsYUFBdEQsRUFBcUU7QUFDakU7QUFDQSxhQUFLQyxJQUFMO0FBQ0g7O0FBQ0QsWUFBTSxJQUFJMUMsT0FBSixDQUFZQyxPQUFPLElBQUkwQyxVQUFVLENBQUMxQyxPQUFELEVBQVUsSUFBVixDQUFqQyxDQUFOO0FBQ0FxQyxNQUFBQSxXQUFXLEdBQUcsSUFBSWhCLGlDQUFpQyxDQUFDc0IsV0FBdEMsQ0FBa0QsTUFBbEQsRUFBMERWLG1CQUExRCxFQUErRUMsWUFBL0UsQ0FBZDtBQUNBRyxNQUFBQSxXQUFXLENBQUNPLGNBQVosR0FBNkJqQixXQUFXLENBQUNrQixnQkFBekM7QUFDQSxZQUFNUixXQUFXLENBQUNTLEtBQVosRUFBTjtBQUNILEtBVGUsQ0FBaEI7QUFVSCxHQVhJLENBQUw7QUFZQUMsRUFBQUEsUUFBUSxDQUFDLE1BQU1yRCxTQUFTLFNBQU8sS0FBSyxDQUFaLEVBQWUsS0FBSyxDQUFwQixFQUF1QixhQUFhO0FBQ3hEO0FBQ0EsVUFBTSxJQUFJSyxPQUFKLENBQVlDLE9BQU8sSUFBSTBDLFVBQVUsQ0FBQzFDLE9BQUQsRUFBVSxJQUFWLENBQWpDLENBQU47O0FBQ0EsUUFBSTtBQUNBcUMsTUFBQUEsV0FBVyxDQUFDVyxJQUFaLEdBQW1CQyxLQUFuQixDQUF5QjNCLE1BQU0sQ0FBQzRCLElBQWhDLEVBREEsQ0FFQTtBQUNILEtBSEQsQ0FJQSxPQUFPQyxFQUFQLEVBQVcsQ0FBRztBQUNqQixHQVJ1QixDQUFoQixDQUFSOztBQVNBLFdBQVNDLGVBQVQsQ0FBeUJDLFVBQXpCLEVBQXFDQyxXQUFXLEdBQUcsS0FBbkQsRUFBMERDLElBQTFELEVBQWdFQyxJQUFoRSxFQUFzRUMsZUFBZSxHQUFHLEtBQXhGLEVBQStGO0FBQzNGLFdBQU87QUFDSEMsTUFBQUEsT0FBTyxFQUFFdEMsSUFBSSxDQUFDVSxJQUFMLENBQVVELGNBQVYsRUFBMEJ3QixVQUExQixDQUROO0FBRUhNLE1BQUFBLEdBQUcsRUFBRTlCLGNBRkY7QUFHSHlCLE1BQUFBLFdBSEc7QUFJSEcsTUFBQUEsZUFKRztBQUtIRyxNQUFBQSxTQUFTLEVBQUUsSUFMUjtBQU1IQyxNQUFBQSxZQUFZLEVBQUUsQ0FBQ3JDLE9BQU8sQ0FBQ3NDLFlBQVIsQ0FBcUJDLGNBQXRCLENBTlg7QUFPSEMsTUFBQUEsVUFBVSxFQUFFdkMsUUFBUSxDQUFDd0MsV0FQbEI7QUFRSEMsTUFBQUEsSUFBSSxFQUFFLEVBUkg7QUFTSEMsTUFBQUEsT0FBTyxFQUFFLEVBVE47QUFVSFgsTUFBQUEsSUFWRztBQVVHRCxNQUFBQSxJQVZIO0FBV0hhLE1BQUFBLElBQUksRUFBRWxDLFlBWEg7QUFZSG1DLE1BQUFBLElBQUksRUFBRSxFQVpIO0FBYUhDLE1BQUFBLE9BQU8sRUFBRTtBQWJOLEtBQVA7QUFlSDs7QUFDRCxXQUFTQyw2QkFBVCxDQUF1Q2hCLElBQXZDLEVBQTZDQyxJQUE3QyxFQUFtRDtBQUMvQyxXQUFPOUQsU0FBUyxDQUFDLElBQUQsRUFBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDaEQsWUFBTUssT0FBTyxDQUFDeUUsR0FBUixDQUFZLENBQ2RuQyxXQUFXLENBQUNvQyxxQkFBWixFQURjLEVBRWRwQyxXQUFXLENBQUNxQyxNQUFaLENBQW1CdEIsZUFBZSxDQUFDLGlCQUFELEVBQW9CLEtBQXBCLEVBQTJCRyxJQUEzQixFQUFpQ0MsSUFBakMsQ0FBbEMsQ0FGYyxFQUdkbkIsV0FBVyxDQUFDc0MsWUFBWixDQUF5QixhQUF6QixDQUhjLENBQVosQ0FBTixDQURnRCxDQU1oRDs7QUFDQSxVQUFJLE9BQU9wQixJQUFQLEtBQWdCLFFBQWhCLElBQTRCQSxJQUFJLEdBQUcsQ0FBdkMsRUFBMEM7QUFDdEM7QUFDQSxjQUFNcUIsdUJBQXVCLEdBQUcsTUFBTTFELFdBQVcsQ0FBQztBQUFFc0MsVUFBQUEsSUFBSSxFQUFFLFdBQVI7QUFBcUJELFVBQUFBO0FBQXJCLFNBQUQsQ0FBakQ7QUFDQXhDLFFBQUFBLE1BQU0sQ0FBQzhELE1BQVAsQ0FBY0QsdUJBQWQsRUFBdUNFLEVBQXZDLENBQTBDQyxHQUExQyxDQUE4Q0MsS0FBOUMsQ0FBb0R6QixJQUFwRCxFQUEwRCxvREFBMUQ7QUFDSDtBQUNKLEtBWmUsQ0FBaEI7QUFhSDs7QUFDRDBCLEVBQUFBLElBQUksQ0FBQywrREFBRCxFQUFrRSxNQUFNdkYsU0FBUyxTQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsYUFBYTtBQUNySCxVQUFNNkUsNkJBQTZCLEVBQW5DO0FBQ0gsR0FGb0YsQ0FBakYsQ0FBSjtBQUdBVSxFQUFBQSxJQUFJLENBQUMsa0NBQUQsRUFBcUMsTUFBTXZGLFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDeEYsVUFBTTZFLDZCQUE2QixDQUFDLENBQUQsRUFBSSxXQUFKLENBQW5DO0FBQ0gsR0FGdUQsQ0FBcEQsQ0FBSjtBQUdBVSxFQUFBQSxJQUFJLENBQUMsb0RBQUQsRUFBdUQsTUFBTXZGLFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDMUcsVUFBTTZFLDZCQUE2QixDQUFDLENBQUQsRUFBSSxXQUFKLENBQW5DO0FBQ0gsR0FGeUUsQ0FBdEUsQ0FBSjtBQUdBVSxFQUFBQSxJQUFJLENBQUMsb0RBQUQsRUFBdUQsTUFBTXZGLFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDMUcsVUFBTTZFLDZCQUE2QixDQUFDLENBQUQsRUFBSSxXQUFKLENBQW5DO0FBQ0gsR0FGeUUsQ0FBdEUsQ0FBSjtBQUdBVSxFQUFBQSxJQUFJLENBQUMseURBQUQsRUFBNEQsTUFBTXZGLFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDL0csVUFBTXdGLE9BQU8sR0FBR1gsNkJBQTZCLENBQUMsQ0FBRCxFQUFJLHFCQUFKLENBQTdDO0FBQ0EsUUFBSVksU0FBSjs7QUFDQSxRQUFJO0FBQ0EsWUFBTUQsT0FBTjtBQUNILEtBRkQsQ0FHQSxPQUFPL0IsRUFBUCxFQUFXO0FBQ1BnQyxNQUFBQSxTQUFTLEdBQUdoQyxFQUFaO0FBQ0g7O0FBQ0RwQyxJQUFBQSxNQUFNLENBQUM4RCxNQUFQLENBQWNNLFNBQVMsQ0FBQ0MsT0FBeEIsRUFBaUNDLFFBQWpDLENBQTBDLFdBQTFDLEVBQXVELHdDQUF2RDtBQUNILEdBVjhFLENBQTNFLENBQUo7QUFXQUosRUFBQUEsSUFBSSxDQUFDLHFEQUFELEVBQXdELE1BQU12RixTQUFTLFNBQU8sS0FBSyxDQUFaLEVBQWUsS0FBSyxDQUFwQixFQUF1QixhQUFhO0FBQzNHLFVBQU00RixNQUFNLEdBQUduRSxHQUFHLENBQUNvRSxZQUFKLENBQWlCakUsTUFBTSxDQUFDNEIsSUFBeEIsQ0FBZjtBQUNBLFVBQU1LLElBQUksR0FBRyxNQUFNLElBQUl4RCxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCcUYsTUFBTSxDQUFDRSxNQUFQLENBQWM7QUFBRWhDLE1BQUFBLElBQUksRUFBRSxXQUFSO0FBQXFCRCxNQUFBQSxJQUFJLEVBQUU7QUFBM0IsS0FBZCxFQUE4QyxNQUFNdkQsT0FBTyxDQUFDc0YsTUFBTSxDQUFDRyxPQUFQLEdBQWlCbEMsSUFBbEIsQ0FBM0QsQ0FBakMsQ0FBbkI7QUFDQSxRQUFJNEIsU0FBSjs7QUFDQSxRQUFJO0FBQ0EsWUFBTVosNkJBQTZCLENBQUNoQixJQUFELENBQW5DO0FBQ0gsS0FGRCxDQUdBLE9BQU9KLEVBQVAsRUFBVztBQUNQZ0MsTUFBQUEsU0FBUyxHQUFHaEMsRUFBWjtBQUNILEtBTEQsU0FNUTtBQUNKbUMsTUFBQUEsTUFBTSxDQUFDSSxLQUFQO0FBQ0g7O0FBQ0QzRSxJQUFBQSxNQUFNLENBQUM4RCxNQUFQLENBQWNNLFNBQVMsQ0FBQ0MsT0FBeEIsRUFBaUNDLFFBQWpDLENBQTBDLFlBQTFDLEVBQXdELHdDQUF4RDtBQUNILEdBZDBFLENBQXZFLENBQUo7QUFlSCxDQTdGSSxDQUFMIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY2hhaV8xID0gcmVxdWlyZShcImNoYWlcIik7XHJcbmNvbnN0IGNoYWlBc1Byb21pc2VkID0gcmVxdWlyZShcImNoYWktYXMtcHJvbWlzZWRcIik7XHJcbmNvbnN0IGdldEZyZWVQb3J0ID0gcmVxdWlyZShcImdldC1wb3J0XCIpO1xyXG5jb25zdCBuZXQgPSByZXF1aXJlKFwibmV0XCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IHZzY29kZV9kZWJ1Z2FkYXB0ZXJfdGVzdHN1cHBvcnRfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtZGVidWdhZGFwdGVyLXRlc3RzdXBwb3J0XCIpO1xyXG5jb25zdCBtaXNjXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbW1vbi91dGlscy9taXNjXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnQvZGVidWdnZXIvY29uc3RhbnRzXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9kZWJ1Z2dlci90eXBlc1wiKTtcclxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xyXG5jb25zdCBpbml0aWFsaXplXzEgPSByZXF1aXJlKFwiLi4vaW5pdGlhbGl6ZVwiKTtcclxuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb21tb24vY29uc3RhbnRzXCIpO1xyXG5jaGFpXzEudXNlKGNoYWlBc1Byb21pc2VkKTtcclxuY29uc3QgZGVidWdGaWxlc1BhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAnc3JjJywgJ3Rlc3QnLCAncHl0aG9uRmlsZXMnLCAnZGVidWdnaW5nJyk7XHJcbmNvbnN0IEVYUEVSSU1FTlRBTF9ERUJVR19BREFQVEVSID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJ2NsaWVudCcsICdkZWJ1Z2dlcicsICdkZWJ1Z0FkYXB0ZXInLCAnbWFpbi5qcycpO1xyXG5jb25zdCB0ZXN0QWRhcHRlckZpbGVQYXRoID0gRVhQRVJJTUVOVEFMX0RFQlVHX0FEQVBURVI7XHJcbmNvbnN0IGRlYnVnZ2VyVHlwZSA9IGNvbnN0YW50c18xLkRlYnVnZ2VyVHlwZU5hbWU7XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtZnVuYy1ib2R5LWxlbmd0aFxyXG5zdWl0ZShgU3RhbmRhcmQgRGVidWdnaW5nIG9mIHBvcnRzIGFuZCBob3N0czogJHtkZWJ1Z2dlclR5cGV9YCwgKCkgPT4ge1xyXG4gICAgbGV0IGRlYnVnQ2xpZW50O1xyXG4gICAgc2V0dXAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5pdGlhbGl6ZV8xLklTX01VTFRJX1JPT1RfVEVTVCB8fCAhaW5pdGlhbGl6ZV8xLlRFU1RfREVCVUdHRVIpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRoaXNcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XHJcbiAgICAgICAgICAgIGRlYnVnQ2xpZW50ID0gbmV3IHZzY29kZV9kZWJ1Z2FkYXB0ZXJfdGVzdHN1cHBvcnRfMS5EZWJ1Z0NsaWVudCgnbm9kZScsIHRlc3RBZGFwdGVyRmlsZVBhdGgsIGRlYnVnZ2VyVHlwZSk7XHJcbiAgICAgICAgICAgIGRlYnVnQ2xpZW50LmRlZmF1bHRUaW1lb3V0ID0gY29uc3RhbnRzXzIuREVCVUdHRVJfVElNRU9VVDtcclxuICAgICAgICAgICAgeWllbGQgZGVidWdDbGllbnQuc3RhcnQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgdGVhcmRvd24oKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIFdhaXQgZm9yIGEgc2Vjb25kIGJlZm9yZSBzdGFydGluZyBhbm90aGVyIHRlc3QgKHNvbWV0aW1lcywgc29ja2V0cyB0YWtlIGEgd2hpbGUgdG8gZ2V0IGNsb3NlZCkuXHJcbiAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkZWJ1Z0NsaWVudC5zdG9wKCkuY2F0Y2gobWlzY18xLm5vb3ApO1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGV4KSB7IH1cclxuICAgIH0pKTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkTGF1bmNoQXJncyhweXRob25GaWxlLCBzdG9wT25FbnRyeSA9IGZhbHNlLCBwb3J0LCBob3N0LCBzaG93UmV0dXJuVmFsdWUgPSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByb2dyYW06IHBhdGguam9pbihkZWJ1Z0ZpbGVzUGF0aCwgcHl0aG9uRmlsZSksXHJcbiAgICAgICAgICAgIGN3ZDogZGVidWdGaWxlc1BhdGgsXHJcbiAgICAgICAgICAgIHN0b3BPbkVudHJ5LFxyXG4gICAgICAgICAgICBzaG93UmV0dXJuVmFsdWUsXHJcbiAgICAgICAgICAgIGxvZ1RvRmlsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZGVidWdPcHRpb25zOiBbdHlwZXNfMS5EZWJ1Z09wdGlvbnMuUmVkaXJlY3RPdXRwdXRdLFxyXG4gICAgICAgICAgICBweXRob25QYXRoOiBjb21tb25fMS5QWVRIT05fUEFUSCxcclxuICAgICAgICAgICAgYXJnczogW10sXHJcbiAgICAgICAgICAgIGVudkZpbGU6ICcnLFxyXG4gICAgICAgICAgICBob3N0LCBwb3J0LFxyXG4gICAgICAgICAgICB0eXBlOiBkZWJ1Z2dlclR5cGUsXHJcbiAgICAgICAgICAgIG5hbWU6ICcnLFxyXG4gICAgICAgICAgICByZXF1ZXN0OiAnbGF1bmNoJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0ZXN0RGVidWdnaW5nV2l0aFByb3ZpZGVkUG9ydChwb3J0LCBob3N0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgZGVidWdDbGllbnQuY29uZmlndXJhdGlvblNlcXVlbmNlKCksXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0NsaWVudC5sYXVuY2goYnVpbGRMYXVuY2hBcmdzKCdzdGFydEFuZFdhaXQucHknLCBmYWxzZSwgcG9ydCwgaG9zdCkpLFxyXG4gICAgICAgICAgICAgICAgZGVidWdDbGllbnQud2FpdEZvckV2ZW50KCdpbml0aWFsaXplZCcpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAvLyBDb25maXJtIHBvcnQgaXMgaW4gdXNlIChpZiBvbmUgd2FzIHByb3ZpZGVkKS5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3J0ID09PSAnbnVtYmVyJyAmJiBwb3J0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgcG9ydCAnZGVidWdnZXJQb3J0JyB3YXMgZnJlZSwgbm93IHRoYXQgdGhlIGRlYnVnZ2VyIGhhcyBzdGFydGVkIGNvbmZpcm0gdGhhdCB0aGlzIHBvcnQgaXMgbm8gbG9uZ2VyIGZyZWUuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0QmFzZWRPbkRlYnVnZ2VyUG9ydCA9IHlpZWxkIGdldEZyZWVQb3J0KHsgaG9zdDogJ2xvY2FsaG9zdCcsIHBvcnQgfSk7XHJcbiAgICAgICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHBvcnRCYXNlZE9uRGVidWdnZXJQb3J0KS5pcy5ub3QuZXF1YWwocG9ydCwgJ1BvcnQgYXNzaWduZWQgdG8gZGVidWdnZXIgbm90IHVzZWQgYnkgdGhlIGRlYnVnZ2VyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRlc3QoJ0NvbmZpcm0gZGVidWdnaWcgd29ya3MgaWYgYm90aCBwb3J0IGFuZCBob3N0IGFyZSBub3QgcHJvdmlkZWQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgdGVzdERlYnVnZ2luZ1dpdGhQcm92aWRlZFBvcnQoKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0NvbmZpcm0gZGVidWdnaWcgd29ya3MgaWYgcG9ydD0wJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIHRlc3REZWJ1Z2dpbmdXaXRoUHJvdmlkZWRQb3J0KDAsICdsb2NhbGhvc3QnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0NvbmZpcm0gZGVidWdnaWcgd29ya3MgaWYgcG9ydD0wIG9yIGhvc3Q9bG9jYWxob3N0JywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIHRlc3REZWJ1Z2dpbmdXaXRoUHJvdmlkZWRQb3J0KDAsICdsb2NhbGhvc3QnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0NvbmZpcm0gZGVidWdnaWcgd29ya3MgaWYgcG9ydD0wIG9yIGhvc3Q9MTI3LjAuMC4xJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIHRlc3REZWJ1Z2dpbmdXaXRoUHJvdmlkZWRQb3J0KDAsICcxMjcuMC4wLjEnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0NvbmZpcm0gZGVidWdnaWcgZmFpbHMgd2hlbiBhbiBpbnZhbGlkIGhvc3QgaXMgcHJvdmlkZWQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRlc3REZWJ1Z2dpbmdXaXRoUHJvdmlkZWRQb3J0KDAsICd4eXoxMjM0MDk5MjRwbGVfZXdmJyk7XHJcbiAgICAgICAgbGV0IGV4Y2VwdGlvbjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB5aWVsZCBwcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uID0gZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYWlfMS5leHBlY3QoZXhjZXB0aW9uLm1lc3NhZ2UpLmNvbnRhaW5zKCdFTk9URk9VTkQnLCAnRGVidWdnaW5nIGZhaWxlZCBmb3Igc29tZSBvdGhlciByZWFzb24nKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0NvbmZpcm0gZGVidWdnaWcgZmFpbHMgd2hlbiBwcm92aWRlZCBwb3J0IGlzIGluIHVzZScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBzZXJ2ZXIgPSBuZXQuY3JlYXRlU2VydmVyKG1pc2NfMS5ub29wKTtcclxuICAgICAgICBjb25zdCBwb3J0ID0geWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gc2VydmVyLmxpc3Rlbih7IGhvc3Q6ICdsb2NhbGhvc3QnLCBwb3J0OiAwIH0sICgpID0+IHJlc29sdmUoc2VydmVyLmFkZHJlc3MoKS5wb3J0KSkpO1xyXG4gICAgICAgIGxldCBleGNlcHRpb247XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgeWllbGQgdGVzdERlYnVnZ2luZ1dpdGhQcm92aWRlZFBvcnQocG9ydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICBleGNlcHRpb24gPSBleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHNlcnZlci5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFpXzEuZXhwZWN0KGV4Y2VwdGlvbi5tZXNzYWdlKS5jb250YWlucygnRUFERFJJTlVTRScsICdEZWJ1Z2dpbmcgZmFpbGVkIGZvciBzb21lIG90aGVyIHJlYXNvbicpO1xyXG4gICAgfSkpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9ydEFuZEhvc3QudGVzdC5qcy5tYXAiXX0=