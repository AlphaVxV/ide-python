// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const assert = require("assert");

const TypeMoq = require("typemoq");

const dispatcher_1 = require("../../client/typeFormatters/dispatcher");

suite('Formatting - Dispatcher', () => {
  const doc = TypeMoq.Mock.ofType();
  const pos = TypeMoq.Mock.ofType();
  const opt = TypeMoq.Mock.ofType();
  const token = TypeMoq.Mock.ofType();
  const edits = TypeMoq.Mock.ofType();
  test('No providers', () => __awaiter(void 0, void 0, void 0, function* () {
    const dispatcher = new dispatcher_1.OnTypeFormattingDispatcher({});
    const triggers = dispatcher.getTriggerCharacters();
    assert.equal(triggers, undefined, 'Trigger was not undefined');
    const result = yield dispatcher.provideOnTypeFormattingEdits(doc.object, pos.object, '\n', opt.object, token.object);
    assert.deepStrictEqual(result, [], 'Did not return an empty list of edits');
  }));
  test('Single provider', () => {
    const provider = setupProvider(doc.object, pos.object, ':', opt.object, token.object, edits.object);
    const dispatcher = new dispatcher_1.OnTypeFormattingDispatcher({
      ':': provider.object
    });
    const triggers = dispatcher.getTriggerCharacters();
    assert.deepStrictEqual(triggers, {
      first: ':',
      more: []
    }, 'Did not return correct triggers');
    const result = dispatcher.provideOnTypeFormattingEdits(doc.object, pos.object, ':', opt.object, token.object);
    assert.equal(result, edits.object, 'Did not return correct edits');
    provider.verifyAll();
  });
  test('Two providers', () => {
    const colonProvider = setupProvider(doc.object, pos.object, ':', opt.object, token.object, edits.object);
    const doc2 = TypeMoq.Mock.ofType();
    const pos2 = TypeMoq.Mock.ofType();
    const opt2 = TypeMoq.Mock.ofType();
    const token2 = TypeMoq.Mock.ofType();
    const edits2 = TypeMoq.Mock.ofType();
    const newlineProvider = setupProvider(doc2.object, pos2.object, '\n', opt2.object, token2.object, edits2.object);
    const dispatcher = new dispatcher_1.OnTypeFormattingDispatcher({
      ':': colonProvider.object,
      '\n': newlineProvider.object
    });
    const triggers = dispatcher.getTriggerCharacters();
    assert.deepStrictEqual(triggers, {
      first: '\n',
      more: [':']
    }, 'Did not return correct triggers');
    const result = dispatcher.provideOnTypeFormattingEdits(doc.object, pos.object, ':', opt.object, token.object);
    assert.equal(result, edits.object, 'Did not return correct editsfor colon provider');
    const result2 = dispatcher.provideOnTypeFormattingEdits(doc2.object, pos2.object, '\n', opt2.object, token2.object);
    assert.equal(result2, edits2.object, 'Did not return correct edits for newline provider');
    colonProvider.verifyAll();
    newlineProvider.verifyAll();
  });

  function setupProvider(document, position, ch, options, cancellationToken, result) {
    const provider = TypeMoq.Mock.ofType();
    provider.setup(p => p.provideOnTypeFormattingEdits(document, position, ch, options, cancellationToken)).returns(() => result).verifiable(TypeMoq.Times.once());
    return provider;
  }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV4dGVuc2lvbi5kaXNwYXRjaC50ZXN0LmpzIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJhc3NlcnQiLCJyZXF1aXJlIiwiVHlwZU1vcSIsImRpc3BhdGNoZXJfMSIsInN1aXRlIiwiZG9jIiwiTW9jayIsIm9mVHlwZSIsInBvcyIsIm9wdCIsInRva2VuIiwiZWRpdHMiLCJ0ZXN0IiwiZGlzcGF0Y2hlciIsIk9uVHlwZUZvcm1hdHRpbmdEaXNwYXRjaGVyIiwidHJpZ2dlcnMiLCJnZXRUcmlnZ2VyQ2hhcmFjdGVycyIsImVxdWFsIiwidW5kZWZpbmVkIiwicHJvdmlkZU9uVHlwZUZvcm1hdHRpbmdFZGl0cyIsIm9iamVjdCIsImRlZXBTdHJpY3RFcXVhbCIsInByb3ZpZGVyIiwic2V0dXBQcm92aWRlciIsImZpcnN0IiwibW9yZSIsInZlcmlmeUFsbCIsImNvbG9uUHJvdmlkZXIiLCJkb2MyIiwicG9zMiIsIm9wdDIiLCJ0b2tlbjIiLCJlZGl0czIiLCJuZXdsaW5lUHJvdmlkZXIiLCJyZXN1bHQyIiwiZG9jdW1lbnQiLCJwb3NpdGlvbiIsImNoIiwib3B0aW9ucyIsImNhbmNlbGxhdGlvblRva2VuIiwic2V0dXAiLCJwIiwicmV0dXJucyIsInZlcmlmaWFibGUiLCJUaW1lcyIsIm9uY2UiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQSxTQUFTLEdBQUksVUFBUSxTQUFLQSxTQUFkLElBQTRCLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxDQUEvQixFQUFrQ0MsU0FBbEMsRUFBNkM7QUFDckYs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QU92QixRQUFQO0FBQ0g7QUFDSixDQXBESSxDQUFMIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbmNvbnN0IFR5cGVNb3EgPSByZXF1aXJlKFwidHlwZW1vcVwiKTtcclxuY29uc3QgZGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC90eXBlRm9ybWF0dGVycy9kaXNwYXRjaGVyXCIpO1xyXG5zdWl0ZSgnRm9ybWF0dGluZyAtIERpc3BhdGNoZXInLCAoKSA9PiB7XHJcbiAgICBjb25zdCBkb2MgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICBjb25zdCBwb3MgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICBjb25zdCBvcHQgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICBjb25zdCB0b2tlbiA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgIGNvbnN0IGVkaXRzID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgdGVzdCgnTm8gcHJvdmlkZXJzJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSBuZXcgZGlzcGF0Y2hlcl8xLk9uVHlwZUZvcm1hdHRpbmdEaXNwYXRjaGVyKHt9KTtcclxuICAgICAgICBjb25zdCB0cmlnZ2VycyA9IGRpc3BhdGNoZXIuZ2V0VHJpZ2dlckNoYXJhY3RlcnMoKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodHJpZ2dlcnMsIHVuZGVmaW5lZCwgJ1RyaWdnZXIgd2FzIG5vdCB1bmRlZmluZWQnKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBkaXNwYXRjaGVyLnByb3ZpZGVPblR5cGVGb3JtYXR0aW5nRWRpdHMoZG9jLm9iamVjdCwgcG9zLm9iamVjdCwgJ1xcbicsIG9wdC5vYmplY3QsIHRva2VuLm9iamVjdCk7XHJcbiAgICAgICAgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFtdLCAnRGlkIG5vdCByZXR1cm4gYW4gZW1wdHkgbGlzdCBvZiBlZGl0cycpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnU2luZ2xlIHByb3ZpZGVyJywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gc2V0dXBQcm92aWRlcihkb2Mub2JqZWN0LCBwb3Mub2JqZWN0LCAnOicsIG9wdC5vYmplY3QsIHRva2VuLm9iamVjdCwgZWRpdHMub2JqZWN0KTtcclxuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gbmV3IGRpc3BhdGNoZXJfMS5PblR5cGVGb3JtYXR0aW5nRGlzcGF0Y2hlcih7XHJcbiAgICAgICAgICAgICc6JzogcHJvdmlkZXIub2JqZWN0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgdHJpZ2dlcnMgPSBkaXNwYXRjaGVyLmdldFRyaWdnZXJDaGFyYWN0ZXJzKCk7XHJcbiAgICAgICAgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh0cmlnZ2VycywgeyBmaXJzdDogJzonLCBtb3JlOiBbXSB9LCAnRGlkIG5vdCByZXR1cm4gY29ycmVjdCB0cmlnZ2VycycpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRpc3BhdGNoZXIucHJvdmlkZU9uVHlwZUZvcm1hdHRpbmdFZGl0cyhkb2Mub2JqZWN0LCBwb3Mub2JqZWN0LCAnOicsIG9wdC5vYmplY3QsIHRva2VuLm9iamVjdCk7XHJcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdCwgZWRpdHMub2JqZWN0LCAnRGlkIG5vdCByZXR1cm4gY29ycmVjdCBlZGl0cycpO1xyXG4gICAgICAgIHByb3ZpZGVyLnZlcmlmeUFsbCgpO1xyXG4gICAgfSk7XHJcbiAgICB0ZXN0KCdUd28gcHJvdmlkZXJzJywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbG9uUHJvdmlkZXIgPSBzZXR1cFByb3ZpZGVyKGRvYy5vYmplY3QsIHBvcy5vYmplY3QsICc6Jywgb3B0Lm9iamVjdCwgdG9rZW4ub2JqZWN0LCBlZGl0cy5vYmplY3QpO1xyXG4gICAgICAgIGNvbnN0IGRvYzIgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgY29uc3QgcG9zMiA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICBjb25zdCBvcHQyID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgIGNvbnN0IHRva2VuMiA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICBjb25zdCBlZGl0czIgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgY29uc3QgbmV3bGluZVByb3ZpZGVyID0gc2V0dXBQcm92aWRlcihkb2MyLm9iamVjdCwgcG9zMi5vYmplY3QsICdcXG4nLCBvcHQyLm9iamVjdCwgdG9rZW4yLm9iamVjdCwgZWRpdHMyLm9iamVjdCk7XHJcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IG5ldyBkaXNwYXRjaGVyXzEuT25UeXBlRm9ybWF0dGluZ0Rpc3BhdGNoZXIoe1xyXG4gICAgICAgICAgICAnOic6IGNvbG9uUHJvdmlkZXIub2JqZWN0LFxyXG4gICAgICAgICAgICAnXFxuJzogbmV3bGluZVByb3ZpZGVyLm9iamVjdFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHRyaWdnZXJzID0gZGlzcGF0Y2hlci5nZXRUcmlnZ2VyQ2hhcmFjdGVycygpO1xyXG4gICAgICAgIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwodHJpZ2dlcnMsIHsgZmlyc3Q6ICdcXG4nLCBtb3JlOiBbJzonXSB9LCAnRGlkIG5vdCByZXR1cm4gY29ycmVjdCB0cmlnZ2VycycpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRpc3BhdGNoZXIucHJvdmlkZU9uVHlwZUZvcm1hdHRpbmdFZGl0cyhkb2Mub2JqZWN0LCBwb3Mub2JqZWN0LCAnOicsIG9wdC5vYmplY3QsIHRva2VuLm9iamVjdCk7XHJcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdCwgZWRpdHMub2JqZWN0LCAnRGlkIG5vdCByZXR1cm4gY29ycmVjdCBlZGl0c2ZvciBjb2xvbiBwcm92aWRlcicpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDIgPSBkaXNwYXRjaGVyLnByb3ZpZGVPblR5cGVGb3JtYXR0aW5nRWRpdHMoZG9jMi5vYmplY3QsIHBvczIub2JqZWN0LCAnXFxuJywgb3B0Mi5vYmplY3QsIHRva2VuMi5vYmplY3QpO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbChyZXN1bHQyLCBlZGl0czIub2JqZWN0LCAnRGlkIG5vdCByZXR1cm4gY29ycmVjdCBlZGl0cyBmb3IgbmV3bGluZSBwcm92aWRlcicpO1xyXG4gICAgICAgIGNvbG9uUHJvdmlkZXIudmVyaWZ5QWxsKCk7XHJcbiAgICAgICAgbmV3bGluZVByb3ZpZGVyLnZlcmlmeUFsbCgpO1xyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBzZXR1cFByb3ZpZGVyKGRvY3VtZW50LCBwb3NpdGlvbiwgY2gsIG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuLCByZXN1bHQpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICBwcm92aWRlci5zZXR1cChwID0+IHAucHJvdmlkZU9uVHlwZUZvcm1hdHRpbmdFZGl0cyhkb2N1bWVudCwgcG9zaXRpb24sIGNoLCBvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbikpXHJcbiAgICAgICAgICAgIC5yZXR1cm5zKCgpID0+IHJlc3VsdClcclxuICAgICAgICAgICAgLnZlcmlmaWFibGUoVHlwZU1vcS5UaW1lcy5vbmNlKCkpO1xyXG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcclxuICAgIH1cclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuc2lvbi5kaXNwYXRjaC50ZXN0LmpzLm1hcCJdfQ==