'use strict';

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const assert = require("assert");

const fs = require("fs-extra");

const path = require("path");

const vscode_1 = require("vscode");

const constants_1 = require("../../../client/common/constants");

const platform_1 = require("../../../client/common/utils/platform");

const constants_2 = require("../../../client/unittests/common/constants");

const types_1 = require("../../../client/unittests/common/types");

const common_1 = require("../../common");

const serviceRegistry_1 = require("../serviceRegistry");

const initialize_1 = require("./../../initialize");

const testFilesPath = path.join(constants_1.EXTENSION_ROOT_DIR, 'src', 'test', 'pythonFiles', 'testFiles');
const UNITTEST_TEST_FILES_PATH = path.join(testFilesPath, 'standard');
const UNITTEST_SINGLE_TEST_FILE_PATH = path.join(testFilesPath, 'single');
const UNITTEST_MULTI_TEST_FILE_PATH = path.join(testFilesPath, 'multi');
const UNITTEST_COUNTS_TEST_FILE_PATH = path.join(testFilesPath, 'counter');
const defaultUnitTestArgs = ['-v', '-s', '.', '-p', '*test*.py']; // tslint:disable-next-line:max-func-body-length

suite('Unit Tests - unittest - discovery against actual python process', () => {
  let ioc;
  const configTarget = initialize_1.IS_MULTI_ROOT_TEST ? vscode_1.ConfigurationTarget.WorkspaceFolder : vscode_1.ConfigurationTarget.Workspace;
  suiteSetup(() => __awaiter(void 0, void 0, void 0, function* () {
    yield initialize_1.initialize();
    yield common_1.updateSetting('unitTest.unittestArgs', defaultUnitTestArgs, common_1.rootWorkspaceUri, configTarget);
  }));
  setup(() => __awaiter(void 0, void 0, void 0, function* () {
    const cachePath = path.join(UNITTEST_TEST_FILES_PATH, '.cache');

    if (yield fs.pathExists(cachePath)) {
      yield fs.remove(cachePath);
    }

    yield initialize_1.initializeTest();
    initializeDI();
  }));
  teardown(() => __awaiter(void 0, void 0, void 0, function* () {
    ioc.dispose();
    yield common_1.updateSetting('unitTest.unittestArgs', defaultUnitTestArgs, common_1.rootWorkspaceUri, configTarget);
  }));

  function initializeDI() {
    ioc = new serviceRegistry_1.UnitTestIocContainer();
    ioc.registerCommonTypes();
    ioc.registerVariableTypes();
    ioc.registerUnitTestTypes();
    ioc.registerProcessTypes();
  }

  test('Discover Tests (single test file)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.unittestArgs', ['-s=./tests', '-p=test_*.py'], common_1.rootWorkspaceUri, configTarget);
    const factory = ioc.serviceContainer.get(types_1.ITestManagerFactory);
    const testManager = factory('unittest', common_1.rootWorkspaceUri, UNITTEST_SINGLE_TEST_FILE_PATH);
    const tests = yield testManager.discoverTests(constants_2.CommandSource.ui, true, true);
    assert.equal(tests.testFiles.length, 1, 'Incorrect number of test files');
    assert.equal(tests.testFunctions.length, 3, 'Incorrect number of test functions');
    assert.equal(tests.testSuites.length, 1, 'Incorrect number of test suites');
    assert.equal(tests.testFiles.some(t => t.name === 'test_one.py' && t.nameToRun === 'test_one.Test_test1.test_A'), true, 'Test File not found');
  }));
  test('Discover Tests (many test files, subdir included)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.unittestArgs', ['-s=./tests', '-p=test_*.py'], common_1.rootWorkspaceUri, configTarget);
    const factory = ioc.serviceContainer.get(types_1.ITestManagerFactory);
    const testManager = factory('unittest', common_1.rootWorkspaceUri, UNITTEST_MULTI_TEST_FILE_PATH);
    const tests = yield testManager.discoverTests(constants_2.CommandSource.ui, true, true);
    assert.equal(tests.testFiles.length, 3, 'Incorrect number of test files');
    assert.equal(tests.testFunctions.length, 9, 'Incorrect number of test functions');
    assert.equal(tests.testSuites.length, 3, 'Incorrect number of test suites');
    assert.equal(tests.testFiles.some(t => t.name === 'test_one.py' && t.nameToRun === 'test_one.Test_test1.test_A'), true, 'Test File one not found');
    assert.equal(tests.testFiles.some(t => t.name === 'test_two.py' && t.nameToRun === 'test_two.Test_test2.test_2A'), true, 'Test File two not found');
    assert.equal(tests.testFiles.some(t => t.name === 'test_three.py' && t.nameToRun === 'more_tests.test_three.Test_test3.test_3A'), true, 'Test File three not found');
  }));
  test('Run single test', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.unittestArgs', ['-s=./tests', '-p=test_*.py'], common_1.rootWorkspaceUri, configTarget);
    const factory = ioc.serviceContainer.get(types_1.ITestManagerFactory);
    const testManager = factory('unittest', common_1.rootWorkspaceUri, UNITTEST_MULTI_TEST_FILE_PATH);
    const testsDiscovered = yield testManager.discoverTests(constants_2.CommandSource.ui, true, true);
    const testFile = testsDiscovered.testFiles.find(value => value.nameToRun.endsWith('_3A'));
    assert.notEqual(testFile, undefined, 'No test file suffixed with _3A in test files.');
    assert.equal(testFile.suites.length, 1, 'Expected only 1 test suite in test file three.');
    const testFunc = testFile.suites[0].functions.find(value => value.name === 'test_3A');
    assert.notEqual(testFunc, undefined, 'No test in file test_three.py named test_3A');
    const testsToRun = {
      testFunction: [testFunc]
    };
    const testRunResult = yield testManager.runTest(constants_2.CommandSource.ui, testsToRun);
    assert.equal(testRunResult.summary.failures + testRunResult.summary.passed + testRunResult.summary.skipped, 1, 'Expected to see only 1 test run in the summary for tests run.');
    assert.equal(testRunResult.summary.errors, 0, 'Unexpected: Test file ran with errors.');
    assert.equal(testRunResult.summary.failures, 0, 'Unexpected: Test has failed during test run.');
    assert.equal(testRunResult.summary.passed, 1, `Only one test should have passed during our test run. Instead, ${testRunResult.summary.passed} passed.`);
    assert.equal(testRunResult.summary.skipped, 0, `Expected to have skipped 0 tests during this test-run. Instead, ${testRunResult.summary.skipped} where skipped.`);
  }));
  test('Ensure correct test count for running a set of tests multiple times', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // This test has not been working for many months in Python 3.4 under
      // Windows and macOS.Tracked by #2548.
      if (common_1.isOs(platform_1.OSType.Windows, platform_1.OSType.OSX)) {
        if (yield common_1.isPythonVersion('3.4')) {
          // tslint:disable-next-line:no-invalid-this
          return this.skip();
        }
      }

      yield common_1.updateSetting('unitTest.unittestArgs', ['-s=./tests', '-p=test_*.py'], common_1.rootWorkspaceUri, configTarget);
      const factory = ioc.serviceContainer.get(types_1.ITestManagerFactory);
      const testManager = factory('unittest', common_1.rootWorkspaceUri, UNITTEST_COUNTS_TEST_FILE_PATH);
      const testsDiscovered = yield testManager.discoverTests(constants_2.CommandSource.ui, true, true);
      const testsFile = testsDiscovered.testFiles.find(value => value.name.startsWith('test_unit_test_counter'));
      assert.notEqual(testsFile, undefined, `No test file suffixed with _counter in test files. Looked in ${UNITTEST_COUNTS_TEST_FILE_PATH}.`);
      assert.equal(testsFile.suites.length, 1, 'Expected only 1 test suite in counter test file.');
      const testsToRun = {
        testFolder: [testsDiscovered.testFolders[0]]
      }; // ensure that each re-run of the unit tests in question result in the same summary count information.

      let testRunResult = yield testManager.runTest(constants_2.CommandSource.ui, testsToRun);
      assert.equal(testRunResult.summary.failures, 2, 'This test was written assuming there was 2 tests run that would fail. (iteration 1)');
      assert.equal(testRunResult.summary.passed, 2, 'This test was written assuming there was 2 tests run that would succeed. (iteration 1)');
      testRunResult = yield testManager.runTest(constants_2.CommandSource.ui, testsToRun);
      assert.equal(testRunResult.summary.failures, 2, 'This test was written assuming there was 2 tests run that would fail. (iteration 2)');
      assert.equal(testRunResult.summary.passed, 2, 'This test was written assuming there was 2 tests run that would succeed. (iteration 2)');
    });
  });
  test('Re-run failed tests results in the correct number of tests counted', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // This test has not been working for many months in Python 3.4 under
      // Windows and macOS.Tracked by #2548.
      if (common_1.isOs(platform_1.OSType.Windows, platform_1.OSType.OSX)) {
        if (yield common_1.isPythonVersion('3.4')) {
          // tslint:disable-next-line:no-invalid-this
          return this.skip();
        }
      }

      yield common_1.updateSetting('unitTest.unittestArgs', ['-s=./tests', '-p=test_*.py'], common_1.rootWorkspaceUri, configTarget);
      const factory = ioc.serviceContainer.get(types_1.ITestManagerFactory);
      const testManager = factory('unittest', common_1.rootWorkspaceUri, UNITTEST_COUNTS_TEST_FILE_PATH);
      const testsDiscovered = yield testManager.discoverTests(constants_2.CommandSource.ui, true, true);
      const testsFile = testsDiscovered.testFiles.find(value => value.name.startsWith('test_unit_test_counter'));
      assert.notEqual(testsFile, undefined, `No test file suffixed with _counter in test files. Looked in ${UNITTEST_COUNTS_TEST_FILE_PATH}.`);
      assert.equal(testsFile.suites.length, 1, 'Expected only 1 test suite in counter test file.');
      const testsToRun = {
        testFolder: [testsDiscovered.testFolders[0]]
      }; // ensure that each re-run of the unit tests in question result in the same summary count information.

      let testRunResult = yield testManager.runTest(constants_2.CommandSource.ui, testsToRun);
      assert.equal(testRunResult.summary.failures, 2, 'This test was written assuming there was 2 tests run that would fail. (iteration 1)');
      assert.equal(testRunResult.summary.passed, 2, 'This test was written assuming there was 2 tests run that would succeed. (iteration 1)');
      testRunResult = yield testManager.runTest(constants_2.CommandSource.ui, testsToRun, true);
      assert.equal(testRunResult.summary.failures, 2, 'This test was written assuming there was 2 tests run that would fail. (iteration 2)');
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaXR0ZXN0LnRlc3QuanMiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImFzc2VydCIsInJlcXVpcmUiLCJmcyIsInBhdGgiLCJ2c2NvZGVfMSIsImNvbnN0YW50c18xIiwicGxhdGZvcm1fMSIsImNvbnN0YW50c18yIiwidHlwZXNfMSIsImNvbW1vbl8xIiwic2VydmljZVJlZ2lzdHJ5XzEiLCJpbml0aWFsaXplXzEiLCJ0ZXN0RmlsZXNQYXRoIiwiam9pbiIsIkVYVEVOU0lPTl9ST09UX0RJUiIsIlVOSVRURVNUX1RFU1RfRklMRVNfUEFUSCIsIlVOSVRURVNUX1NJTkdMRV9URVNUX0ZJTEVfUEFUSCIsIlVOSVRURVNUX01VTFRJX1RFU1RfRklMRV9QQVRIIiwiVU5JVFRFU1RfQ09VTlRTX1RFU1RfRklMRV9QQVRIIiwiZGVmYXVsdFVuaXRUZXN0QXJncyIsInN1aXRlIiwiaW9jIiwiY29uZmlnVGFyZ2V0IiwiSVNfTVVMVElfUk9PVF9URVNUIiwiQ29uZmlndXJhdGlvblRhcmdldCIsIldvcmtzcGFjZUZvbGRlciIsIldvcmtzcGFjZSIsInN1aXRlU2V0dXAiLCJpbml0aWFsaXplIiwidXBkYXRlU2V0dGluZyIsInJvb3RXb3Jrc3BhY2VVcmkiLCJzZXR1cCIsImNhY2hlUGF0aCIsInBhdGhFeGlzdHMiLCJyZW1vdmUiLCJpbml0aWFsaXplVGVzdCIsImluaXRpYWxpemVESSIsInRlYXJkb3duIiwiZGlzcG9zZSIsIlVuaXRUZXN0SW9jQ29udGFpbmVyIiwicmVnaXN0ZXJDb21tb25UeXBlcyIsInJlZ2lzdGVyVmFyaWFibGVUeXBlcyIsInJlZ2lzdGVyVW5pdFRlc3RUeXBlcyIsInJlZ2lzdGVyUHJvY2Vzc1R5cGVzIiwidGVzdCIsImZhY3RvcnkiLCJzZXJ2aWNlQ29udGFpbmVyIiwiZ2V0IiwiSVRlc3RNYW5hZ2VyRmFjdG9yeSIsInRlc3RNYW5hZ2VyIiwidGVzdHMiLCJkaXNjb3ZlclRlc3RzIiwiQ29tbWFuZFNvdXJjZSIsInVpIiwiZXF1YWwiLCJ0ZXN0RmlsZXMiLCJsZW5ndGgiLCJ0ZXN0RnVuY3Rpb25zIiwidGVzdFN1aXRlcyIsInNvbWUiLCJ0IiwibmFtZSIsIm5hbWVUb1J1biIsInRlc3RzRGlzY292ZXJlZCIsInRlc3RGaWxlIiwiZmluZCIsImVuZHNXaXRoIiwibm90RXF1YWwiLCJ1bmRlZmluZWQiLCJzdWl0ZXMiLCJ0ZXN0RnVuYyIsImZ1bmN0aW9ucyIsInRlc3RzVG9SdW4iLCJ0ZXN0RnVuY3Rpb24iLCJ0ZXN0UnVuUmVzdWx0IiwicnVuVGVzdCIsInN1bW1hcnkiLCJmYWlsdXJlcyIsInBhc3NlZCIsInNraXBwZWQiLCJlcnJvcnMiLCJpc09zIiwiT1NUeXBlIiwiV2luZG93cyIsIk9TWCIsImlzUHl0aG9uVmVyc2lvbiIsInNraXAiLCJ0ZXN0c0ZpbGUiLCJzdGFydHNXaXRoIiwidGVzdEZvbGRlciIsInRlc3RGb2xkZXJzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxTQUFTLEdBQUksVUFBUSxTQUFLQSxTQUFkLElBQTRCLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxDQUEvQixFQUFrQ0MsU0FBbEMsRUFBNkM7QUFDckYsU0FBTyxLQUFLRCxDQUFDLEtBQUtBLENBQUMsR0FBR0UsT0FBVCxDQUFOLEVBQXlCLFVBQVVDLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTJCO0FBQ3ZELGFBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO0FBQUUsVUFBSTtBQUFFQyxRQUFBQSxJQUFJLENBQUNOLFNBQVMsQ0FBQ08sSUFBVixDQUFlRixLQUFmLENBQUQsQ0FBSjtBQUE4QixPQUFwQyxD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NkMsYUFBWixDQUEwQkMsRUFBOUMsRUFBa0RtQixVQUFsRCxDQUExQjtBQUNBeEUsTUFBQUEsTUFBTSxDQUFDc0QsS0FBUCxDQUFhb0IsYUFBYSxDQUFDRSxPQUFkLENBQXNCQyxRQUFuQyxFQUE2QyxDQUE3QyxFQUFnRCxxRkFBaEQ7QUFDQTdFLE1BQUFBLE1BQU0sQ0FBQ3NELEtBQVAsQ0FBYW9CLGFBQWEsQ0FBQ0UsT0FBZCxDQUFzQkUsTUFBbkMsRUFBMkMsQ0FBM0MsRUFBOEMsd0ZBQTlDO0FBQ0FKLE1BQUFBLGFBQWEsR0FBRyxNQUFNekIsV0FBVyxDQUFDMEIsT0FBWixDQUFvQnBFLFdBQVcsQ0FBQzZDLGFBQVosQ0FBMEJDLEVBQTlDLEVBQWtEbUIsVUFBbEQsRUFBOEQsSUFBOUQsQ0FBdEI7QUFDQXhFLE1BQUFBLE1BQU0sQ0FBQ3NELEtBQVAsQ0FBYW9CLGFBQWEsQ0FBQ0UsT0FBZCxDQUFzQkMsUUFBbkMsRUFBNkMsQ0FBN0MsRUFBZ0QscUZBQWhEO0FBQ0gsS0F6QmUsQ0FBaEI7QUEwQkgsR0EzQkcsQ0FBSjtBQTRCSCxDQTdISSxDQUFMIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IHZzY29kZV8xID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi9jb25zdGFudHNcIik7XHJcbmNvbnN0IHBsYXRmb3JtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi91dGlscy9wbGF0Zm9ybVwiKTtcclxuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy9jb21tb24vY29uc3RhbnRzXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC91bml0dGVzdHMvY29tbW9uL3R5cGVzXCIpO1xyXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XHJcbmNvbnN0IHNlcnZpY2VSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4uL3NlcnZpY2VSZWdpc3RyeVwiKTtcclxuY29uc3QgaW5pdGlhbGl6ZV8xID0gcmVxdWlyZShcIi4vLi4vLi4vaW5pdGlhbGl6ZVwiKTtcclxuY29uc3QgdGVzdEZpbGVzUGF0aCA9IHBhdGguam9pbihjb25zdGFudHNfMS5FWFRFTlNJT05fUk9PVF9ESVIsICdzcmMnLCAndGVzdCcsICdweXRob25GaWxlcycsICd0ZXN0RmlsZXMnKTtcclxuY29uc3QgVU5JVFRFU1RfVEVTVF9GSUxFU19QQVRIID0gcGF0aC5qb2luKHRlc3RGaWxlc1BhdGgsICdzdGFuZGFyZCcpO1xyXG5jb25zdCBVTklUVEVTVF9TSU5HTEVfVEVTVF9GSUxFX1BBVEggPSBwYXRoLmpvaW4odGVzdEZpbGVzUGF0aCwgJ3NpbmdsZScpO1xyXG5jb25zdCBVTklUVEVTVF9NVUxUSV9URVNUX0ZJTEVfUEFUSCA9IHBhdGguam9pbih0ZXN0RmlsZXNQYXRoLCAnbXVsdGknKTtcclxuY29uc3QgVU5JVFRFU1RfQ09VTlRTX1RFU1RfRklMRV9QQVRIID0gcGF0aC5qb2luKHRlc3RGaWxlc1BhdGgsICdjb3VudGVyJyk7XHJcbmNvbnN0IGRlZmF1bHRVbml0VGVzdEFyZ3MgPSBbXHJcbiAgICAnLXYnLFxyXG4gICAgJy1zJyxcclxuICAgICcuJyxcclxuICAgICctcCcsXHJcbiAgICAnKnRlc3QqLnB5J1xyXG5dO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWZ1bmMtYm9keS1sZW5ndGhcclxuc3VpdGUoJ1VuaXQgVGVzdHMgLSB1bml0dGVzdCAtIGRpc2NvdmVyeSBhZ2FpbnN0IGFjdHVhbCBweXRob24gcHJvY2VzcycsICgpID0+IHtcclxuICAgIGxldCBpb2M7XHJcbiAgICBjb25zdCBjb25maWdUYXJnZXQgPSBpbml0aWFsaXplXzEuSVNfTVVMVElfUk9PVF9URVNUID8gdnNjb2RlXzEuQ29uZmlndXJhdGlvblRhcmdldC5Xb3Jrc3BhY2VGb2xkZXIgOiB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZTtcclxuICAgIHN1aXRlU2V0dXAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIGluaXRpYWxpemVfMS5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3QudW5pdHRlc3RBcmdzJywgZGVmYXVsdFVuaXRUZXN0QXJncywgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgY29uZmlnVGFyZ2V0KTtcclxuICAgIH0pKTtcclxuICAgIHNldHVwKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBjYWNoZVBhdGggPSBwYXRoLmpvaW4oVU5JVFRFU1RfVEVTVF9GSUxFU19QQVRILCAnLmNhY2hlJyk7XHJcbiAgICAgICAgaWYgKHlpZWxkIGZzLnBhdGhFeGlzdHMoY2FjaGVQYXRoKSkge1xyXG4gICAgICAgICAgICB5aWVsZCBmcy5yZW1vdmUoY2FjaGVQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgaW5pdGlhbGl6ZV8xLmluaXRpYWxpemVUZXN0KCk7XHJcbiAgICAgICAgaW5pdGlhbGl6ZURJKCk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZWFyZG93bigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaW9jLmRpc3Bvc2UoKTtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC51bml0dGVzdEFyZ3MnLCBkZWZhdWx0VW5pdFRlc3RBcmdzLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCBjb25maWdUYXJnZXQpO1xyXG4gICAgfSkpO1xyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZURJKCkge1xyXG4gICAgICAgIGlvYyA9IG5ldyBzZXJ2aWNlUmVnaXN0cnlfMS5Vbml0VGVzdElvY0NvbnRhaW5lcigpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlckNvbW1vblR5cGVzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyVmFyaWFibGVUeXBlcygpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlclVuaXRUZXN0VHlwZXMoKTtcclxuICAgICAgICBpb2MucmVnaXN0ZXJQcm9jZXNzVHlwZXMoKTtcclxuICAgIH1cclxuICAgIHRlc3QoJ0Rpc2NvdmVyIFRlc3RzIChzaW5nbGUgdGVzdCBmaWxlKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC51bml0dGVzdEFyZ3MnLCBbJy1zPS4vdGVzdHMnLCAnLXA9dGVzdF8qLnB5J10sIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIGNvbmZpZ1RhcmdldCk7XHJcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IGlvYy5zZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18xLklUZXN0TWFuYWdlckZhY3RvcnkpO1xyXG4gICAgICAgIGNvbnN0IHRlc3RNYW5hZ2VyID0gZmFjdG9yeSgndW5pdHRlc3QnLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCBVTklUVEVTVF9TSU5HTEVfVEVTVF9GSUxFX1BBVEgpO1xyXG4gICAgICAgIGNvbnN0IHRlc3RzID0geWllbGQgdGVzdE1hbmFnZXIuZGlzY292ZXJUZXN0cyhjb25zdGFudHNfMi5Db21tYW5kU291cmNlLnVpLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodGVzdHMudGVzdEZpbGVzLmxlbmd0aCwgMSwgJ0luY29ycmVjdCBudW1iZXIgb2YgdGVzdCBmaWxlcycpO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbCh0ZXN0cy50ZXN0RnVuY3Rpb25zLmxlbmd0aCwgMywgJ0luY29ycmVjdCBudW1iZXIgb2YgdGVzdCBmdW5jdGlvbnMnKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodGVzdHMudGVzdFN1aXRlcy5sZW5ndGgsIDEsICdJbmNvcnJlY3QgbnVtYmVyIG9mIHRlc3Qgc3VpdGVzJyk7XHJcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRlc3RzLnRlc3RGaWxlcy5zb21lKHQgPT4gdC5uYW1lID09PSAndGVzdF9vbmUucHknICYmIHQubmFtZVRvUnVuID09PSAndGVzdF9vbmUuVGVzdF90ZXN0MS50ZXN0X0EnKSwgdHJ1ZSwgJ1Rlc3QgRmlsZSBub3QgZm91bmQnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0Rpc2NvdmVyIFRlc3RzIChtYW55IHRlc3QgZmlsZXMsIHN1YmRpciBpbmNsdWRlZCknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3QudW5pdHRlc3RBcmdzJywgWyctcz0uL3Rlc3RzJywgJy1wPXRlc3RfKi5weSddLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCBjb25maWdUYXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSBpb2Muc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JVGVzdE1hbmFnZXJGYWN0b3J5KTtcclxuICAgICAgICBjb25zdCB0ZXN0TWFuYWdlciA9IGZhY3RvcnkoJ3VuaXR0ZXN0JywgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgVU5JVFRFU1RfTVVMVElfVEVTVF9GSUxFX1BBVEgpO1xyXG4gICAgICAgIGNvbnN0IHRlc3RzID0geWllbGQgdGVzdE1hbmFnZXIuZGlzY292ZXJUZXN0cyhjb25zdGFudHNfMi5Db21tYW5kU291cmNlLnVpLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodGVzdHMudGVzdEZpbGVzLmxlbmd0aCwgMywgJ0luY29ycmVjdCBudW1iZXIgb2YgdGVzdCBmaWxlcycpO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbCh0ZXN0cy50ZXN0RnVuY3Rpb25zLmxlbmd0aCwgOSwgJ0luY29ycmVjdCBudW1iZXIgb2YgdGVzdCBmdW5jdGlvbnMnKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodGVzdHMudGVzdFN1aXRlcy5sZW5ndGgsIDMsICdJbmNvcnJlY3QgbnVtYmVyIG9mIHRlc3Qgc3VpdGVzJyk7XHJcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRlc3RzLnRlc3RGaWxlcy5zb21lKHQgPT4gdC5uYW1lID09PSAndGVzdF9vbmUucHknICYmIHQubmFtZVRvUnVuID09PSAndGVzdF9vbmUuVGVzdF90ZXN0MS50ZXN0X0EnKSwgdHJ1ZSwgJ1Rlc3QgRmlsZSBvbmUgbm90IGZvdW5kJyk7XHJcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRlc3RzLnRlc3RGaWxlcy5zb21lKHQgPT4gdC5uYW1lID09PSAndGVzdF90d28ucHknICYmIHQubmFtZVRvUnVuID09PSAndGVzdF90d28uVGVzdF90ZXN0Mi50ZXN0XzJBJyksIHRydWUsICdUZXN0IEZpbGUgdHdvIG5vdCBmb3VuZCcpO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbCh0ZXN0cy50ZXN0RmlsZXMuc29tZSh0ID0+IHQubmFtZSA9PT0gJ3Rlc3RfdGhyZWUucHknICYmIHQubmFtZVRvUnVuID09PSAnbW9yZV90ZXN0cy50ZXN0X3RocmVlLlRlc3RfdGVzdDMudGVzdF8zQScpLCB0cnVlLCAnVGVzdCBGaWxlIHRocmVlIG5vdCBmb3VuZCcpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnUnVuIHNpbmdsZSB0ZXN0JywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLnVwZGF0ZVNldHRpbmcoJ3VuaXRUZXN0LnVuaXR0ZXN0QXJncycsIFsnLXM9Li90ZXN0cycsICctcD10ZXN0XyoucHknXSwgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgY29uZmlnVGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBmYWN0b3J5ID0gaW9jLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSVRlc3RNYW5hZ2VyRmFjdG9yeSk7XHJcbiAgICAgICAgY29uc3QgdGVzdE1hbmFnZXIgPSBmYWN0b3J5KCd1bml0dGVzdCcsIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIFVOSVRURVNUX01VTFRJX1RFU1RfRklMRV9QQVRIKTtcclxuICAgICAgICBjb25zdCB0ZXN0c0Rpc2NvdmVyZWQgPSB5aWVsZCB0ZXN0TWFuYWdlci5kaXNjb3ZlclRlc3RzKGNvbnN0YW50c18yLkNvbW1hbmRTb3VyY2UudWksIHRydWUsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHRlc3RGaWxlID0gdGVzdHNEaXNjb3ZlcmVkLnRlc3RGaWxlcy5maW5kKCh2YWx1ZSkgPT4gdmFsdWUubmFtZVRvUnVuLmVuZHNXaXRoKCdfM0EnKSk7XHJcbiAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKHRlc3RGaWxlLCB1bmRlZmluZWQsICdObyB0ZXN0IGZpbGUgc3VmZml4ZWQgd2l0aCBfM0EgaW4gdGVzdCBmaWxlcy4nKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodGVzdEZpbGUuc3VpdGVzLmxlbmd0aCwgMSwgJ0V4cGVjdGVkIG9ubHkgMSB0ZXN0IHN1aXRlIGluIHRlc3QgZmlsZSB0aHJlZS4nKTtcclxuICAgICAgICBjb25zdCB0ZXN0RnVuYyA9IHRlc3RGaWxlLnN1aXRlc1swXS5mdW5jdGlvbnMuZmluZCgodmFsdWUpID0+IHZhbHVlLm5hbWUgPT09ICd0ZXN0XzNBJyk7XHJcbiAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKHRlc3RGdW5jLCB1bmRlZmluZWQsICdObyB0ZXN0IGluIGZpbGUgdGVzdF90aHJlZS5weSBuYW1lZCB0ZXN0XzNBJyk7XHJcbiAgICAgICAgY29uc3QgdGVzdHNUb1J1biA9IHtcclxuICAgICAgICAgICAgdGVzdEZ1bmN0aW9uOiBbdGVzdEZ1bmNdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0ZXN0UnVuUmVzdWx0ID0geWllbGQgdGVzdE1hbmFnZXIucnVuVGVzdChjb25zdGFudHNfMi5Db21tYW5kU291cmNlLnVpLCB0ZXN0c1RvUnVuKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodGVzdFJ1blJlc3VsdC5zdW1tYXJ5LmZhaWx1cmVzICsgdGVzdFJ1blJlc3VsdC5zdW1tYXJ5LnBhc3NlZCArIHRlc3RSdW5SZXN1bHQuc3VtbWFyeS5za2lwcGVkLCAxLCAnRXhwZWN0ZWQgdG8gc2VlIG9ubHkgMSB0ZXN0IHJ1biBpbiB0aGUgc3VtbWFyeSBmb3IgdGVzdHMgcnVuLicpO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbCh0ZXN0UnVuUmVzdWx0LnN1bW1hcnkuZXJyb3JzLCAwLCAnVW5leHBlY3RlZDogVGVzdCBmaWxlIHJhbiB3aXRoIGVycm9ycy4nKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodGVzdFJ1blJlc3VsdC5zdW1tYXJ5LmZhaWx1cmVzLCAwLCAnVW5leHBlY3RlZDogVGVzdCBoYXMgZmFpbGVkIGR1cmluZyB0ZXN0IHJ1bi4nKTtcclxuICAgICAgICBhc3NlcnQuZXF1YWwodGVzdFJ1blJlc3VsdC5zdW1tYXJ5LnBhc3NlZCwgMSwgYE9ubHkgb25lIHRlc3Qgc2hvdWxkIGhhdmUgcGFzc2VkIGR1cmluZyBvdXIgdGVzdCBydW4uIEluc3RlYWQsICR7dGVzdFJ1blJlc3VsdC5zdW1tYXJ5LnBhc3NlZH0gcGFzc2VkLmApO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbCh0ZXN0UnVuUmVzdWx0LnN1bW1hcnkuc2tpcHBlZCwgMCwgYEV4cGVjdGVkIHRvIGhhdmUgc2tpcHBlZCAwIHRlc3RzIGR1cmluZyB0aGlzIHRlc3QtcnVuLiBJbnN0ZWFkLCAke3Rlc3RSdW5SZXN1bHQuc3VtbWFyeS5za2lwcGVkfSB3aGVyZSBza2lwcGVkLmApO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnRW5zdXJlIGNvcnJlY3QgdGVzdCBjb3VudCBmb3IgcnVubmluZyBhIHNldCBvZiB0ZXN0cyBtdWx0aXBsZSB0aW1lcycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHRlc3QgaGFzIG5vdCBiZWVuIHdvcmtpbmcgZm9yIG1hbnkgbW9udGhzIGluIFB5dGhvbiAzLjQgdW5kZXJcclxuICAgICAgICAgICAgLy8gV2luZG93cyBhbmQgbWFjT1MuVHJhY2tlZCBieSAjMjU0OC5cclxuICAgICAgICAgICAgaWYgKGNvbW1vbl8xLmlzT3MocGxhdGZvcm1fMS5PU1R5cGUuV2luZG93cywgcGxhdGZvcm1fMS5PU1R5cGUuT1NYKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHlpZWxkIGNvbW1vbl8xLmlzUHl0aG9uVmVyc2lvbignMy40JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIGNvbW1vbl8xLnVwZGF0ZVNldHRpbmcoJ3VuaXRUZXN0LnVuaXR0ZXN0QXJncycsIFsnLXM9Li90ZXN0cycsICctcD10ZXN0XyoucHknXSwgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgY29uZmlnVGFyZ2V0KTtcclxuICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGlvYy5zZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18xLklUZXN0TWFuYWdlckZhY3RvcnkpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXN0TWFuYWdlciA9IGZhY3RvcnkoJ3VuaXR0ZXN0JywgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgVU5JVFRFU1RfQ09VTlRTX1RFU1RfRklMRV9QQVRIKTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdHNEaXNjb3ZlcmVkID0geWllbGQgdGVzdE1hbmFnZXIuZGlzY292ZXJUZXN0cyhjb25zdGFudHNfMi5Db21tYW5kU291cmNlLnVpLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdHNGaWxlID0gdGVzdHNEaXNjb3ZlcmVkLnRlc3RGaWxlcy5maW5kKCh2YWx1ZSkgPT4gdmFsdWUubmFtZS5zdGFydHNXaXRoKCd0ZXN0X3VuaXRfdGVzdF9jb3VudGVyJykpO1xyXG4gICAgICAgICAgICBhc3NlcnQubm90RXF1YWwodGVzdHNGaWxlLCB1bmRlZmluZWQsIGBObyB0ZXN0IGZpbGUgc3VmZml4ZWQgd2l0aCBfY291bnRlciBpbiB0ZXN0IGZpbGVzLiBMb29rZWQgaW4gJHtVTklUVEVTVF9DT1VOVFNfVEVTVF9GSUxFX1BBVEh9LmApO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwodGVzdHNGaWxlLnN1aXRlcy5sZW5ndGgsIDEsICdFeHBlY3RlZCBvbmx5IDEgdGVzdCBzdWl0ZSBpbiBjb3VudGVyIHRlc3QgZmlsZS4nKTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdHNUb1J1biA9IHtcclxuICAgICAgICAgICAgICAgIHRlc3RGb2xkZXI6IFt0ZXN0c0Rpc2NvdmVyZWQudGVzdEZvbGRlcnNbMF1dXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IGVhY2ggcmUtcnVuIG9mIHRoZSB1bml0IHRlc3RzIGluIHF1ZXN0aW9uIHJlc3VsdCBpbiB0aGUgc2FtZSBzdW1tYXJ5IGNvdW50IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICBsZXQgdGVzdFJ1blJlc3VsdCA9IHlpZWxkIHRlc3RNYW5hZ2VyLnJ1blRlc3QoY29uc3RhbnRzXzIuQ29tbWFuZFNvdXJjZS51aSwgdGVzdHNUb1J1bik7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCh0ZXN0UnVuUmVzdWx0LnN1bW1hcnkuZmFpbHVyZXMsIDIsICdUaGlzIHRlc3Qgd2FzIHdyaXR0ZW4gYXNzdW1pbmcgdGhlcmUgd2FzIDIgdGVzdHMgcnVuIHRoYXQgd291bGQgZmFpbC4gKGl0ZXJhdGlvbiAxKScpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwodGVzdFJ1blJlc3VsdC5zdW1tYXJ5LnBhc3NlZCwgMiwgJ1RoaXMgdGVzdCB3YXMgd3JpdHRlbiBhc3N1bWluZyB0aGVyZSB3YXMgMiB0ZXN0cyBydW4gdGhhdCB3b3VsZCBzdWNjZWVkLiAoaXRlcmF0aW9uIDEpJyk7XHJcbiAgICAgICAgICAgIHRlc3RSdW5SZXN1bHQgPSB5aWVsZCB0ZXN0TWFuYWdlci5ydW5UZXN0KGNvbnN0YW50c18yLkNvbW1hbmRTb3VyY2UudWksIHRlc3RzVG9SdW4pO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwodGVzdFJ1blJlc3VsdC5zdW1tYXJ5LmZhaWx1cmVzLCAyLCAnVGhpcyB0ZXN0IHdhcyB3cml0dGVuIGFzc3VtaW5nIHRoZXJlIHdhcyAyIHRlc3RzIHJ1biB0aGF0IHdvdWxkIGZhaWwuIChpdGVyYXRpb24gMiknKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHRlc3RSdW5SZXN1bHQuc3VtbWFyeS5wYXNzZWQsIDIsICdUaGlzIHRlc3Qgd2FzIHdyaXR0ZW4gYXNzdW1pbmcgdGhlcmUgd2FzIDIgdGVzdHMgcnVuIHRoYXQgd291bGQgc3VjY2VlZC4gKGl0ZXJhdGlvbiAyKScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB0ZXN0KCdSZS1ydW4gZmFpbGVkIHRlc3RzIHJlc3VsdHMgaW4gdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHRlc3RzIGNvdW50ZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB0ZXN0IGhhcyBub3QgYmVlbiB3b3JraW5nIGZvciBtYW55IG1vbnRocyBpbiBQeXRob24gMy40IHVuZGVyXHJcbiAgICAgICAgICAgIC8vIFdpbmRvd3MgYW5kIG1hY09TLlRyYWNrZWQgYnkgIzI1NDguXHJcbiAgICAgICAgICAgIGlmIChjb21tb25fMS5pc09zKHBsYXRmb3JtXzEuT1NUeXBlLldpbmRvd3MsIHBsYXRmb3JtXzEuT1NUeXBlLk9TWCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh5aWVsZCBjb21tb25fMS5pc1B5dGhvblZlcnNpb24oJzMuNCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNraXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC51bml0dGVzdEFyZ3MnLCBbJy1zPS4vdGVzdHMnLCAnLXA9dGVzdF8qLnB5J10sIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIGNvbmZpZ1RhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSBpb2Muc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JVGVzdE1hbmFnZXJGYWN0b3J5KTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdE1hbmFnZXIgPSBmYWN0b3J5KCd1bml0dGVzdCcsIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIFVOSVRURVNUX0NPVU5UU19URVNUX0ZJTEVfUEFUSCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzRGlzY292ZXJlZCA9IHlpZWxkIHRlc3RNYW5hZ2VyLmRpc2NvdmVyVGVzdHMoY29uc3RhbnRzXzIuQ29tbWFuZFNvdXJjZS51aSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzRmlsZSA9IHRlc3RzRGlzY292ZXJlZC50ZXN0RmlsZXMuZmluZCgodmFsdWUpID0+IHZhbHVlLm5hbWUuc3RhcnRzV2l0aCgndGVzdF91bml0X3Rlc3RfY291bnRlcicpKTtcclxuICAgICAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKHRlc3RzRmlsZSwgdW5kZWZpbmVkLCBgTm8gdGVzdCBmaWxlIHN1ZmZpeGVkIHdpdGggX2NvdW50ZXIgaW4gdGVzdCBmaWxlcy4gTG9va2VkIGluICR7VU5JVFRFU1RfQ09VTlRTX1RFU1RfRklMRV9QQVRIfS5gKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHRlc3RzRmlsZS5zdWl0ZXMubGVuZ3RoLCAxLCAnRXhwZWN0ZWQgb25seSAxIHRlc3Qgc3VpdGUgaW4gY291bnRlciB0ZXN0IGZpbGUuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzVG9SdW4gPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0Rm9sZGVyOiBbdGVzdHNEaXNjb3ZlcmVkLnRlc3RGb2xkZXJzWzBdXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBlYWNoIHJlLXJ1biBvZiB0aGUgdW5pdCB0ZXN0cyBpbiBxdWVzdGlvbiByZXN1bHQgaW4gdGhlIHNhbWUgc3VtbWFyeSBjb3VudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgbGV0IHRlc3RSdW5SZXN1bHQgPSB5aWVsZCB0ZXN0TWFuYWdlci5ydW5UZXN0KGNvbnN0YW50c18yLkNvbW1hbmRTb3VyY2UudWksIHRlc3RzVG9SdW4pO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwodGVzdFJ1blJlc3VsdC5zdW1tYXJ5LmZhaWx1cmVzLCAyLCAnVGhpcyB0ZXN0IHdhcyB3cml0dGVuIGFzc3VtaW5nIHRoZXJlIHdhcyAyIHRlc3RzIHJ1biB0aGF0IHdvdWxkIGZhaWwuIChpdGVyYXRpb24gMSknKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHRlc3RSdW5SZXN1bHQuc3VtbWFyeS5wYXNzZWQsIDIsICdUaGlzIHRlc3Qgd2FzIHdyaXR0ZW4gYXNzdW1pbmcgdGhlcmUgd2FzIDIgdGVzdHMgcnVuIHRoYXQgd291bGQgc3VjY2VlZC4gKGl0ZXJhdGlvbiAxKScpO1xyXG4gICAgICAgICAgICB0ZXN0UnVuUmVzdWx0ID0geWllbGQgdGVzdE1hbmFnZXIucnVuVGVzdChjb25zdGFudHNfMi5Db21tYW5kU291cmNlLnVpLCB0ZXN0c1RvUnVuLCB0cnVlKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHRlc3RSdW5SZXN1bHQuc3VtbWFyeS5mYWlsdXJlcywgMiwgJ1RoaXMgdGVzdCB3YXMgd3JpdHRlbiBhc3N1bWluZyB0aGVyZSB3YXMgMiB0ZXN0cyBydW4gdGhhdCB3b3VsZCBmYWlsLiAoaXRlcmF0aW9uIDIpJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXR0ZXN0LnRlc3QuanMubWFwIl19