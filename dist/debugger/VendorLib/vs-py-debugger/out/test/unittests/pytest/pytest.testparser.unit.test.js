// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const chai_1 = require("chai");

const chaipromise = require("chai-as-promised");

const typeMoq = require("typemoq");

const types_1 = require("../../../client/common/application/types");

const platform_1 = require("../../../client/common/utils/platform");

const testUtils_1 = require("../../../client/unittests/common/testUtils");

const flatteningVisitor_1 = require("../../../client/unittests/common/testVisitors/flatteningVisitor");

const parserService_1 = require("../../../client/unittests/pytest/services/parserService");

const pytest_unittest_parser_data_1 = require("./pytest_unittest_parser_data");

chai_1.use(chaipromise); // The PyTest test parsing is done via the stdout result of the
// `pytest --collect-only` command.
//
// There are a few limitations with this approach, the largest issue is mixing
// package and non-package style codebases (stdout does not give subdir
// information of tests in a package when __init__.py is not present).
//
// However, to test all of the various layouts that are available, we have
// created a JSON structure that defines all the tests - see file
// `pytest_unittest_parser_data.ts` in this folder.

suite('Unit Tests - PyTest - Test Parser used in discovery', () => {
  // Build tests for the test data that is relevant for this platform.
  const testPlatformType = platform_1.getOSType() === platform_1.OSType.Windows ? pytest_unittest_parser_data_1.PytestDataPlatformType.Windows : pytest_unittest_parser_data_1.PytestDataPlatformType.NonWindows;
  pytest_unittest_parser_data_1.pytestScenarioData.forEach(testScenario => {
    if (testPlatformType === testScenario.platform) {
      const testDescription = `PyTest${testScenario.pytest_version_spec}: ${testScenario.description}`;
      test(testDescription, () => __awaiter(void 0, void 0, void 0, function* () {
        // Setup the service container for use by the parser.
        const serviceContainer = typeMoq.Mock.ofType();
        const appShell = typeMoq.Mock.ofType();
        const cmdMgr = typeMoq.Mock.ofType();
        serviceContainer.setup(s => s.get(typeMoq.It.isValue(types_1.IApplicationShell), typeMoq.It.isAny())).returns(() => {
          return appShell.object;
        });
        serviceContainer.setup(s => s.get(typeMoq.It.isValue(types_1.ICommandManager), typeMoq.It.isAny())).returns(() => {
          return cmdMgr.object;
        }); // Create mocks used in the test discovery setup.

        const outChannel = typeMoq.Mock.ofType();
        const cancelToken = typeMoq.Mock.ofType();
        cancelToken.setup(c => c.isCancellationRequested).returns(() => false);
        const wsFolder = typeMoq.Mock.ofType(); // Create the test options for the mocked-up test. All data is either
        // mocked or is taken from the JSON test data itself.

        const options = {
          args: [],
          cwd: testScenario.rootdir,
          ignoreCache: true,
          outChannel: outChannel.object,
          token: cancelToken.object,
          workspaceFolder: wsFolder.object
        }; // Setup the parser.

        const testFlattener = new flatteningVisitor_1.TestFlatteningVisitor();
        const testHlp = new testUtils_1.TestsHelper(testFlattener, serviceContainer.object);
        const parser = new parserService_1.TestsParser(testHlp); // Each test scenario has a 'stdout' member that is an array of
        // stdout lines. Join them here such that the parser can operate
        // on stdout-like data.

        const stdout = testScenario.stdout.join('\n');
        const parsedTests = parser.parse(stdout, options); // Now we can actually perform tests.

        chai_1.expect(parsedTests).is.not.equal(undefined, 'Should have gotten tests extracted from the parsed pytest result content.');
        chai_1.expect(parsedTests.testFunctions.length).equals(testScenario.functionCount, `Parsed pytest summary contained ${testScenario.functionCount} test functions.`);
        testScenario.test_functions.forEach(funcName => {
          const findAllTests = parsedTests.testFunctions.filter(tstFunc => {
            return tstFunc.testFunction.nameToRun === funcName;
          }); // Each test identified in the testScenario should exist once and only once.

          chai_1.expect(findAllTests).is.not.equal(undefined, `Could not find "${funcName}" in tests.`);
          chai_1.expect(findAllTests.length).is.equal(1, 'There should be exactly one instance of each test.');
        });
      }));
    }
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInB5dGVzdC50ZXN0cGFyc2VyLnVuaXQudGVzdC5qcyJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInZhbHVlIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiY2hhaV8xIiwicmVxdWlyZSIsImNoYWlwcm9taXNlIiwidHlwZU1vcSIsInR5cGVzXzEiLCJwbGF0Zm9ybV8xIiwidGVzdFV0aWxzXzEiLCJmbGF0dGVuaW5nVmlzaXRvcl8xIiwicGFyc2VyU2VydmljZV8xIiwicHl0ZXN0X3VuaXR0ZXN0X3BhcnNlcl9kYXRhXzEiLCJ1c2UiLCJzdWl0ZSIsInRlc3RQbGF0Zm9ybVR5cGUiLCJnZXRPU1R5cGUiLCJPU1R5cGUiLCJXaW5kb3dzIiwiUHl0ZXN0RGF0YVBsYXRmb3JtVHlwZSIsIk5vbldpbmRvd3MiLCJweXRlc3RTY2VuYXJpb0RhdGEiLCJmb3JFYWNoIiwidGVzdFNjZW5hcmlvIiwicGxhdGZvcm0iLCJ0ZXN0RGVzY3JpcHRpb24iLCJweXRlc3RfdmVyc2lvbl9zcGVjIiwiZGVzY3JpcHRpb24iLCJ0ZXN0Iiwic2VydmljZUNvbnRhaW5lciIsIk1vY2siLCJvZlR5cGUiLCJhcHBTaGVsbCIsImNtZE1nciIsInNldHVwIiwicyIsImdldCIsIkl0IiwiaXNWYWx1ZSIsIklBcHBsaWNhdGlvblNoZWxsIiwiaXNBbnkiLCJyZXR1cm5zIiwib2JqZWN0IiwiSUNvbW1hbmRNYW5hZ2VyIiwib3V0Q2hhbm5lbCIsImNhbmNlbFRva2VuIiwiYyIsImlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwid3NGb2xkZXIiLCJvcHRpb25zIiwiYXJncyIsImN3ZCIsInJvb3RkaXIiLCJpZ25vcmVDYWNoZSIsInRva2VuIiwid29ya3NwYWNlRm9sZGVyIiwidGVzdEZsYXR0ZW5lciIsIlRlc3RGbGF0dGVuaW5nVmlzaXRvciIsInRlc3RIbHAiLCJUZXN0c0hlbHBlciIsInBhcnNlciIsIlRlc3RzUGFyc2VyIiwic3Rkb3V0Iiwiam9pbiIsInBhcnNlZFRlc3RzIiwicGFyc2UiLCJleHBlY3QiLCJpcyIsIm5vdCIsImVxdWFsIiwidW5kZWZpbmVkIiwidGVzdEZ1bmN0aW9ucyIsImxlbmd0aCIsImVxdWFscyIsImZ1bmN0aW9uQ291bnQiLCJ0ZXN0X2Z1bmN0aW9ucyIsImZ1bmNOYW1lIiwiZmluZEFsbFRlc3RzIiwiZmlsdGVyIiwidHN0RnVuYyIsInRlc3RGdW5jdGlvbiIsIm5hbWVUb1J1biJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBLElBQUlBLFNBQVMsR0FBSSxVQUFRLFNBQUtBLFNBQWQsSUFBNEIsVUFBVUMsT0FBVixFQUFtQkMsVUFBbkIsRUFBK0JDLENBQS9CLEVBQWtDQyxTQUFsQyxFQUE2QztBQUNyRixTQUFPLEtBQUtELENBQUMsS0FBS0EsQ0FBQyxHQUFHRSxPQUFULENBQU4sRUFBeUIsVUFBVUMsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7QUFDdkQsYUFBU0MsU0FBVCxDQUFtQkMsS0FBbkIsRUFBMEI7QUFBRSxVQUFJO0FBQUVDLFFBQUFBLElBQUksQ0FBQ04sU0FBUyxDQUFDTyxJQUFWLENBQWVGLEtBQWYsQ0FBRCxDQUFKO0FBQThCLE9BQXBDLENBQXFDLE9BQU9HLENBQVAsRUFBVTtBQUFFTCxRQUFBQSxNQUFNLENBQUNLLENBQUQsQ0FBTjtBQUFZO0FBQUU7O0FBQzNGLGFBQVNDLFFBQVQsQ0FBa0JKLEtBQWxCLEVBQXlCO0FBQUUsVUFBSTtBQUFFQyxRQUFBQSxJQUFJLENBQUNOLFNBQVMsQ0FBQyxPQUFELENBQVQsQ0FBbUJLLEtBQW5CLENBQUQsQ0FBSjtBQUFrQyxPQUF4QyxDQUF5QyxPQUFPRyxDQUFQLEVBQVU7QUFBRUwsUUFBQUEsTUFBTSxDQUFDSyxD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Q0MsS0FBbkMsQ0FBeUNDLFNBQXpDLEVBQXFELG1CQUFrQk0sUUFBUyxhQUFoRjtBQUNBekUsVUFBQUEsTUFBTSxDQUFDK0QsTUFBUCxDQUFjVyxZQUFZLENBQUNMLE1BQTNCLEVBQW1DTCxFQUFuQyxDQUFzQ0UsS0FBdEMsQ0FBNEMsQ0FBNUMsRUFBK0Msb0RBQS9DO0FBQ0gsU0FQRDtBQVFILE9BaERvQyxDQUFqQyxDQUFKO0FBaURIO0FBQ0osR0FyREQ7QUFzREgsQ0ExREksQ0FBTCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjaGFpXzEgPSByZXF1aXJlKFwiY2hhaVwiKTtcclxuY29uc3QgY2hhaXByb21pc2UgPSByZXF1aXJlKFwiY2hhaS1hcy1wcm9taXNlZFwiKTtcclxuY29uc3QgdHlwZU1vcSA9IHJlcXVpcmUoXCJ0eXBlbW9xXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vYXBwbGljYXRpb24vdHlwZXNcIik7XHJcbmNvbnN0IHBsYXRmb3JtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi91dGlscy9wbGF0Zm9ybVwiKTtcclxuY29uc3QgdGVzdFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy9jb21tb24vdGVzdFV0aWxzXCIpO1xyXG5jb25zdCBmbGF0dGVuaW5nVmlzaXRvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC91bml0dGVzdHMvY29tbW9uL3Rlc3RWaXNpdG9ycy9mbGF0dGVuaW5nVmlzaXRvclwiKTtcclxuY29uc3QgcGFyc2VyU2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC91bml0dGVzdHMvcHl0ZXN0L3NlcnZpY2VzL3BhcnNlclNlcnZpY2VcIik7XHJcbmNvbnN0IHB5dGVzdF91bml0dGVzdF9wYXJzZXJfZGF0YV8xID0gcmVxdWlyZShcIi4vcHl0ZXN0X3VuaXR0ZXN0X3BhcnNlcl9kYXRhXCIpO1xyXG5jaGFpXzEudXNlKGNoYWlwcm9taXNlKTtcclxuLy8gVGhlIFB5VGVzdCB0ZXN0IHBhcnNpbmcgaXMgZG9uZSB2aWEgdGhlIHN0ZG91dCByZXN1bHQgb2YgdGhlXHJcbi8vIGBweXRlc3QgLS1jb2xsZWN0LW9ubHlgIGNvbW1hbmQuXHJcbi8vXHJcbi8vIFRoZXJlIGFyZSBhIGZldyBsaW1pdGF0aW9ucyB3aXRoIHRoaXMgYXBwcm9hY2gsIHRoZSBsYXJnZXN0IGlzc3VlIGlzIG1peGluZ1xyXG4vLyBwYWNrYWdlIGFuZCBub24tcGFja2FnZSBzdHlsZSBjb2RlYmFzZXMgKHN0ZG91dCBkb2VzIG5vdCBnaXZlIHN1YmRpclxyXG4vLyBpbmZvcm1hdGlvbiBvZiB0ZXN0cyBpbiBhIHBhY2thZ2Ugd2hlbiBfX2luaXRfXy5weSBpcyBub3QgcHJlc2VudCkuXHJcbi8vXHJcbi8vIEhvd2V2ZXIsIHRvIHRlc3QgYWxsIG9mIHRoZSB2YXJpb3VzIGxheW91dHMgdGhhdCBhcmUgYXZhaWxhYmxlLCB3ZSBoYXZlXHJcbi8vIGNyZWF0ZWQgYSBKU09OIHN0cnVjdHVyZSB0aGF0IGRlZmluZXMgYWxsIHRoZSB0ZXN0cyAtIHNlZSBmaWxlXHJcbi8vIGBweXRlc3RfdW5pdHRlc3RfcGFyc2VyX2RhdGEudHNgIGluIHRoaXMgZm9sZGVyLlxyXG5zdWl0ZSgnVW5pdCBUZXN0cyAtIFB5VGVzdCAtIFRlc3QgUGFyc2VyIHVzZWQgaW4gZGlzY292ZXJ5JywgKCkgPT4ge1xyXG4gICAgLy8gQnVpbGQgdGVzdHMgZm9yIHRoZSB0ZXN0IGRhdGEgdGhhdCBpcyByZWxldmFudCBmb3IgdGhpcyBwbGF0Zm9ybS5cclxuICAgIGNvbnN0IHRlc3RQbGF0Zm9ybVR5cGUgPSBwbGF0Zm9ybV8xLmdldE9TVHlwZSgpID09PSBwbGF0Zm9ybV8xLk9TVHlwZS5XaW5kb3dzID9cclxuICAgICAgICBweXRlc3RfdW5pdHRlc3RfcGFyc2VyX2RhdGFfMS5QeXRlc3REYXRhUGxhdGZvcm1UeXBlLldpbmRvd3MgOiBweXRlc3RfdW5pdHRlc3RfcGFyc2VyX2RhdGFfMS5QeXRlc3REYXRhUGxhdGZvcm1UeXBlLk5vbldpbmRvd3M7XHJcbiAgICBweXRlc3RfdW5pdHRlc3RfcGFyc2VyX2RhdGFfMS5weXRlc3RTY2VuYXJpb0RhdGEuZm9yRWFjaCgodGVzdFNjZW5hcmlvKSA9PiB7XHJcbiAgICAgICAgaWYgKHRlc3RQbGF0Zm9ybVR5cGUgPT09IHRlc3RTY2VuYXJpby5wbGF0Zm9ybSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXN0RGVzY3JpcHRpb24gPSBgUHlUZXN0JHt0ZXN0U2NlbmFyaW8ucHl0ZXN0X3ZlcnNpb25fc3BlY306ICR7dGVzdFNjZW5hcmlvLmRlc2NyaXB0aW9ufWA7XHJcbiAgICAgICAgICAgIHRlc3QodGVzdERlc2NyaXB0aW9uLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXR1cCB0aGUgc2VydmljZSBjb250YWluZXIgZm9yIHVzZSBieSB0aGUgcGFyc2VyLlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmljZUNvbnRhaW5lciA9IHR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcFNoZWxsID0gdHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY21kTWdyID0gdHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgc2VydmljZUNvbnRhaW5lci5zZXR1cChzID0+IHMuZ2V0KHR5cGVNb3EuSXQuaXNWYWx1ZSh0eXBlc18xLklBcHBsaWNhdGlvblNoZWxsKSwgdHlwZU1vcS5JdC5pc0FueSgpKSlcclxuICAgICAgICAgICAgICAgICAgICAucmV0dXJucygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcFNoZWxsLm9iamVjdDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc2VydmljZUNvbnRhaW5lci5zZXR1cChzID0+IHMuZ2V0KHR5cGVNb3EuSXQuaXNWYWx1ZSh0eXBlc18xLklDb21tYW5kTWFuYWdlciksIHR5cGVNb3EuSXQuaXNBbnkoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJldHVybnMoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbWRNZ3Iub2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbW9ja3MgdXNlZCBpbiB0aGUgdGVzdCBkaXNjb3Zlcnkgc2V0dXAuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRDaGFubmVsID0gdHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsVG9rZW4gPSB0eXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxUb2tlbi5zZXR1cChjID0+IGMuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpLnJldHVybnMoKCkgPT4gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd3NGb2xkZXIgPSB0eXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRlc3Qgb3B0aW9ucyBmb3IgdGhlIG1vY2tlZC11cCB0ZXN0LiBBbGwgZGF0YSBpcyBlaXRoZXJcclxuICAgICAgICAgICAgICAgIC8vIG1vY2tlZCBvciBpcyB0YWtlbiBmcm9tIHRoZSBKU09OIHRlc3QgZGF0YSBpdHNlbGYuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGN3ZDogdGVzdFNjZW5hcmlvLnJvb3RkaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlQ2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Q2hhbm5lbDogb3V0Q2hhbm5lbC5vYmplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IGNhbmNlbFRva2VuLm9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICB3b3Jrc3BhY2VGb2xkZXI6IHdzRm9sZGVyLm9iamVjdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIFNldHVwIHRoZSBwYXJzZXIuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0RmxhdHRlbmVyID0gbmV3IGZsYXR0ZW5pbmdWaXNpdG9yXzEuVGVzdEZsYXR0ZW5pbmdWaXNpdG9yKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SGxwID0gbmV3IHRlc3RVdGlsc18xLlRlc3RzSGVscGVyKHRlc3RGbGF0dGVuZXIsIHNlcnZpY2VDb250YWluZXIub2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBwYXJzZXJTZXJ2aWNlXzEuVGVzdHNQYXJzZXIodGVzdEhscCk7XHJcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHRlc3Qgc2NlbmFyaW8gaGFzIGEgJ3N0ZG91dCcgbWVtYmVyIHRoYXQgaXMgYW4gYXJyYXkgb2ZcclxuICAgICAgICAgICAgICAgIC8vIHN0ZG91dCBsaW5lcy4gSm9pbiB0aGVtIGhlcmUgc3VjaCB0aGF0IHRoZSBwYXJzZXIgY2FuIG9wZXJhdGVcclxuICAgICAgICAgICAgICAgIC8vIG9uIHN0ZG91dC1saWtlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGRvdXQgPSB0ZXN0U2NlbmFyaW8uc3Rkb3V0LmpvaW4oJ1xcbicpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVGVzdHMgPSBwYXJzZXIucGFyc2Uoc3Rkb3V0LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBjYW4gYWN0dWFsbHkgcGVyZm9ybSB0ZXN0cy5cclxuICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QocGFyc2VkVGVzdHMpLmlzLm5vdC5lcXVhbCh1bmRlZmluZWQsICdTaG91bGQgaGF2ZSBnb3R0ZW4gdGVzdHMgZXh0cmFjdGVkIGZyb20gdGhlIHBhcnNlZCBweXRlc3QgcmVzdWx0IGNvbnRlbnQuJyk7XHJcbiAgICAgICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHBhcnNlZFRlc3RzLnRlc3RGdW5jdGlvbnMubGVuZ3RoKS5lcXVhbHModGVzdFNjZW5hcmlvLmZ1bmN0aW9uQ291bnQsIGBQYXJzZWQgcHl0ZXN0IHN1bW1hcnkgY29udGFpbmVkICR7dGVzdFNjZW5hcmlvLmZ1bmN0aW9uQ291bnR9IHRlc3QgZnVuY3Rpb25zLmApO1xyXG4gICAgICAgICAgICAgICAgdGVzdFNjZW5hcmlvLnRlc3RfZnVuY3Rpb25zLmZvckVhY2goKGZ1bmNOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluZEFsbFRlc3RzID0gcGFyc2VkVGVzdHMudGVzdEZ1bmN0aW9ucy5maWx0ZXIoKHRzdEZ1bmMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRzdEZ1bmMudGVzdEZ1bmN0aW9uLm5hbWVUb1J1biA9PT0gZnVuY05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCB0ZXN0IGlkZW50aWZpZWQgaW4gdGhlIHRlc3RTY2VuYXJpbyBzaG91bGQgZXhpc3Qgb25jZSBhbmQgb25seSBvbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QoZmluZEFsbFRlc3RzKS5pcy5ub3QuZXF1YWwodW5kZWZpbmVkLCBgQ291bGQgbm90IGZpbmQgXCIke2Z1bmNOYW1lfVwiIGluIHRlc3RzLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QoZmluZEFsbFRlc3RzLmxlbmd0aCkuaXMuZXF1YWwoMSwgJ1RoZXJlIHNob3VsZCBiZSBleGFjdGx5IG9uZSBpbnN0YW5jZSBvZiBlYWNoIHRlc3QuJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHl0ZXN0LnRlc3RwYXJzZXIudW5pdC50ZXN0LmpzLm1hcCJdfQ==