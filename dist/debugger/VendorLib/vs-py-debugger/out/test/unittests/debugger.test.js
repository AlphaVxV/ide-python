"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const chai_1 = require("chai");

const chaiAsPromised = require("chai-as-promised");

const path = require("path");

const vscode_1 = require("vscode");

const async_1 = require("../../client/common/utils/async");

const runner_1 = require("../../client/unittests//nosetest/runner");

const runner_2 = require("../../client/unittests//pytest/runner");

const runner_3 = require("../../client/unittests//unittest/runner");

const argumentsHelper_1 = require("../../client/unittests/common/argumentsHelper");

const constants_1 = require("../../client/unittests/common/constants");

const runner_4 = require("../../client/unittests/common/runner");

const types_1 = require("../../client/unittests/common/types");

const xUnitParser_1 = require("../../client/unittests/common/xUnitParser");

const argsService_1 = require("../../client/unittests/nosetest/services/argsService");

const argsService_2 = require("../../client/unittests/pytest/services/argsService");

const types_2 = require("../../client/unittests/types");

const helper_1 = require("../../client/unittests/unittest/helper");

const argsService_3 = require("../../client/unittests/unittest/services/argsService");

const common_1 = require("../common");

const initialize_1 = require("./../initialize");

const mocks_1 = require("./mocks");

const serviceRegistry_1 = require("./serviceRegistry");

chai_1.use(chaiAsPromised);
const testFilesPath = path.join(__dirname, '..', '..', '..', 'src', 'test', 'pythonFiles', 'testFiles', 'debuggerTest');
const defaultUnitTestArgs = ['-v', '-s', '.', '-p', '*test*.py']; // tslint:disable-next-line:max-func-body-length

suite('Unit Tests - debugging', () => {
  let ioc;
  const configTarget = initialize_1.IS_MULTI_ROOT_TEST ? vscode_1.ConfigurationTarget.WorkspaceFolder : vscode_1.ConfigurationTarget.Workspace;
  suiteSetup(() => __awaiter(void 0, void 0, void 0, function* () {
    // Test disvovery is where the delay is, hence give 10 seconds (as we discover tests at least twice in each test).
    yield initialize_1.initialize();
    yield common_1.updateSetting('unitTest.unittestArgs', defaultUnitTestArgs, common_1.rootWorkspaceUri, configTarget);
    yield common_1.updateSetting('unitTest.nosetestArgs', [], common_1.rootWorkspaceUri, configTarget);
    yield common_1.updateSetting('unitTest.pyTestArgs', [], common_1.rootWorkspaceUri, configTarget);
  }));
  setup(() => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.deleteDirectory(path.join(testFilesPath, '.cache'));
    yield initialize_1.initializeTest();
    initializeDI();
  }));
  teardown(() => __awaiter(void 0, void 0, void 0, function* () {
    ioc.dispose();
    yield common_1.updateSetting('unitTest.unittestArgs', defaultUnitTestArgs, common_1.rootWorkspaceUri, configTarget);
    yield common_1.updateSetting('unitTest.nosetestArgs', [], common_1.rootWorkspaceUri, configTarget);
    yield common_1.updateSetting('unitTest.pyTestArgs', [], common_1.rootWorkspaceUri, configTarget);
  }));

  function initializeDI() {
    ioc = new serviceRegistry_1.UnitTestIocContainer();
    ioc.registerCommonTypes();
    ioc.registerProcessTypes();
    ioc.registerVariableTypes();
    ioc.registerTestParsers();
    ioc.registerTestVisitors();
    ioc.registerTestDiscoveryServices();
    ioc.registerTestResultsHelper();
    ioc.registerTestStorage();
    ioc.registerTestsHelper();
    ioc.registerTestManagers();
    ioc.registerMockUnitTestSocketServer();
    ioc.serviceManager.add(types_2.IArgumentsHelper, argumentsHelper_1.ArgumentsHelper);
    ioc.serviceManager.add(types_1.ITestRunner, runner_4.TestRunner);
    ioc.serviceManager.add(types_1.IXUnitParser, xUnitParser_1.XUnitParser);
    ioc.serviceManager.add(types_2.IUnitTestHelper, helper_1.UnitTestHelper);
    ioc.serviceManager.add(types_2.IArgumentsService, argsService_1.ArgumentsService, constants_1.NOSETEST_PROVIDER);
    ioc.serviceManager.add(types_2.IArgumentsService, argsService_2.ArgumentsService, constants_1.PYTEST_PROVIDER);
    ioc.serviceManager.add(types_2.IArgumentsService, argsService_3.ArgumentsService, constants_1.UNITTEST_PROVIDER);
    ioc.serviceManager.add(types_2.ITestManagerRunner, runner_2.TestManagerRunner, constants_1.PYTEST_PROVIDER);
    ioc.serviceManager.add(types_2.ITestManagerRunner, runner_1.TestManagerRunner, constants_1.NOSETEST_PROVIDER);
    ioc.serviceManager.add(types_2.ITestManagerRunner, runner_3.TestManagerRunner, constants_1.UNITTEST_PROVIDER);
    ioc.serviceManager.addSingleton(types_1.ITestDebugLauncher, mocks_1.MockDebugLauncher);
  }

  function testStartingDebugger(testProvider) {
    return __awaiter(this, void 0, void 0, function* () {
      const testManager = ioc.serviceContainer.get(types_1.ITestManagerFactory)(testProvider, common_1.rootWorkspaceUri, testFilesPath);
      const mockDebugLauncher = ioc.serviceContainer.get(types_1.ITestDebugLauncher);
      const tests = yield testManager.discoverTests(constants_1.CommandSource.commandPalette, true, true);
      chai_1.assert.equal(tests.testFiles.length, 2, 'Incorrect number of test files');
      chai_1.assert.equal(tests.testFunctions.length, 2, 'Incorrect number of test functions');
      chai_1.assert.equal(tests.testSuites.length, 2, 'Incorrect number of test suites');
      const deferred = async_1.createDeferred();
      const testFunction = [tests.testFunctions[0].testFunction];
      const runningPromise = testManager.runTest(constants_1.CommandSource.commandPalette, {
        testFunction
      }, false, true); // This promise should never resolve nor reject.

      runningPromise.then(() => deferred.reject('Debugger stopped when it shouldn\'t have')).catch(error => deferred.reject(error));
      mockDebugLauncher.launched.then(launched => {
        if (launched) {
          deferred.resolve('');
        } else {
          deferred.reject('Debugger not launched');
        }
      }).catch(error => deferred.reject(error));
      yield deferred.promise;
    });
  }

  test('Debugger should start (unittest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.unittestArgs', ['-s=./tests', '-p=test_*.py'], common_1.rootWorkspaceUri, configTarget);
    yield testStartingDebugger('unittest');
  }));
  test('Debugger should start (pytest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.pyTestArgs', ['-k=test_'], common_1.rootWorkspaceUri, configTarget);
    yield testStartingDebugger('pytest');
  }));
  test('Debugger should start (nosetest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.nosetestArgs', ['-m', 'test'], common_1.rootWorkspaceUri, configTarget);
    yield testStartingDebugger('nosetest');
  }));

  function testStoppingDebugger(testProvider) {
    return __awaiter(this, void 0, void 0, function* () {
      const testManager = ioc.serviceContainer.get(types_1.ITestManagerFactory)(testProvider, common_1.rootWorkspaceUri, testFilesPath);
      const mockDebugLauncher = ioc.serviceContainer.get(types_1.ITestDebugLauncher);
      const tests = yield testManager.discoverTests(constants_1.CommandSource.commandPalette, true, true);
      chai_1.assert.equal(tests.testFiles.length, 2, 'Incorrect number of test files');
      chai_1.assert.equal(tests.testFunctions.length, 2, 'Incorrect number of test functions');
      chai_1.assert.equal(tests.testSuites.length, 2, 'Incorrect number of test suites');
      const testFunction = [tests.testFunctions[0].testFunction];
      const runningPromise = testManager.runTest(constants_1.CommandSource.commandPalette, {
        testFunction
      }, false, true);
      const launched = yield mockDebugLauncher.launched;
      chai_1.assert.isTrue(launched, 'Debugger not launched');
      const discoveryPromise = testManager.discoverTests(constants_1.CommandSource.commandPalette, true, true, true);
      yield chai_1.expect(runningPromise).to.be.rejectedWith(constants_1.CANCELLATION_REASON, 'Incorrect reason for ending the debugger');
      ioc.dispose(); // will cancel test discovery

      yield chai_1.expect(discoveryPromise).to.be.rejectedWith(constants_1.CANCELLATION_REASON, 'Incorrect reason for ending the debugger');
    });
  }

  test('Debugger should stop when user invokes a test discovery (unittest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.unittestArgs', ['-s=./tests', '-p=test_*.py'], common_1.rootWorkspaceUri, configTarget);
    yield testStoppingDebugger('unittest');
  }));
  test('Debugger should stop when user invokes a test discovery (pytest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.pyTestArgs', ['-k=test_'], common_1.rootWorkspaceUri, configTarget);
    yield testStoppingDebugger('pytest');
  }));
  test('Debugger should stop when user invokes a test discovery (nosetest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.nosetestArgs', ['-m', 'test'], common_1.rootWorkspaceUri, configTarget);
    yield testStoppingDebugger('nosetest');
  }));

  function testDebuggerWhenRediscoveringTests(testProvider) {
    return __awaiter(this, void 0, void 0, function* () {
      const testManager = ioc.serviceContainer.get(types_1.ITestManagerFactory)(testProvider, common_1.rootWorkspaceUri, testFilesPath);
      const mockDebugLauncher = ioc.serviceContainer.get(types_1.ITestDebugLauncher);
      const tests = yield testManager.discoverTests(constants_1.CommandSource.commandPalette, true, true);
      chai_1.assert.equal(tests.testFiles.length, 2, 'Incorrect number of test files');
      chai_1.assert.equal(tests.testFunctions.length, 2, 'Incorrect number of test functions');
      chai_1.assert.equal(tests.testSuites.length, 2, 'Incorrect number of test suites');
      const testFunction = [tests.testFunctions[0].testFunction];
      const runningPromise = testManager.runTest(constants_1.CommandSource.commandPalette, {
        testFunction
      }, false, true);
      const launched = yield mockDebugLauncher.launched;
      chai_1.assert.isTrue(launched, 'Debugger not launched');
      const discoveryPromise = testManager.discoverTests(constants_1.CommandSource.commandPalette, false, true);
      const deferred = async_1.createDeferred();
      discoveryPromise // tslint:disable-next-line:no-unsafe-any
      .then(() => deferred.resolve('')) // tslint:disable-next-line:no-unsafe-any
      .catch(ex => deferred.reject(ex)); // This promise should never resolve nor reject.

      runningPromise.then(() => 'Debugger stopped when it shouldn\'t have').catch(() => 'Debugger crashed when it shouldn\'t have') // tslint:disable-next-line: no-floating-promises
      .then(error => {
        deferred.reject(error);
      }); // Should complete without any errors

      yield deferred.promise;
    });
  }

  test('Debugger should not stop when test discovery is invoked automatically by extension (unittest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.unittestArgs', ['-s=./tests', '-p=test_*.py'], common_1.rootWorkspaceUri, configTarget);
    yield testDebuggerWhenRediscoveringTests('unittest');
  }));
  test('Debugger should not stop when test discovery is invoked automatically by extension (pytest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.pyTestArgs', ['-k=test_'], common_1.rootWorkspaceUri, configTarget);
    yield testDebuggerWhenRediscoveringTests('pytest');
  }));
  test('Debugger should not stop when test discovery is invoked automatically by extension (nosetest)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('unitTest.nosetestArgs', ['-m', 'test'], common_1.rootWorkspaceUri, configTarget);
    yield testDebuggerWhenRediscoveringTests('nosetest');
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlYnVnZ2VyLnRlc3QuanMiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImNoYWlfMSIsInJlcXVpcmUiLCJjaGFpQXNQcm9taXNlZCIsInBhdGgiLCJ2c2NvZGVfMSIsImFzeW5jXzEiLCJydW5uZXJfMSIsInJ1bm5lcl8yIiwicnVubmVyXzMiLCJhcmd1bWVudHNIZWxwZXJfMSIsImNvbnN0YW50c18xIiwicnVubmVyXzQiLCJ0eXBlc18xIiwieFVuaXRQYXJzZXJfMSIsImFyZ3NTZXJ2aWNlXzEiLCJhcmdzU2VydmljZV8yIiwidHlwZXNfMiIsImhlbHBlcl8xIiwiYXJnc1NlcnZpY2VfMyIsImNvbW1vbl8xIiwiaW5pdGlhbGl6ZV8xIiwibW9ja3NfMSIsInNlcnZpY2VSZWdpc3RyeV8xIiwidXNlIiwidGVzdEZpbGVzUGF0aCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJkZWZhdWx0VW5pdFRlc3RBcmdzIiwic3VpdGUiLCJpb2MiLCJjb25maWdUYXJnZXQiLCJJU19NVUxUSV9ST09UX1RFU1QiLCJDb25maWd1cmF0aW9uVGFyZ2V0IiwiV29ya3NwYWNlRm9sZGVyIiwiV29ya3NwYWNlIiwic3VpdGVTZXR1cCIsImluaXRpYWxpemUiLCJ1cGRhdGVTZXR0aW5nIiwicm9vdFdvcmtzcGFjZVVyaSIsInNldHVwIiwiZGVsZXRlRGlyZWN0b3J5IiwiaW5pdGlhbGl6ZVRlc3QiLCJpbml0aWFsaXplREkiLCJ0ZWFyZG93biIsImRpc3Bvc2UiLCJVbml0VGVzdElvY0NvbnRhaW5lciIsInJlZ2lzdGVyQ29tbW9uVHlwZXMiLCJyZWdpc3RlclByb2Nlc3NUeXBlcyIsInJlZ2lzdGVyVmFyaWFibGVUeXBlcyIsInJlZ2lzdGVyVGVzdFBhcnNlcnMiLCJyZWdpc3RlclRlc3RWaXNpdG9ycyIsInJlZ2lzdGVyVGVzdERpc2NvdmVyeVNlcnZpY2VzIiwicmVnaXN0ZXJUZXN0UmVzdWx0c0hlbHBlciIsInJlZ2lzdGVyVGVzdFN0b3JhZ2UiLCJyZWdpc3RlclRlc3RzSGVscGVyIiwicmVnaXN0ZXJUZXN0TWFuYWdlcnMiLCJyZWdpc3Rlck1vY2tVbml0VGVzdFNvY2tldFNlcnZlciIsInNlcnZpY2VNYW5hZ2VyIiwiYWRkIiwiSUFyZ3VtZW50c0hlbHBlciIsIkFyZ3VtZW50c0hlbHBlciIsIklUZXN0UnVubmVyIiwiVGVzdFJ1bm5lciIsIklYVW5pdFBhcnNlciIsIlhVbml0UGFyc2VyIiwiSVVuaXRUZXN0SGVscGVyIiwiVW5pdFRlc3RIZWxwZXIiLCJJQXJndW1lbnRzU2VydmljZSIsIkFyZ3VtZW50c1NlcnZpY2UiLCJOT1NFVEVTVF9QUk9WSURFUiIsIlBZVEVTVF9QUk9WSURFUiIsIlVOSVRURVNUX1BST1ZJREVSIiwiSVRlc3RNYW5hZ2VyUnVubmVyIiwiVGVzdE1hbmFnZXJSdW5uZXIiLCJhZGRTaW5nbGV0b24iLCJJVGVzdERlYnVnTGF1bmNoZXIiLCJNb2NrRGVidWdMYXVuY2hlciIsInRlc3RTdGFydGluZ0RlYnVnZ2VyIiwidGVzdFByb3ZpZGVyIiwidGVzdE1hbmFnZXIiLCJzZXJ2aWNlQ29udGFpbmVyIiwiZ2V0IiwiSVRlc3RNYW5hZ2VyRmFjdG9yeSIsIm1vY2tEZWJ1Z0xhdW5jaGVyIiwidGVzdHMiLCJkaXNjb3ZlclRlc3RzIiwiQ29tbWFuZFNvdXJjZSIsImNvbW1hbmRQYWxldHRlIiwiYXNzZXJ0IiwiZXF1YWwiLCJ0ZXN0RmlsZXMiLCJsZW5ndGgiLCJ0ZXN0RnVuY3Rpb25zIiwidGVzdFN1aXRlcyIsImRlZmVycmVkIiwiY3JlYXRlRGVmZXJyZWQiLCJ0ZXN0RnVuY3Rpb24iLCJydW5uaW5nUHJvbWlzZSIsInJ1blRlc3QiLCJjYXRjaCIsImVycm9yIiwibGF1bmNoZWQiLCJwcm9taXNlIiwidGVzdCIsInRlc3RTdG9wcGluZ0RlYnVnZ2VyIiwiaXNUcnVlIiwiZGlzY292ZXJ5UHJvbWlzZSIsImV4cGVjdCIsInRvIiwiYmUiLCJyZWplY3RlZFdpdGgiLCJDQU5DRUxMQVRJT05fUkVBU09OIiwidGVzdERlYnVnZ2VyV2hlblJlZGlzY292ZXJpbmdUZXN0cyIsImV4Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxTQUFTLEdBQUksVUFBUSxTQUFLQSxTQUFkLElBQTRCLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxDQUEvQixFQUFrQ0MsU0FBbEMsRUFBNkM7QUFDckYsU0FBTyxLQUFLRCxDQUFDLEtBQUtBLENBQUMsR0FBR0UsT0FBVCxDQUFOLEVBQXlCLFVBQVVDLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTJCO0FBQ3ZELGFBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO0FBQUUsVUFBSTtBQUFFQyxRQUFBQSxJQUFJLENBQUNOLFNBQVMsQ0FBQ08sSUFBVixDQUFlRixLQUFmLENBQUQsQ0FBSjtBQUE4QixPQUFwQyxDQUFxQyxPQUFPRyxDQUFQLEVBQVU7QUFBRUwsUUFBQUEsTUFBTSxDQUFDSyxDQUFELENBQU47QUFBWTtBQUFFOztBQUMzRixhQUFTQyxRQUFULENBQWtCSixLQUFsQixFQUF5QjtBQUFFLFVBQUk7QUFBRUMsUUFBQUEsSUFBSSxDQUFDTixTQUFTLENBQUMsT0FBRCxDQUFULENBQW1CSyxLQUFuQixDQUFELENBQUo7QUFBa0MsT0FBeEMsQ0FBeUMsT0FBT0csQ0FBUCxFQUFVO0FBQUVMLFFBQUFBLE1BQU0sQ0FBQ0ssQ0FBRCxDQUFOO0FBQVk7QUFBRTs7QUFDOUYsYUFBU0YsSUFBVCxDQUFjSSxNQUFkLEVBQXNCO0FBQUVBLE1BQUFBLE1BQU0sQ0FBQ0MsSUFBUCxHQUFjVCxPQUFPLENBQUNRLE1BQU0sQ0FBQ0wsS0FBUixDQUFyQixHQUFzQyxJQUFJTixDQUFKLENBQU0sVUFB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QywrRkFBRCxFQUFrRyxNQUFNNUgsU0FBUyxTQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsYUFBYTtBQUNySixVQUFNd0MsUUFBUSxDQUFDa0IsYUFBVCxDQUF1Qix1QkFBdkIsRUFBZ0QsQ0FBQyxZQUFELEVBQWUsY0FBZixDQUFoRCxFQUFnRmxCLFFBQVEsQ0FBQ21CLGdCQUF6RixFQUEyR1IsWUFBM0csQ0FBTjtBQUNBLFVBQU1rRixrQ0FBa0MsQ0FBQyxVQUFELENBQXhDO0FBQ0gsR0FIb0gsQ0FBakgsQ0FBSjtBQUlBVCxFQUFBQSxJQUFJLENBQUMsNkZBQUQsRUFBZ0csTUFBTTVILFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDbkosVUFBTXdDLFFBQVEsQ0FBQ2tCLGFBQVQsQ0FBdUIscUJBQXZCLEVBQThDLENBQUMsVUFBRCxDQUE5QyxFQUE0RGxCLFFBQVEsQ0FBQ21CLGdCQUFyRSxFQUF1RlIsWUFBdkYsQ0FBTjtBQUNBLFVBQU1rRixrQ0FBa0MsQ0FBQyxRQUFELENBQXhDO0FBQ0gsR0FIa0gsQ0FBL0csQ0FBSjtBQUlBVCxFQUFBQSxJQUFJLENBQUMsK0ZBQUQsRUFBa0csTUFBTTVILFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDckosVUFBTXdDLFFBQVEsQ0FBQ2tCLGFBQVQsQ0FBdUIsdUJBQXZCLEVBQWdELENBQUMsSUFBRCxFQUFPLE1BQVAsQ0FBaEQsRUFBZ0VsQixRQUFRLENBQUNtQixnQkFBekUsRUFBMkZSLFlBQTNGLENBQU47QUFDQSxVQUFNa0Ysa0NBQWtDLENBQUMsVUFBRCxDQUF4QztBQUNILEdBSG9ILENBQWpILENBQUo7QUFJSCxDQTlKSSxDQUFMIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY2hhaV8xID0gcmVxdWlyZShcImNoYWlcIik7XHJcbmNvbnN0IGNoYWlBc1Byb21pc2VkID0gcmVxdWlyZShcImNoYWktYXMtcHJvbWlzZWRcIik7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCBhc3luY18xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vdXRpbHMvYXN5bmNcIik7XHJcbmNvbnN0IHJ1bm5lcl8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC91bml0dGVzdHMvL25vc2V0ZXN0L3J1bm5lclwiKTtcclxuY29uc3QgcnVubmVyXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy8vcHl0ZXN0L3J1bm5lclwiKTtcclxuY29uc3QgcnVubmVyXzMgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy8vdW5pdHRlc3QvcnVubmVyXCIpO1xyXG5jb25zdCBhcmd1bWVudHNIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnQvdW5pdHRlc3RzL2NvbW1vbi9hcmd1bWVudHNIZWxwZXJcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC91bml0dGVzdHMvY29tbW9uL2NvbnN0YW50c1wiKTtcclxuY29uc3QgcnVubmVyXzQgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy9jb21tb24vcnVubmVyXCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC91bml0dGVzdHMvY29tbW9uL3R5cGVzXCIpO1xyXG5jb25zdCB4VW5pdFBhcnNlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC91bml0dGVzdHMvY29tbW9uL3hVbml0UGFyc2VyXCIpO1xyXG5jb25zdCBhcmdzU2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC91bml0dGVzdHMvbm9zZXRlc3Qvc2VydmljZXMvYXJnc1NlcnZpY2VcIik7XHJcbmNvbnN0IGFyZ3NTZXJ2aWNlXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy9weXRlc3Qvc2VydmljZXMvYXJnc1NlcnZpY2VcIik7XHJcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy90eXBlc1wiKTtcclxuY29uc3QgaGVscGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy91bml0dGVzdC9oZWxwZXJcIik7XHJcbmNvbnN0IGFyZ3NTZXJ2aWNlXzMgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy91bml0dGVzdC9zZXJ2aWNlcy9hcmdzU2VydmljZVwiKTtcclxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xyXG5jb25zdCBpbml0aWFsaXplXzEgPSByZXF1aXJlKFwiLi8uLi9pbml0aWFsaXplXCIpO1xyXG5jb25zdCBtb2Nrc18xID0gcmVxdWlyZShcIi4vbW9ja3NcIik7XHJcbmNvbnN0IHNlcnZpY2VSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vc2VydmljZVJlZ2lzdHJ5XCIpO1xyXG5jaGFpXzEudXNlKGNoYWlBc1Byb21pc2VkKTtcclxuY29uc3QgdGVzdEZpbGVzUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICcuLicsICcuLicsICdzcmMnLCAndGVzdCcsICdweXRob25GaWxlcycsICd0ZXN0RmlsZXMnLCAnZGVidWdnZXJUZXN0Jyk7XHJcbmNvbnN0IGRlZmF1bHRVbml0VGVzdEFyZ3MgPSBbXHJcbiAgICAnLXYnLFxyXG4gICAgJy1zJyxcclxuICAgICcuJyxcclxuICAgICctcCcsXHJcbiAgICAnKnRlc3QqLnB5J1xyXG5dO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWZ1bmMtYm9keS1sZW5ndGhcclxuc3VpdGUoJ1VuaXQgVGVzdHMgLSBkZWJ1Z2dpbmcnLCAoKSA9PiB7XHJcbiAgICBsZXQgaW9jO1xyXG4gICAgY29uc3QgY29uZmlnVGFyZ2V0ID0gaW5pdGlhbGl6ZV8xLklTX01VTFRJX1JPT1RfVEVTVCA/IHZzY29kZV8xLkNvbmZpZ3VyYXRpb25UYXJnZXQuV29ya3NwYWNlRm9sZGVyIDogdnNjb2RlXzEuQ29uZmlndXJhdGlvblRhcmdldC5Xb3Jrc3BhY2U7XHJcbiAgICBzdWl0ZVNldHVwKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBUZXN0IGRpc3ZvdmVyeSBpcyB3aGVyZSB0aGUgZGVsYXkgaXMsIGhlbmNlIGdpdmUgMTAgc2Vjb25kcyAoYXMgd2UgZGlzY292ZXIgdGVzdHMgYXQgbGVhc3QgdHdpY2UgaW4gZWFjaCB0ZXN0KS5cclxuICAgICAgICB5aWVsZCBpbml0aWFsaXplXzEuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLnVwZGF0ZVNldHRpbmcoJ3VuaXRUZXN0LnVuaXR0ZXN0QXJncycsIGRlZmF1bHRVbml0VGVzdEFyZ3MsIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIGNvbmZpZ1RhcmdldCk7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3Qubm9zZXRlc3RBcmdzJywgW10sIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIGNvbmZpZ1RhcmdldCk7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3QucHlUZXN0QXJncycsIFtdLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCBjb25maWdUYXJnZXQpO1xyXG4gICAgfSkpO1xyXG4gICAgc2V0dXAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLmRlbGV0ZURpcmVjdG9yeShwYXRoLmpvaW4odGVzdEZpbGVzUGF0aCwgJy5jYWNoZScpKTtcclxuICAgICAgICB5aWVsZCBpbml0aWFsaXplXzEuaW5pdGlhbGl6ZVRlc3QoKTtcclxuICAgICAgICBpbml0aWFsaXplREkoKTtcclxuICAgIH0pKTtcclxuICAgIHRlYXJkb3duKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpb2MuZGlzcG9zZSgpO1xyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLnVwZGF0ZVNldHRpbmcoJ3VuaXRUZXN0LnVuaXR0ZXN0QXJncycsIGRlZmF1bHRVbml0VGVzdEFyZ3MsIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIGNvbmZpZ1RhcmdldCk7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3Qubm9zZXRlc3RBcmdzJywgW10sIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIGNvbmZpZ1RhcmdldCk7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3QucHlUZXN0QXJncycsIFtdLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCBjb25maWdUYXJnZXQpO1xyXG4gICAgfSkpO1xyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZURJKCkge1xyXG4gICAgICAgIGlvYyA9IG5ldyBzZXJ2aWNlUmVnaXN0cnlfMS5Vbml0VGVzdElvY0NvbnRhaW5lcigpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlckNvbW1vblR5cGVzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyUHJvY2Vzc1R5cGVzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyVmFyaWFibGVUeXBlcygpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlclRlc3RQYXJzZXJzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyVGVzdFZpc2l0b3JzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyVGVzdERpc2NvdmVyeVNlcnZpY2VzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyVGVzdFJlc3VsdHNIZWxwZXIoKTtcclxuICAgICAgICBpb2MucmVnaXN0ZXJUZXN0U3RvcmFnZSgpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlclRlc3RzSGVscGVyKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyVGVzdE1hbmFnZXJzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyTW9ja1VuaXRUZXN0U29ja2V0U2VydmVyKCk7XHJcbiAgICAgICAgaW9jLnNlcnZpY2VNYW5hZ2VyLmFkZCh0eXBlc18yLklBcmd1bWVudHNIZWxwZXIsIGFyZ3VtZW50c0hlbHBlcl8xLkFyZ3VtZW50c0hlbHBlcik7XHJcbiAgICAgICAgaW9jLnNlcnZpY2VNYW5hZ2VyLmFkZCh0eXBlc18xLklUZXN0UnVubmVyLCBydW5uZXJfNC5UZXN0UnVubmVyKTtcclxuICAgICAgICBpb2Muc2VydmljZU1hbmFnZXIuYWRkKHR5cGVzXzEuSVhVbml0UGFyc2VyLCB4VW5pdFBhcnNlcl8xLlhVbml0UGFyc2VyKTtcclxuICAgICAgICBpb2Muc2VydmljZU1hbmFnZXIuYWRkKHR5cGVzXzIuSVVuaXRUZXN0SGVscGVyLCBoZWxwZXJfMS5Vbml0VGVzdEhlbHBlcik7XHJcbiAgICAgICAgaW9jLnNlcnZpY2VNYW5hZ2VyLmFkZCh0eXBlc18yLklBcmd1bWVudHNTZXJ2aWNlLCBhcmdzU2VydmljZV8xLkFyZ3VtZW50c1NlcnZpY2UsIGNvbnN0YW50c18xLk5PU0VURVNUX1BST1ZJREVSKTtcclxuICAgICAgICBpb2Muc2VydmljZU1hbmFnZXIuYWRkKHR5cGVzXzIuSUFyZ3VtZW50c1NlcnZpY2UsIGFyZ3NTZXJ2aWNlXzIuQXJndW1lbnRzU2VydmljZSwgY29uc3RhbnRzXzEuUFlURVNUX1BST1ZJREVSKTtcclxuICAgICAgICBpb2Muc2VydmljZU1hbmFnZXIuYWRkKHR5cGVzXzIuSUFyZ3VtZW50c1NlcnZpY2UsIGFyZ3NTZXJ2aWNlXzMuQXJndW1lbnRzU2VydmljZSwgY29uc3RhbnRzXzEuVU5JVFRFU1RfUFJPVklERVIpO1xyXG4gICAgICAgIGlvYy5zZXJ2aWNlTWFuYWdlci5hZGQodHlwZXNfMi5JVGVzdE1hbmFnZXJSdW5uZXIsIHJ1bm5lcl8yLlRlc3RNYW5hZ2VyUnVubmVyLCBjb25zdGFudHNfMS5QWVRFU1RfUFJPVklERVIpO1xyXG4gICAgICAgIGlvYy5zZXJ2aWNlTWFuYWdlci5hZGQodHlwZXNfMi5JVGVzdE1hbmFnZXJSdW5uZXIsIHJ1bm5lcl8xLlRlc3RNYW5hZ2VyUnVubmVyLCBjb25zdGFudHNfMS5OT1NFVEVTVF9QUk9WSURFUik7XHJcbiAgICAgICAgaW9jLnNlcnZpY2VNYW5hZ2VyLmFkZCh0eXBlc18yLklUZXN0TWFuYWdlclJ1bm5lciwgcnVubmVyXzMuVGVzdE1hbmFnZXJSdW5uZXIsIGNvbnN0YW50c18xLlVOSVRURVNUX1BST1ZJREVSKTtcclxuICAgICAgICBpb2Muc2VydmljZU1hbmFnZXIuYWRkU2luZ2xldG9uKHR5cGVzXzEuSVRlc3REZWJ1Z0xhdW5jaGVyLCBtb2Nrc18xLk1vY2tEZWJ1Z0xhdW5jaGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRlc3RTdGFydGluZ0RlYnVnZ2VyKHRlc3RQcm92aWRlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RNYW5hZ2VyID0gaW9jLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSVRlc3RNYW5hZ2VyRmFjdG9yeSkodGVzdFByb3ZpZGVyLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCB0ZXN0RmlsZXNQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0RlYnVnTGF1bmNoZXIgPSBpb2Muc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JVGVzdERlYnVnTGF1bmNoZXIpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IHlpZWxkIHRlc3RNYW5hZ2VyLmRpc2NvdmVyVGVzdHMoY29uc3RhbnRzXzEuQ29tbWFuZFNvdXJjZS5jb21tYW5kUGFsZXR0ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5hc3NlcnQuZXF1YWwodGVzdHMudGVzdEZpbGVzLmxlbmd0aCwgMiwgJ0luY29ycmVjdCBudW1iZXIgb2YgdGVzdCBmaWxlcycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuYXNzZXJ0LmVxdWFsKHRlc3RzLnRlc3RGdW5jdGlvbnMubGVuZ3RoLCAyLCAnSW5jb3JyZWN0IG51bWJlciBvZiB0ZXN0IGZ1bmN0aW9ucycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuYXNzZXJ0LmVxdWFsKHRlc3RzLnRlc3RTdWl0ZXMubGVuZ3RoLCAyLCAnSW5jb3JyZWN0IG51bWJlciBvZiB0ZXN0IHN1aXRlcycpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IGFzeW5jXzEuY3JlYXRlRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdEZ1bmN0aW9uID0gW3Rlc3RzLnRlc3RGdW5jdGlvbnNbMF0udGVzdEZ1bmN0aW9uXTtcclxuICAgICAgICAgICAgY29uc3QgcnVubmluZ1Byb21pc2UgPSB0ZXN0TWFuYWdlci5ydW5UZXN0KGNvbnN0YW50c18xLkNvbW1hbmRTb3VyY2UuY29tbWFuZFBhbGV0dGUsIHsgdGVzdEZ1bmN0aW9uIH0sIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgLy8gVGhpcyBwcm9taXNlIHNob3VsZCBuZXZlciByZXNvbHZlIG5vciByZWplY3QuXHJcbiAgICAgICAgICAgIHJ1bm5pbmdQcm9taXNlXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBkZWZlcnJlZC5yZWplY3QoJ0RlYnVnZ2VyIHN0b3BwZWQgd2hlbiBpdCBzaG91bGRuXFwndCBoYXZlJykpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gZGVmZXJyZWQucmVqZWN0KGVycm9yKSk7XHJcbiAgICAgICAgICAgIG1vY2tEZWJ1Z0xhdW5jaGVyLmxhdW5jaGVkXHJcbiAgICAgICAgICAgICAgICAudGhlbigobGF1bmNoZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXVuY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdEZWJ1Z2dlciBub3QgbGF1bmNoZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gZGVmZXJyZWQucmVqZWN0KGVycm9yKSk7XHJcbiAgICAgICAgICAgIHlpZWxkIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0ZXN0KCdEZWJ1Z2dlciBzaG91bGQgc3RhcnQgKHVuaXR0ZXN0KScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC51bml0dGVzdEFyZ3MnLCBbJy1zPS4vdGVzdHMnLCAnLXA9dGVzdF8qLnB5J10sIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIGNvbmZpZ1RhcmdldCk7XHJcbiAgICAgICAgeWllbGQgdGVzdFN0YXJ0aW5nRGVidWdnZXIoJ3VuaXR0ZXN0Jyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdEZWJ1Z2dlciBzaG91bGQgc3RhcnQgKHB5dGVzdCknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3QucHlUZXN0QXJncycsIFsnLWs9dGVzdF8nXSwgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgY29uZmlnVGFyZ2V0KTtcclxuICAgICAgICB5aWVsZCB0ZXN0U3RhcnRpbmdEZWJ1Z2dlcigncHl0ZXN0Jyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdEZWJ1Z2dlciBzaG91bGQgc3RhcnQgKG5vc2V0ZXN0KScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC5ub3NldGVzdEFyZ3MnLCBbJy1tJywgJ3Rlc3QnXSwgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgY29uZmlnVGFyZ2V0KTtcclxuICAgICAgICB5aWVsZCB0ZXN0U3RhcnRpbmdEZWJ1Z2dlcignbm9zZXRlc3QnKTtcclxuICAgIH0pKTtcclxuICAgIGZ1bmN0aW9uIHRlc3RTdG9wcGluZ0RlYnVnZ2VyKHRlc3RQcm92aWRlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RNYW5hZ2VyID0gaW9jLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSVRlc3RNYW5hZ2VyRmFjdG9yeSkodGVzdFByb3ZpZGVyLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCB0ZXN0RmlsZXNQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0RlYnVnTGF1bmNoZXIgPSBpb2Muc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JVGVzdERlYnVnTGF1bmNoZXIpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IHlpZWxkIHRlc3RNYW5hZ2VyLmRpc2NvdmVyVGVzdHMoY29uc3RhbnRzXzEuQ29tbWFuZFNvdXJjZS5jb21tYW5kUGFsZXR0ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5hc3NlcnQuZXF1YWwodGVzdHMudGVzdEZpbGVzLmxlbmd0aCwgMiwgJ0luY29ycmVjdCBudW1iZXIgb2YgdGVzdCBmaWxlcycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuYXNzZXJ0LmVxdWFsKHRlc3RzLnRlc3RGdW5jdGlvbnMubGVuZ3RoLCAyLCAnSW5jb3JyZWN0IG51bWJlciBvZiB0ZXN0IGZ1bmN0aW9ucycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuYXNzZXJ0LmVxdWFsKHRlc3RzLnRlc3RTdWl0ZXMubGVuZ3RoLCAyLCAnSW5jb3JyZWN0IG51bWJlciBvZiB0ZXN0IHN1aXRlcycpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXN0RnVuY3Rpb24gPSBbdGVzdHMudGVzdEZ1bmN0aW9uc1swXS50ZXN0RnVuY3Rpb25dO1xyXG4gICAgICAgICAgICBjb25zdCBydW5uaW5nUHJvbWlzZSA9IHRlc3RNYW5hZ2VyLnJ1blRlc3QoY29uc3RhbnRzXzEuQ29tbWFuZFNvdXJjZS5jb21tYW5kUGFsZXR0ZSwgeyB0ZXN0RnVuY3Rpb24gfSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBjb25zdCBsYXVuY2hlZCA9IHlpZWxkIG1vY2tEZWJ1Z0xhdW5jaGVyLmxhdW5jaGVkO1xyXG4gICAgICAgICAgICBjaGFpXzEuYXNzZXJ0LmlzVHJ1ZShsYXVuY2hlZCwgJ0RlYnVnZ2VyIG5vdCBsYXVuY2hlZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXNjb3ZlcnlQcm9taXNlID0gdGVzdE1hbmFnZXIuZGlzY292ZXJUZXN0cyhjb25zdGFudHNfMS5Db21tYW5kU291cmNlLmNvbW1hbmRQYWxldHRlLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgeWllbGQgY2hhaV8xLmV4cGVjdChydW5uaW5nUHJvbWlzZSkudG8uYmUucmVqZWN0ZWRXaXRoKGNvbnN0YW50c18xLkNBTkNFTExBVElPTl9SRUFTT04sICdJbmNvcnJlY3QgcmVhc29uIGZvciBlbmRpbmcgdGhlIGRlYnVnZ2VyJyk7XHJcbiAgICAgICAgICAgIGlvYy5kaXNwb3NlKCk7IC8vIHdpbGwgY2FuY2VsIHRlc3QgZGlzY292ZXJ5XHJcbiAgICAgICAgICAgIHlpZWxkIGNoYWlfMS5leHBlY3QoZGlzY292ZXJ5UHJvbWlzZSkudG8uYmUucmVqZWN0ZWRXaXRoKGNvbnN0YW50c18xLkNBTkNFTExBVElPTl9SRUFTT04sICdJbmNvcnJlY3QgcmVhc29uIGZvciBlbmRpbmcgdGhlIGRlYnVnZ2VyJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0ZXN0KCdEZWJ1Z2dlciBzaG91bGQgc3RvcCB3aGVuIHVzZXIgaW52b2tlcyBhIHRlc3QgZGlzY292ZXJ5ICh1bml0dGVzdCknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3QudW5pdHRlc3RBcmdzJywgWyctcz0uL3Rlc3RzJywgJy1wPXRlc3RfKi5weSddLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCBjb25maWdUYXJnZXQpO1xyXG4gICAgICAgIHlpZWxkIHRlc3RTdG9wcGluZ0RlYnVnZ2VyKCd1bml0dGVzdCcpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnRGVidWdnZXIgc2hvdWxkIHN0b3Agd2hlbiB1c2VyIGludm9rZXMgYSB0ZXN0IGRpc2NvdmVyeSAocHl0ZXN0KScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC5weVRlc3RBcmdzJywgWyctaz10ZXN0XyddLCBjb21tb25fMS5yb290V29ya3NwYWNlVXJpLCBjb25maWdUYXJnZXQpO1xyXG4gICAgICAgIHlpZWxkIHRlc3RTdG9wcGluZ0RlYnVnZ2VyKCdweXRlc3QnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0RlYnVnZ2VyIHNob3VsZCBzdG9wIHdoZW4gdXNlciBpbnZva2VzIGEgdGVzdCBkaXNjb3ZlcnkgKG5vc2V0ZXN0KScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC5ub3NldGVzdEFyZ3MnLCBbJy1tJywgJ3Rlc3QnXSwgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgY29uZmlnVGFyZ2V0KTtcclxuICAgICAgICB5aWVsZCB0ZXN0U3RvcHBpbmdEZWJ1Z2dlcignbm9zZXRlc3QnKTtcclxuICAgIH0pKTtcclxuICAgIGZ1bmN0aW9uIHRlc3REZWJ1Z2dlcldoZW5SZWRpc2NvdmVyaW5nVGVzdHModGVzdFByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgdGVzdE1hbmFnZXIgPSBpb2Muc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JVGVzdE1hbmFnZXJGYWN0b3J5KSh0ZXN0UHJvdmlkZXIsIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIHRlc3RGaWxlc1BhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrRGVidWdMYXVuY2hlciA9IGlvYy5zZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18xLklUZXN0RGVidWdMYXVuY2hlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzID0geWllbGQgdGVzdE1hbmFnZXIuZGlzY292ZXJUZXN0cyhjb25zdGFudHNfMS5Db21tYW5kU291cmNlLmNvbW1hbmRQYWxldHRlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgY2hhaV8xLmFzc2VydC5lcXVhbCh0ZXN0cy50ZXN0RmlsZXMubGVuZ3RoLCAyLCAnSW5jb3JyZWN0IG51bWJlciBvZiB0ZXN0IGZpbGVzJyk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5hc3NlcnQuZXF1YWwodGVzdHMudGVzdEZ1bmN0aW9ucy5sZW5ndGgsIDIsICdJbmNvcnJlY3QgbnVtYmVyIG9mIHRlc3QgZnVuY3Rpb25zJyk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5hc3NlcnQuZXF1YWwodGVzdHMudGVzdFN1aXRlcy5sZW5ndGgsIDIsICdJbmNvcnJlY3QgbnVtYmVyIG9mIHRlc3Qgc3VpdGVzJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RGdW5jdGlvbiA9IFt0ZXN0cy50ZXN0RnVuY3Rpb25zWzBdLnRlc3RGdW5jdGlvbl07XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmdQcm9taXNlID0gdGVzdE1hbmFnZXIucnVuVGVzdChjb25zdGFudHNfMS5Db21tYW5kU291cmNlLmNvbW1hbmRQYWxldHRlLCB7IHRlc3RGdW5jdGlvbiB9LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhdW5jaGVkID0geWllbGQgbW9ja0RlYnVnTGF1bmNoZXIubGF1bmNoZWQ7XHJcbiAgICAgICAgICAgIGNoYWlfMS5hc3NlcnQuaXNUcnVlKGxhdW5jaGVkLCAnRGVidWdnZXIgbm90IGxhdW5jaGVkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyeVByb21pc2UgPSB0ZXN0TWFuYWdlci5kaXNjb3ZlclRlc3RzKGNvbnN0YW50c18xLkNvbW1hbmRTb3VyY2UuY29tbWFuZFBhbGV0dGUsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBhc3luY18xLmNyZWF0ZURlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIGRpc2NvdmVyeVByb21pc2VcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnNhZmUtYW55XHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBkZWZlcnJlZC5yZXNvbHZlKCcnKSlcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnNhZmUtYW55XHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXggPT4gZGVmZXJyZWQucmVqZWN0KGV4KSk7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgcHJvbWlzZSBzaG91bGQgbmV2ZXIgcmVzb2x2ZSBub3IgcmVqZWN0LlxyXG4gICAgICAgICAgICBydW5uaW5nUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gJ0RlYnVnZ2VyIHN0b3BwZWQgd2hlbiBpdCBzaG91bGRuXFwndCBoYXZlJylcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiAnRGVidWdnZXIgY3Jhc2hlZCB3aGVuIGl0IHNob3VsZG5cXCd0IGhhdmUnKVxyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgICAgICAgICAgLnRoZW4oZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIFNob3VsZCBjb21wbGV0ZSB3aXRob3V0IGFueSBlcnJvcnNcclxuICAgICAgICAgICAgeWllbGQgZGVmZXJyZWQucHJvbWlzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRlc3QoJ0RlYnVnZ2VyIHNob3VsZCBub3Qgc3RvcCB3aGVuIHRlc3QgZGlzY292ZXJ5IGlzIGludm9rZWQgYXV0b21hdGljYWxseSBieSBleHRlbnNpb24gKHVuaXR0ZXN0KScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC51bml0dGVzdEFyZ3MnLCBbJy1zPS4vdGVzdHMnLCAnLXA9dGVzdF8qLnB5J10sIGNvbW1vbl8xLnJvb3RXb3Jrc3BhY2VVcmksIGNvbmZpZ1RhcmdldCk7XHJcbiAgICAgICAgeWllbGQgdGVzdERlYnVnZ2VyV2hlblJlZGlzY292ZXJpbmdUZXN0cygndW5pdHRlc3QnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0RlYnVnZ2VyIHNob3VsZCBub3Qgc3RvcCB3aGVuIHRlc3QgZGlzY292ZXJ5IGlzIGludm9rZWQgYXV0b21hdGljYWxseSBieSBleHRlbnNpb24gKHB5dGVzdCknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygndW5pdFRlc3QucHlUZXN0QXJncycsIFsnLWs9dGVzdF8nXSwgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgY29uZmlnVGFyZ2V0KTtcclxuICAgICAgICB5aWVsZCB0ZXN0RGVidWdnZXJXaGVuUmVkaXNjb3ZlcmluZ1Rlc3RzKCdweXRlc3QnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0RlYnVnZ2VyIHNob3VsZCBub3Qgc3RvcCB3aGVuIHRlc3QgZGlzY292ZXJ5IGlzIGludm9rZWQgYXV0b21hdGljYWxseSBieSBleHRlbnNpb24gKG5vc2V0ZXN0KScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCd1bml0VGVzdC5ub3NldGVzdEFyZ3MnLCBbJy1tJywgJ3Rlc3QnXSwgY29tbW9uXzEucm9vdFdvcmtzcGFjZVVyaSwgY29uZmlnVGFyZ2V0KTtcclxuICAgICAgICB5aWVsZCB0ZXN0RGVidWdnZXJXaGVuUmVkaXNjb3ZlcmluZ1Rlc3RzKCdub3NldGVzdCcpO1xyXG4gICAgfSkpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWdnZXIudGVzdC5qcy5tYXAiXX0=