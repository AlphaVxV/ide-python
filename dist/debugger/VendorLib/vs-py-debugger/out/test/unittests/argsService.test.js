// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
}); // tslint:disable:max-func-body-length

const assert_1 = require("assert");

const chai_1 = require("chai");

const child_process_1 = require("child_process");

const typeMoq = require("typemoq");

const types_1 = require("../../client/common/types");

const enum_1 = require("../../client/common/utils/enum");

const argumentsHelper_1 = require("../../client/unittests/common/argumentsHelper");

const argsService_1 = require("../../client/unittests/nosetest/services/argsService");

const argsService_2 = require("../../client/unittests/pytest/services/argsService");

const types_2 = require("../../client/unittests/types");

const argsService_3 = require("../../client/unittests/unittest/services/argsService");

const common_1 = require("../common");

suite('ArgsService: Common', () => {
  [types_1.Product.unittest, types_1.Product.nosetest, types_1.Product.pytest].forEach(product => {
    const productNames = enum_1.getNamesAndValues(types_1.Product);
    const productName = productNames.find(item => item.value === product).name;
    suite(productName, () => {
      let argumentsService;
      let moduleName = '';
      let expectedWithArgs = [];
      let expectedWithoutArgs = [];
      setup(function () {
        // Take the spawning of process into account.
        // tslint:disable-next-line:no-invalid-this
        this.timeout(5000);
        const serviceContainer = typeMoq.Mock.ofType();
        const logger = typeMoq.Mock.ofType();
        serviceContainer.setup(s => s.get(typeMoq.It.isValue(types_1.ILogger), typeMoq.It.isAny())).returns(() => logger.object);
        const argsHelper = new argumentsHelper_1.ArgumentsHelper(serviceContainer.object);
        serviceContainer.setup(s => s.get(typeMoq.It.isValue(types_2.IArgumentsHelper), typeMoq.It.isAny())).returns(() => argsHelper);

        switch (product) {
          case types_1.Product.unittest:
            {
              argumentsService = new argsService_3.ArgumentsService(serviceContainer.object);
              moduleName = 'unittest';
              break;
            }

          case types_1.Product.nosetest:
            {
              argumentsService = new argsService_1.ArgumentsService(serviceContainer.object);
              moduleName = 'nose';
              break;
            }

          case types_1.Product.pytest:
            {
              moduleName = 'pytest';
              argumentsService = new argsService_2.ArgumentsService(serviceContainer.object);
              break;
            }

          default:
            {
              throw new Error('Unrecognized Test Framework');
            }
        }

        expectedWithArgs = getOptions(product, moduleName, true);
        expectedWithoutArgs = getOptions(product, moduleName, false);
      });
      test('Check for new/unrecognized options with values', () => {
        const options = argumentsService.getKnownOptions();
        const optionsNotFound = expectedWithArgs.filter(item => options.withArgs.indexOf(item) === -1);

        if (optionsNotFound.length > 0) {
          assert_1.fail('', optionsNotFound.join(', '), 'Options not found');
        }
      });
      test('Check for new/unrecognized options without values', () => {
        const options = argumentsService.getKnownOptions();
        const optionsNotFound = expectedWithoutArgs.filter(item => options.withoutArgs.indexOf(item) === -1);

        if (optionsNotFound.length > 0) {
          assert_1.fail('', optionsNotFound.join(', '), 'Options not found');
        }
      });
      test('Test getting value for an option with a single value', () => {
        for (const option of expectedWithArgs) {
          const args = ['--some-option-with-a-value', '1234', '--another-value-with-inline=1234', option, 'abcd'];
          const value = argumentsService.getOptionValue(args, option);
          chai_1.expect(value).to.equal('abcd');
        }
      });
      test('Test getting value for an option with a multiple value', () => {
        for (const option of expectedWithArgs) {
          const args = ['--some-option-with-a-value', '1234', '--another-value-with-inline=1234', option, 'abcd', option, 'xyz'];
          const value = argumentsService.getOptionValue(args, option);
          chai_1.expect(value).to.deep.equal(['abcd', 'xyz']);
        }
      });
      test('Test filtering of arguments', () => {
        const args = [];
        const knownOptions = argumentsService.getKnownOptions();
        const argumentsToRemove = [];
        const expectedFilteredArgs = []; // Generate some random arguments.

        for (let i = 0; i < 5; i += 1) {
          args.push(knownOptions.withArgs[i], `Random Value ${i}`);
          args.push(knownOptions.withoutArgs[i]);

          if (i % 2 === 0) {
            argumentsToRemove.push(knownOptions.withArgs[i], knownOptions.withoutArgs[i]);
          } else {
            expectedFilteredArgs.push(knownOptions.withArgs[i], `Random Value ${i}`);
            expectedFilteredArgs.push(knownOptions.withoutArgs[i]);
          }
        }

        const filteredArgs = argumentsService.filterArguments(args, argumentsToRemove);
        chai_1.expect(filteredArgs).to.be.deep.equal(expectedFilteredArgs);
      });
    });
  });
});

function getOptions(product, moduleName, withValues) {
  const result = child_process_1.spawnSync(common_1.PYTHON_PATH, ['-m', moduleName, '-h']);
  const output = result.stdout.toString(); // Our regex isn't the best, so lets exclude stuff that shouldn't be captured.

  const knownOptionsWithoutArgs = [];
  const knownOptionsWithArgs = [];

  if (product === types_1.Product.pytest) {
    knownOptionsWithArgs.push(...['-c', '-p', '-r']);
  }

  if (withValues) {
    return getOptionsWithArguments(output).concat(...knownOptionsWithArgs).filter(item => knownOptionsWithoutArgs.indexOf(item) === -1).sort();
  } else {
    return getOptionsWithoutArguments(output).concat(...knownOptionsWithoutArgs).filter(item => knownOptionsWithArgs.indexOf(item) === -1) // In pytest, any option begining with --log- is known to have args.
    .filter(item => product === types_1.Product.pytest ? !item.startsWith('--log-') : true).sort();
  }
}

function getOptionsWithoutArguments(output) {
  return getMatches('\\s{1,}(-{1,2}[A-Za-z0-9-]+)(?:,|\\s{2,})', output);
}

function getOptionsWithArguments(output) {
  return getMatches('\\s{1,}(-{1,2}[A-Za-z0-9-]+)(?:=|\\s{0,1}[A-Z])', output);
}

function getMatches(pattern, str) {
  const matches = [];
  const regex = new RegExp(pattern, 'gm');
  let result = regex.exec(str);

  while (result !== null) {
    if (result.index === regex.lastIndex) {
      regex.lastIndex += 1;
    }

    matches.push(result[1].trim());
    result = regex.exec(str);
  }

  return matches.sort().reduce((items, item) => items.indexOf(item) === -1 ? items.concat([item]) : items, []);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFyZ3NTZXJ2aWNlLnRlc3QuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhc3NlcnRfMSIsInJlcXVpcmUiLCJjaGFpXzEiLCJjaGlsZF9wcm9jZXNzXzEiLCJ0eXBlTW9xIiwidHlwZXNfMSIsImVudW1fMSIsImFyZ3VtZW50c0hlbHBlcl8xIiwiYXJnc1NlcnZpY2VfMSIsImFyZ3NTZXJ2aWNlXzIiLCJ0eXBlc18yIiwiYXJnc1NlcnZpY2VfMyIsImNvbW1vbl8xIiwic3VpdGUiLCJQcm9kdWN0IiwidW5pdHRlc3QiLCJub3NldGVzdCIsInB5dGVzdCIsImZvckVhY2giLCJwcm9kdWN0IiwicHJvZHVjdE5hbWVzIiwiZ2V0TmFtZXNBbmRWYWx1ZXMiLCJwcm9kdWN0TmFtZSIsImZpbmQiLCJpdGVtIiwibmFtZSIsImFyZ3VtZW50c1NlcnZpY2UiLCJtb2R1bGVOYW1lIiwiZXhwZWN0ZWRXaXRoQXJncyIsImV4cGVjdGVkV2l0aG91dEFyZ3MiLCJzZXR1cCIsInRpbWVvdXQiLCJzZXJ2aWNlQ29udGFpbmVyIiwiTW9jayIsIm9mVHlwZSIsImxvZ2dlciIsInMiLCJnZXQiLCJJdCIsImlzVmFsdWUiLCJJTG9nZ2VyIiwiaXNBbnkiLCJyZXR1cm5zIiwib2JqZWN0IiwiYXJnc0hlbHBlciIsIkFyZ3VtZW50c0hlbHBlciIsIklBcmd1bWVudHNIZWxwZXIiLCJBcmd1bWVudHNTZXJ2aWNlIiwiRXJyb3IiLCJnZXRPcHRpb25zIiwidGVzdCIsIm9wdGlvbnMiLCJnZXRLbm93bk9wdGlvbnMiLCJvcHRpb25zTm90Rm91bmQiLCJmaWx0ZXIiLCJ3aXRoQXJncyIsImluZGV4T2YiLCJsZW5ndGgiLCJmYWlsIiwiam9pbiIsIndpdGhvdXRBcmdzIiwib3B0aW9uIiwiYXJncyIsImdldE9wdGlvblZhbHVlIiwiZXhwZWN0IiwidG8iLCJlcXVhbCIsImRlZXAiLCJrbm93bk9wdGlvbnMiLCJhcmd1bWVudHNUb1JlbW92ZSIsImV4cGVjdGVkRmlsdGVyZWRBcmdzIiwiaSIsInB1c2giLCJmaWx0ZXJlZEFyZ3MiLCJmaWx0ZXJBcmd1bWVudHMiLCJiZSIsIndpdGhWYWx1ZXMiLCJyZXN1bHQiLCJzcGF3blN5bmMiLCJQWVRIT05fUEFUSCIsIm91dHB1dCIsInN0ZG91dCIsInRvU3RyaW5nIiwia25vd25PcHRpb25zV2l0aG91dEFyZ3MiLCJrbm93bk9wdGlvbnNXaXRoQXJncyIsImdldE9wdGlvbnNXaXRoQXJndW1lbnRzIiwiY29uY2F0Iiwic29ydCIsImdldE9wdGlvbnNXaXRob3V0QXJndW1lbnRzIiwic3RhcnRzV2l0aCIsImdldE1hdGNoZXMiLCJwYXR0ZXJuIiwic3RyIiwibWF0Y2hlcyIsInJlZ2V4IiwiUmVnRXhwIiwiZXhlYyIsImluZGV4IiwibGFzdEluZGV4IiwidHJpbSIsInJlZHVjZSIsIml0ZW1zIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBQ0FBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsRUFBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0MsRSxDQUNBOztBQUNBLE1BQU1DLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBeEI7O0FBQ0EsTUFBTUMsTUFBTSxHQUFHRCxPQUFPLENBQUMsTUFBRCxDQUF0Qjs7QUFDQSxNQUFNRSxlQUFlLEdBQUdGLE9BQU8sQ0FBQyxlQUFELENBQS9COztBQUNBLE1BQU1HLE9BQU8sR0FBR0gsT0FBTyxDQUFDLFNBQUQsQ0FBdkI7O0FBQ0EsTUFBTUksT0FBTyxHQUFHSixPQUFPLENBQUMsMkJBQUQsQ0FBdkI7O0FBQ0EsTUFBTUssTUFBTSxHQUFHTCxPQUFPLENBQUMsZ0NBQUQsQ0FBdEI7O0FBQ0EsTUFBTU0saUJBQWlCLEdBQUdOLE9BQU8sQ0FBQywrQ0FBRCxDQUFqQzs7QUFDQSxNQUFNTyxhQUFhLEdBQUdQLE9BQU8sQ0FBQyxzREFBRCxDQUE3Qjs7QUFDQSxNQUFNUSxhQUFhLEdBQUdS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S0FBaUI2RSxLQUFLLENBQUM3QyxPQUFOLENBQWNoQyxJQUFkLE1BQXdCLENBQUMsQ0FBekIsR0FBNkI2RSxLQUFLLENBQUNmLE1BQU4sQ0FBYSxDQUFDOUQsSUFBRCxDQUFiLENBQTdCLEdBQW9ENkUsS0FGMUUsRUFFaUYsRUFGakYsQ0FBUDtBQUdIIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHRzbGludDpkaXNhYmxlOm1heC1mdW5jLWJvZHktbGVuZ3RoXHJcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcImFzc2VydFwiKTtcclxuY29uc3QgY2hhaV8xID0gcmVxdWlyZShcImNoYWlcIik7XHJcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xyXG5jb25zdCB0eXBlTW9xID0gcmVxdWlyZShcInR5cGVtb3FcIik7XHJcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbW1vbi90eXBlc1wiKTtcclxuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vdXRpbHMvZW51bVwiKTtcclxuY29uc3QgYXJndW1lbnRzSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy9jb21tb24vYXJndW1lbnRzSGVscGVyXCIpO1xyXG5jb25zdCBhcmdzU2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC91bml0dGVzdHMvbm9zZXRlc3Qvc2VydmljZXMvYXJnc1NlcnZpY2VcIik7XHJcbmNvbnN0IGFyZ3NTZXJ2aWNlXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy9weXRlc3Qvc2VydmljZXMvYXJnc1NlcnZpY2VcIik7XHJcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L3VuaXR0ZXN0cy90eXBlc1wiKTtcclxuY29uc3QgYXJnc1NlcnZpY2VfMyA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnQvdW5pdHRlc3RzL3VuaXR0ZXN0L3NlcnZpY2VzL2FyZ3NTZXJ2aWNlXCIpO1xyXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XHJcbnN1aXRlKCdBcmdzU2VydmljZTogQ29tbW9uJywgKCkgPT4ge1xyXG4gICAgW3R5cGVzXzEuUHJvZHVjdC51bml0dGVzdCwgdHlwZXNfMS5Qcm9kdWN0Lm5vc2V0ZXN0LCB0eXBlc18xLlByb2R1Y3QucHl0ZXN0XVxyXG4gICAgICAgIC5mb3JFYWNoKHByb2R1Y3QgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByb2R1Y3ROYW1lcyA9IGVudW1fMS5nZXROYW1lc0FuZFZhbHVlcyh0eXBlc18xLlByb2R1Y3QpO1xyXG4gICAgICAgIGNvbnN0IHByb2R1Y3ROYW1lID0gcHJvZHVjdE5hbWVzLmZpbmQoaXRlbSA9PiBpdGVtLnZhbHVlID09PSBwcm9kdWN0KS5uYW1lO1xyXG4gICAgICAgIHN1aXRlKHByb2R1Y3ROYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhcmd1bWVudHNTZXJ2aWNlO1xyXG4gICAgICAgICAgICBsZXQgbW9kdWxlTmFtZSA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgZXhwZWN0ZWRXaXRoQXJncyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgZXhwZWN0ZWRXaXRob3V0QXJncyA9IFtdO1xyXG4gICAgICAgICAgICBzZXR1cChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBzcGF3bmluZyBvZiBwcm9jZXNzIGludG8gYWNjb3VudC5cclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRoaXNcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dCg1MDAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VDb250YWluZXIgPSB0eXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dnZXIgPSB0eXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBzZXJ2aWNlQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldHVwKHMgPT4gcy5nZXQodHlwZU1vcS5JdC5pc1ZhbHVlKHR5cGVzXzEuSUxvZ2dlciksIHR5cGVNb3EuSXQuaXNBbnkoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJldHVybnMoKCkgPT4gbG9nZ2VyLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzSGVscGVyID0gbmV3IGFyZ3VtZW50c0hlbHBlcl8xLkFyZ3VtZW50c0hlbHBlcihzZXJ2aWNlQ29udGFpbmVyLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZXJ2aWNlQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldHVwKHMgPT4gcy5nZXQodHlwZU1vcS5JdC5pc1ZhbHVlKHR5cGVzXzIuSUFyZ3VtZW50c0hlbHBlciksIHR5cGVNb3EuSXQuaXNBbnkoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJldHVybnMoKCkgPT4gYXJnc0hlbHBlcik7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb2R1Y3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuUHJvZHVjdC51bml0dGVzdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNTZXJ2aWNlID0gbmV3IGFyZ3NTZXJ2aWNlXzMuQXJndW1lbnRzU2VydmljZShzZXJ2aWNlQ29udGFpbmVyLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWUgPSAndW5pdHRlc3QnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLlByb2R1Y3Qubm9zZXRlc3Q6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzU2VydmljZSA9IG5ldyBhcmdzU2VydmljZV8xLkFyZ3VtZW50c1NlcnZpY2Uoc2VydmljZUNvbnRhaW5lci5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lID0gJ25vc2UnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLlByb2R1Y3QucHl0ZXN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWUgPSAncHl0ZXN0JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzU2VydmljZSA9IG5ldyBhcmdzU2VydmljZV8yLkFyZ3VtZW50c1NlcnZpY2Uoc2VydmljZUNvbnRhaW5lci5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBUZXN0IEZyYW1ld29yaycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkV2l0aEFyZ3MgPSBnZXRPcHRpb25zKHByb2R1Y3QsIG1vZHVsZU5hbWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRXaXRob3V0QXJncyA9IGdldE9wdGlvbnMocHJvZHVjdCwgbW9kdWxlTmFtZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGVzdCgnQ2hlY2sgZm9yIG5ldy91bnJlY29nbml6ZWQgb3B0aW9ucyB3aXRoIHZhbHVlcycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHNTZXJ2aWNlLmdldEtub3duT3B0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uc05vdEZvdW5kID0gZXhwZWN0ZWRXaXRoQXJncy5maWx0ZXIoaXRlbSA9PiBvcHRpb25zLndpdGhBcmdzLmluZGV4T2YoaXRlbSkgPT09IC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTm90Rm91bmQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydF8xLmZhaWwoJycsIG9wdGlvbnNOb3RGb3VuZC5qb2luKCcsICcpLCAnT3B0aW9ucyBub3QgZm91bmQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRlc3QoJ0NoZWNrIGZvciBuZXcvdW5yZWNvZ25pemVkIG9wdGlvbnMgd2l0aG91dCB2YWx1ZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzU2VydmljZS5nZXRLbm93bk9wdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNOb3RGb3VuZCA9IGV4cGVjdGVkV2l0aG91dEFyZ3MuZmlsdGVyKGl0ZW0gPT4gb3B0aW9ucy53aXRob3V0QXJncy5pbmRleE9mKGl0ZW0pID09PSAtMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc05vdEZvdW5kLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRfMS5mYWlsKCcnLCBvcHRpb25zTm90Rm91bmQuam9pbignLCAnKSwgJ09wdGlvbnMgbm90IGZvdW5kJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0ZXN0KCdUZXN0IGdldHRpbmcgdmFsdWUgZm9yIGFuIG9wdGlvbiB3aXRoIGEgc2luZ2xlIHZhbHVlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZXhwZWN0ZWRXaXRoQXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbJy0tc29tZS1vcHRpb24td2l0aC1hLXZhbHVlJywgJzEyMzQnLCAnLS1hbm90aGVyLXZhbHVlLXdpdGgtaW5saW5lPTEyMzQnLCBvcHRpb24sICdhYmNkJ107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmd1bWVudHNTZXJ2aWNlLmdldE9wdGlvblZhbHVlKGFyZ3MsIG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhaV8xLmV4cGVjdCh2YWx1ZSkudG8uZXF1YWwoJ2FiY2QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRlc3QoJ1Rlc3QgZ2V0dGluZyB2YWx1ZSBmb3IgYW4gb3B0aW9uIHdpdGggYSBtdWx0aXBsZSB2YWx1ZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGV4cGVjdGVkV2l0aEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gWyctLXNvbWUtb3B0aW9uLXdpdGgtYS12YWx1ZScsICcxMjM0JywgJy0tYW5vdGhlci12YWx1ZS13aXRoLWlubGluZT0xMjM0Jywgb3B0aW9uLCAnYWJjZCcsIG9wdGlvbiwgJ3h5eiddO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJndW1lbnRzU2VydmljZS5nZXRPcHRpb25WYWx1ZShhcmdzLCBvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFsdWUpLnRvLmRlZXAuZXF1YWwoWydhYmNkJywgJ3h5eiddKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRlc3QoJ1Rlc3QgZmlsdGVyaW5nIG9mIGFyZ3VtZW50cycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtub3duT3B0aW9ucyA9IGFyZ3VtZW50c1NlcnZpY2UuZ2V0S25vd25PcHRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcmd1bWVudHNUb1JlbW92ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRGaWx0ZXJlZEFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHNvbWUgcmFuZG9tIGFyZ3VtZW50cy5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGtub3duT3B0aW9ucy53aXRoQXJnc1tpXSwgYFJhbmRvbSBWYWx1ZSAke2l9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGtub3duT3B0aW9ucy53aXRob3V0QXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1RvUmVtb3ZlLnB1c2goa25vd25PcHRpb25zLndpdGhBcmdzW2ldLCBrbm93bk9wdGlvbnMud2l0aG91dEFyZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRGaWx0ZXJlZEFyZ3MucHVzaChrbm93bk9wdGlvbnMud2l0aEFyZ3NbaV0sIGBSYW5kb20gVmFsdWUgJHtpfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEZpbHRlcmVkQXJncy5wdXNoKGtub3duT3B0aW9ucy53aXRob3V0QXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRBcmdzID0gYXJndW1lbnRzU2VydmljZS5maWx0ZXJBcmd1bWVudHMoYXJncywgYXJndW1lbnRzVG9SZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChmaWx0ZXJlZEFyZ3MpLnRvLmJlLmRlZXAuZXF1YWwoZXhwZWN0ZWRGaWx0ZXJlZEFyZ3MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59KTtcclxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhwcm9kdWN0LCBtb2R1bGVOYW1lLCB3aXRoVmFsdWVzKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBjaGlsZF9wcm9jZXNzXzEuc3Bhd25TeW5jKGNvbW1vbl8xLlBZVEhPTl9QQVRILCBbJy1tJywgbW9kdWxlTmFtZSwgJy1oJ10pO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gcmVzdWx0LnN0ZG91dC50b1N0cmluZygpO1xyXG4gICAgLy8gT3VyIHJlZ2V4IGlzbid0IHRoZSBiZXN0LCBzbyBsZXRzIGV4Y2x1ZGUgc3R1ZmYgdGhhdCBzaG91bGRuJ3QgYmUgY2FwdHVyZWQuXHJcbiAgICBjb25zdCBrbm93bk9wdGlvbnNXaXRob3V0QXJncyA9IFtdO1xyXG4gICAgY29uc3Qga25vd25PcHRpb25zV2l0aEFyZ3MgPSBbXTtcclxuICAgIGlmIChwcm9kdWN0ID09PSB0eXBlc18xLlByb2R1Y3QucHl0ZXN0KSB7XHJcbiAgICAgICAga25vd25PcHRpb25zV2l0aEFyZ3MucHVzaCguLi5bJy1jJywgJy1wJywgJy1yJ10pO1xyXG4gICAgfVxyXG4gICAgaWYgKHdpdGhWYWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0T3B0aW9uc1dpdGhBcmd1bWVudHMob3V0cHV0KVxyXG4gICAgICAgICAgICAuY29uY2F0KC4uLmtub3duT3B0aW9uc1dpdGhBcmdzKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ga25vd25PcHRpb25zV2l0aG91dEFyZ3MuaW5kZXhPZihpdGVtKSA9PT0gLTEpXHJcbiAgICAgICAgICAgIC5zb3J0KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2V0T3B0aW9uc1dpdGhvdXRBcmd1bWVudHMob3V0cHV0KVxyXG4gICAgICAgICAgICAuY29uY2F0KC4uLmtub3duT3B0aW9uc1dpdGhvdXRBcmdzKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ga25vd25PcHRpb25zV2l0aEFyZ3MuaW5kZXhPZihpdGVtKSA9PT0gLTEpXHJcbiAgICAgICAgICAgIC8vIEluIHB5dGVzdCwgYW55IG9wdGlvbiBiZWdpbmluZyB3aXRoIC0tbG9nLSBpcyBrbm93biB0byBoYXZlIGFyZ3MuXHJcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBwcm9kdWN0ID09PSB0eXBlc18xLlByb2R1Y3QucHl0ZXN0ID8gIWl0ZW0uc3RhcnRzV2l0aCgnLS1sb2ctJykgOiB0cnVlKVxyXG4gICAgICAgICAgICAuc29ydCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldE9wdGlvbnNXaXRob3V0QXJndW1lbnRzKG91dHB1dCkge1xyXG4gICAgcmV0dXJuIGdldE1hdGNoZXMoJ1xcXFxzezEsfSgtezEsMn1bQS1aYS16MC05LV0rKSg/Oix8XFxcXHN7Mix9KScsIG91dHB1dCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0T3B0aW9uc1dpdGhBcmd1bWVudHMob3V0cHV0KSB7XHJcbiAgICByZXR1cm4gZ2V0TWF0Y2hlcygnXFxcXHN7MSx9KC17MSwyfVtBLVphLXowLTktXSspKD86PXxcXFxcc3swLDF9W0EtWl0pJywgb3V0cHV0KTtcclxufVxyXG5mdW5jdGlvbiBnZXRNYXRjaGVzKHBhdHRlcm4sIHN0cikge1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xyXG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sICdnbScpO1xyXG4gICAgbGV0IHJlc3VsdCA9IHJlZ2V4LmV4ZWMoc3RyKTtcclxuICAgIHdoaWxlIChyZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAocmVzdWx0LmluZGV4ID09PSByZWdleC5sYXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgcmVnZXgubGFzdEluZGV4ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdGNoZXMucHVzaChyZXN1bHRbMV0udHJpbSgpKTtcclxuICAgICAgICByZXN1bHQgPSByZWdleC5leGVjKHN0cik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hlc1xyXG4gICAgICAgIC5zb3J0KClcclxuICAgICAgICAucmVkdWNlKChpdGVtcywgaXRlbSkgPT4gaXRlbXMuaW5kZXhPZihpdGVtKSA9PT0gLTEgPyBpdGVtcy5jb25jYXQoW2l0ZW1dKSA6IGl0ZW1zLCBbXSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnc1NlcnZpY2UudGVzdC5qcy5tYXAiXX0=