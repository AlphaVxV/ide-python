"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const assert = require("assert");

const path = require("path");

const TypeMoq = require("typemoq");

const types_1 = require("../../client/common/types");

const contracts_1 = require("../../client/interpreter/contracts");

const conda_1 = require("../../client/interpreter/locators/services/conda");

const condaEnvService_1 = require("../../client/interpreter/locators/services/condaEnvService");

const serviceRegistry_1 = require("../unittests/serviceRegistry");

const mocks_1 = require("./mocks");

const environmentsPath = path.join(__dirname, '..', '..', '..', 'src', 'test', 'pythonFiles', 'environments'); // tslint:disable-next-line:max-func-body-length

suite('Interpreters from Conda Environments', () => {
  let ioc;
  let logger;
  let condaProvider;
  let condaService;
  let interpreterHelper;
  let fileSystem;
  setup(() => {
    initializeDI();
    const serviceContainer = TypeMoq.Mock.ofType();
    const stateFactory = TypeMoq.Mock.ofType();
    serviceContainer.setup(c => c.get(TypeMoq.It.isValue(types_1.IPersistentStateFactory))).returns(() => stateFactory.object);
    const state = new mocks_1.MockState(undefined);
    stateFactory.setup(s => s.createGlobalPersistentState(TypeMoq.It.isAny(), TypeMoq.It.isAny())).returns(() => state);
    condaService = TypeMoq.Mock.ofType();
    interpreterHelper = TypeMoq.Mock.ofType();
    fileSystem = TypeMoq.Mock.ofType();
    condaProvider = new condaEnvService_1.CondaEnvService(condaService.object, interpreterHelper.object, logger.object, serviceContainer.object, fileSystem.object);
  });
  teardown(() => ioc.dispose());

  function initializeDI() {
    ioc = new serviceRegistry_1.UnitTestIocContainer();
    ioc.registerCommonTypes();
    ioc.registerVariableTypes();
    ioc.registerProcessTypes();
    logger = TypeMoq.Mock.ofType();
  }

  test('Must return an empty list for empty json', () => __awaiter(void 0, void 0, void 0, function* () {
    const interpreters = yield condaEnvService_1.parseCondaInfo( // tslint:disable-next-line:no-any prefer-type-cast
    {}, condaService.object, fileSystem.object, interpreterHelper.object);
    assert.equal(interpreters.length, 0, 'Incorrect number of entries');
  }));

  function extractDisplayNameFromVersionInfo(isWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const info = {
        envs: [path.join(environmentsPath, 'conda', 'envs', 'numpy'), path.join(environmentsPath, 'conda', 'envs', 'scipy')],
        default_prefix: '',
        'sys.version': '3.6.1 |Anaconda 4.4.0 (64-bit)| (default, May 11 2017, 13:25:24) [MSC v.1900 64 bit (AMD64)]'
      };
      condaService.setup(c => c.getInterpreterPath(TypeMoq.It.isAny())).returns(environmentPath => {
        return isWindows ? path.join(environmentPath, 'python.exe') : path.join(environmentPath, 'bin', 'python');
      });
      info.envs.forEach(validPath => {
        const pythonPath = isWindows ? path.join(validPath, 'python.exe') : path.join(validPath, 'bin', 'python');
        fileSystem.setup(fs => fs.fileExists(TypeMoq.It.isValue(pythonPath))).returns(() => Promise.resolve(true));
      });
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve({
        version: ''
      }));
      const interpreters = yield condaEnvService_1.parseCondaInfo(info, condaService.object, fileSystem.object, interpreterHelper.object);
      assert.equal(interpreters.length, 2, 'Incorrect number of entries');
      const path1 = path.join(info.envs[0], isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[0].path, path1, 'Incorrect path for first env');
      assert.equal(interpreters[0].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[0].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
      const path2 = path.join(info.envs[1], isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[1].path, path2, 'Incorrect path for first env');
      assert.equal(interpreters[1].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[1].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
    });
  }

  test('Must extract display name from version info (non windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield extractDisplayNameFromVersionInfo(false);
  }));
  test('Must extract display name from version info (windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield extractDisplayNameFromVersionInfo(true);
  }));

  function extractDisplayNameFromVersionInfoSuffixedWithEnvironmentName(isWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const info = {
        envs: [path.join(environmentsPath, 'conda', 'envs', 'numpy'), path.join(environmentsPath, 'conda', 'envs', 'scipy')],
        default_prefix: path.join(environmentsPath, 'conda', 'envs', 'root'),
        'sys.version': '3.6.1 |Anaconda 4.4.0 (64-bit)| (default, May 11 2017, 13:25:24) [MSC v.1900 64 bit (AMD64)]'
      };
      condaService.setup(c => c.getInterpreterPath(TypeMoq.It.isAny())).returns(environmentPath => {
        return isWindows ? path.join(environmentPath, 'python.exe') : path.join(environmentPath, 'bin', 'python');
      });
      info.envs.forEach(validPath => {
        const pythonPath = isWindows ? path.join(validPath, 'python.exe') : path.join(validPath, 'bin', 'python');
        fileSystem.setup(fs => fs.fileExists(TypeMoq.It.isValue(pythonPath))).returns(() => Promise.resolve(true));
      });
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve({
        version: ''
      }));
      condaService.setup(c => c.getCondaFile()).returns(() => Promise.resolve('conda'));
      condaService.setup(c => c.getCondaInfo()).returns(() => Promise.resolve(info));
      condaService.setup(c => c.getCondaEnvironments(TypeMoq.It.isAny())).returns(() => Promise.resolve([{
        name: 'base',
        path: environmentsPath
      }, {
        name: 'numpy',
        path: path.join(environmentsPath, 'conda', 'envs', 'numpy')
      }, {
        name: 'scipy',
        path: path.join(environmentsPath, 'conda', 'envs', 'scipy')
      }]));
      fileSystem.setup(fs => fs.arePathsSame(TypeMoq.It.isAny(), TypeMoq.It.isAny())).returns((p1, p2) => isWindows ? p1 === p2 : p1.toUpperCase() === p2.toUpperCase());
      const interpreters = yield condaProvider.getInterpreters();
      assert.equal(interpreters.length, 2, 'Incorrect number of entries');
      const path1 = path.join(info.envs[0], isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[0].path, path1, 'Incorrect path for first env');
      assert.equal(interpreters[0].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[0].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
      const path2 = path.join(info.envs[1], isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[1].path, path2, 'Incorrect path for first env');
      assert.equal(interpreters[1].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[1].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
    });
  }

  test('Must extract display name from version info suffixed with the environment name (oxs/linux)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield extractDisplayNameFromVersionInfoSuffixedWithEnvironmentName(false);
  }));
  test('Must extract display name from version info suffixed with the environment name (windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield extractDisplayNameFromVersionInfoSuffixedWithEnvironmentName(true);
  }));

  function useDefaultNameIfSysVersionIsInvalid(isWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const info = {
        envs: [path.join(environmentsPath, 'conda', 'envs', 'numpy')],
        default_prefix: '',
        'sys.version': '3.6.1 |Anaonda 4.4.0 (64-bit)| (default, May 11 2017, 13:25:24) [MSC v.1900 64 bit (AMD64)]'
      };
      condaService.setup(c => c.getInterpreterPath(TypeMoq.It.isAny())).returns(environmentPath => {
        return isWindows ? path.join(environmentPath, 'python.exe') : path.join(environmentPath, 'bin', 'python');
      });
      info.envs.forEach(validPath => {
        const pythonPath = isWindows ? path.join(validPath, 'python.exe') : path.join(validPath, 'bin', 'python');
        fileSystem.setup(fs => fs.fileExists(TypeMoq.It.isValue(pythonPath))).returns(() => Promise.resolve(true));
      });
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve({
        version: ''
      }));
      const interpreters = yield condaEnvService_1.parseCondaInfo(info, condaService.object, fileSystem.object, interpreterHelper.object);
      assert.equal(interpreters.length, 1, 'Incorrect number of entries');
      const path1 = path.join(info.envs[0], isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[0].path, path1, 'Incorrect path for first env');
      assert.equal(interpreters[0].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[0].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
    });
  }

  test('Must use the default display name if sys.version is invalid (non windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield useDefaultNameIfSysVersionIsInvalid(false);
  }));
  test('Must use the default display name if sys.version is invalid (windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield useDefaultNameIfSysVersionIsInvalid(true);
  }));

  function useDefaultNameIfSysVersionIsValidAndSuffixWithEnvironmentName(isWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const info = {
        envs: [path.join(environmentsPath, 'conda', 'envs', 'numpy')],
        default_prefix: '',
        'sys.version': '3.6.1 |Anaonda 4.4.0 (64-bit)| (default, May 11 2017, 13:25:24) [MSC v.1900 64 bit (AMD64)]'
      };
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve({
        version: ''
      }));
      condaService.setup(c => c.getCondaInfo()).returns(() => Promise.resolve(info));
      condaService.setup(c => c.getCondaEnvironments(TypeMoq.It.isAny())).returns(() => Promise.resolve([{
        name: 'base',
        path: environmentsPath
      }, {
        name: 'numpy',
        path: path.join(environmentsPath, 'conda', 'envs', 'numpy')
      }, {
        name: 'scipy',
        path: path.join(environmentsPath, 'conda', 'envs', 'scipy')
      }]));
      condaService.setup(c => c.getInterpreterPath(TypeMoq.It.isAny())).returns(environmentPath => {
        return isWindows ? path.join(environmentPath, 'python.exe') : path.join(environmentPath, 'bin', 'python');
      });
      info.envs.forEach(validPath => {
        const pythonPath = isWindows ? path.join(validPath, 'python.exe') : path.join(validPath, 'bin', 'python');
        fileSystem.setup(fs => fs.fileExists(TypeMoq.It.isValue(pythonPath))).returns(() => Promise.resolve(true));
      });
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve(undefined));
      fileSystem.setup(fs => fs.arePathsSame(TypeMoq.It.isAny(), TypeMoq.It.isAny())).returns((p1, p2) => isWindows ? p1 === p2 : p1.toUpperCase() === p2.toUpperCase());
      const interpreters = yield condaProvider.getInterpreters();
      assert.equal(interpreters.length, 1, 'Incorrect number of entries');
      const path1 = path.join(info.envs[0], isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[0].path, path1, 'Incorrect path for first env');
      assert.equal(interpreters[0].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[0].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
    });
  }

  test('Must use the default display name if sys.version is invalid and suffixed with environment name (non windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield useDefaultNameIfSysVersionIsValidAndSuffixWithEnvironmentName(false);
  }));
  test('Must use the default display name if sys.version is invalid and suffixed with environment name (windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield useDefaultNameIfSysVersionIsValidAndSuffixWithEnvironmentName(false);
  }));

  function useDefaultNameIfSysVersionIsEmpty(isWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const info = {
        envs: [path.join(environmentsPath, 'conda', 'envs', 'numpy')]
      };
      condaService.setup(c => c.getInterpreterPath(TypeMoq.It.isAny())).returns(environmentPath => {
        return isWindows ? path.join(environmentPath, 'python.exe') : path.join(environmentPath, 'bin', 'python');
      });
      info.envs.forEach(validPath => {
        const pythonPath = isWindows ? path.join(validPath, 'python.exe') : path.join(validPath, 'bin', 'python');
        fileSystem.setup(fs => fs.fileExists(TypeMoq.It.isValue(pythonPath))).returns(() => Promise.resolve(true));
      });
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve({
        version: ''
      }));
      const interpreters = yield condaEnvService_1.parseCondaInfo(info, condaService.object, fileSystem.object, interpreterHelper.object);
      assert.equal(interpreters.length, 1, 'Incorrect number of entries');
      const path1 = path.join(info.envs[0], isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[0].path, path1, 'Incorrect path for first env');
      assert.equal(interpreters[0].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[0].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
    });
  }

  test('Must use the default display name if sys.version is empty (non windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield useDefaultNameIfSysVersionIsEmpty(false);
  }));
  test('Must use the default display name if sys.version is empty (windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield useDefaultNameIfSysVersionIsEmpty(true);
  }));

  function useDefaultNameIfSysVersionIsEmptyAndSuffixWithEnvironmentName(isWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const info = {
        envs: [path.join(environmentsPath, 'conda', 'envs', 'numpy')]
      };
      condaService.setup(c => c.getInterpreterPath(TypeMoq.It.isAny())).returns(environmentPath => {
        return isWindows ? path.join(environmentPath, 'python.exe') : path.join(environmentPath, 'bin', 'python');
      });
      info.envs.forEach(validPath => {
        const pythonPath = isWindows ? path.join(validPath, 'python.exe') : path.join(validPath, 'bin', 'python');
        fileSystem.setup(fs => fs.fileExists(TypeMoq.It.isValue(pythonPath))).returns(() => Promise.resolve(true));
      });
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve({
        version: ''
      }));
      condaService.setup(c => c.getCondaFile()).returns(() => Promise.resolve('conda'));
      condaService.setup(c => c.getCondaInfo()).returns(() => Promise.resolve(info));
      condaService.setup(c => c.getCondaEnvironments(TypeMoq.It.isAny())).returns(() => Promise.resolve([{
        name: 'base',
        path: environmentsPath
      }, {
        name: 'numpy',
        path: path.join(environmentsPath, 'conda', 'envs', 'numpy')
      }, {
        name: 'scipy',
        path: path.join(environmentsPath, 'conda', 'envs', 'scipy')
      }]));
      fileSystem.setup(fs => fs.arePathsSame(TypeMoq.It.isAny(), TypeMoq.It.isAny())).returns((p1, p2) => isWindows ? p1 === p2 : p1.toUpperCase() === p2.toUpperCase());
      const interpreters = yield condaProvider.getInterpreters();
      assert.equal(interpreters.length, 1, 'Incorrect number of entries');
      const path1 = path.join(info.envs[0], isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[0].path, path1, 'Incorrect path for first env');
      assert.equal(interpreters[0].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[0].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
    });
  }

  test('Must use the default display name if sys.version is empty and suffixed with environment name (non windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield useDefaultNameIfSysVersionIsEmptyAndSuffixWithEnvironmentName(false);
  }));
  test('Must use the default display name if sys.version is empty and suffixed with environment name (windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield useDefaultNameIfSysVersionIsEmptyAndSuffixWithEnvironmentName(true);
  }));

  function includeDefaultPrefixIntoListOfInterpreters(isWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const info = {
        default_prefix: path.join(environmentsPath, 'conda', 'envs', 'numpy')
      };
      condaService.setup(c => c.getInterpreterPath(TypeMoq.It.isAny())).returns(environmentPath => {
        return isWindows ? path.join(environmentPath, 'python.exe') : path.join(environmentPath, 'bin', 'python');
      });
      const pythonPath = isWindows ? path.join(info.default_prefix, 'python.exe') : path.join(info.default_prefix, 'bin', 'python');
      fileSystem.setup(fs => fs.fileExists(TypeMoq.It.isValue(pythonPath))).returns(() => Promise.resolve(true));
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve({
        version: ''
      }));
      const interpreters = yield condaEnvService_1.parseCondaInfo(info, condaService.object, fileSystem.object, interpreterHelper.object);
      assert.equal(interpreters.length, 1, 'Incorrect number of entries');
      const path1 = path.join(info.default_prefix, isWindows ? 'python.exe' : path.join('bin', 'python'));
      assert.equal(interpreters[0].path, path1, 'Incorrect path for first env');
      assert.equal(interpreters[0].companyDisplayName, conda_1.AnacondaCompanyName, 'Incorrect company display name for first env');
      assert.equal(interpreters[0].type, contracts_1.InterpreterType.Conda, 'Environment not detected as a conda environment');
    });
  }

  test('Must include the default_prefix into the list of interpreters (non windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield includeDefaultPrefixIntoListOfInterpreters(false);
  }));
  test('Must include the default_prefix into the list of interpreters (windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield includeDefaultPrefixIntoListOfInterpreters(true);
  }));

  function excludeInterpretersThatDoNotExistOnFileSystem(isWindows) {
    return __awaiter(this, void 0, void 0, function* () {
      const info = {
        envs: [path.join(environmentsPath, 'conda', 'envs', 'numpy'), path.join(environmentsPath, 'path0', 'one.exe'), path.join(environmentsPath, 'path1', 'one.exe'), path.join(environmentsPath, 'path2', 'one.exe'), path.join(environmentsPath, 'conda', 'envs', 'scipy'), path.join(environmentsPath, 'path3', 'three.exe')]
      };
      const validPaths = info.envs.filter((_, index) => index % 2 === 0);
      interpreterHelper.setup(i => i.getInterpreterInformation(TypeMoq.It.isAny())).returns(() => Promise.resolve({
        version: ''
      }));
      validPaths.forEach(envPath => {
        condaService.setup(c => c.getInterpreterPath(TypeMoq.It.isValue(envPath))).returns(environmentPath => {
          return isWindows ? path.join(environmentPath, 'python.exe') : path.join(environmentPath, 'bin', 'python');
        });
        const pythonPath = isWindows ? path.join(envPath, 'python.exe') : path.join(envPath, 'bin', 'python');
        fileSystem.setup(fs => fs.fileExists(TypeMoq.It.isValue(pythonPath))).returns(() => Promise.resolve(true));
      });
      const interpreters = yield condaEnvService_1.parseCondaInfo(info, condaService.object, fileSystem.object, interpreterHelper.object);
      assert.equal(interpreters.length, validPaths.length, 'Incorrect number of entries');
      validPaths.forEach((envPath, index) => {
        assert.equal(interpreters[index].envPath, envPath, 'Incorrect env path');
        const pythonPath = isWindows ? path.join(envPath, 'python.exe') : path.join(envPath, 'bin', 'python');
        assert.equal(interpreters[index].path, pythonPath, 'Incorrect python Path');
      });
    });
  }

  test('Must exclude interpreters that do not exist on disc (non windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield excludeInterpretersThatDoNotExistOnFileSystem(false);
  }));
  test('Must exclude interpreters that do not exist on disc (windows)', () => __awaiter(void 0, void 0, void 0, function* () {
    yield excludeInterpretersThatDoNotExistOnFileSystem(true);
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbmRhRW52U2VydmljZS51bml0LnRlc3QuanMiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImFzc2VydCIsInJlcXVpcmUiLCJwYXRoIiwiVHlwZU1vcSIsInR5cGVzXzEiLCJjb250cmFjdHNfMSIsImNvbmRhXzEiLCJjb25kYUVudlNlcnZpY2VfMSIsInNlcnZpY2VSZWdpc3RyeV8xIiwibW9ja3NfMSIsImVudmlyb25tZW50c1BhdGgiLCJqb2luIiwiX19kaXJuYW1lIiwic3VpdGUiLCJpb2MiLCJsb2dnZXIiLCJjb25kYVByb3ZpZGVyIiwiY29uZGFTZXJ2aWNlIiwiaW50ZXJwcmV0ZXJIZWxwZXIiLCJmaWxlU3lzdGVtIiwic2V0dXAiLCJpbml0aWFsaXplREkiLCJzZXJ2aWNlQ29udGFpbmVyIiwiTW9jayIsIm9mVHlwZSIsInN0YXRlRmFjdG9yeSIsImMiLCJnZXQiLCJJdCIsImlzVmFsdWUiLCJJUGVyc2lzdGVudFN0YXRlRmFjdG9yeSIsInJldHVybnMiLCJvYmplY3QiLCJzdGF0ZSIsIk1vY2tTdGF0ZSIsInVuZGVmaW5lZCIsInMiLCJjcmVhdGVHbG9iYWxQZXJzaXN0ZW50U3RhdGUiLCJpc0FueSIsIkNvbmRhRW52U2VydmljZSIsInRlYXJkb3duIiwiZGlzcG9zZSIsIlVuaXRUZXN0SW9jQ29udGFpbmVyIiwicmVnaXN0ZXJDb21tb25UeXBlcyIsInJlZ2lzdGVyVmFyaWFibGVUeXBlcyIsInJlZ2lzdGVyUHJvY2Vzc1R5cGVzIiwidGVzdCIsImludGVycHJldGVycyIsInBhcnNlQ29uZGFJbmZvIiwiZXF1YWwiLCJsZW5ndGgiLCJleHRyYWN0RGlzcGxheU5hbWVGcm9tVmVyc2lvbkluZm8iLCJpc1dpbmRvd3MiLCJpbmZvIiwiZW52cyIsImRlZmF1bHRfcHJlZml4IiwiZ2V0SW50ZXJwcmV0ZXJQYXRoIiwiZW52aXJvbm1lbnRQYXRoIiwiZm9yRWFjaCIsInZhbGlkUGF0aCIsInB5dGhvblBhdGgiLCJmcyIsImZpbGVFeGlzdHMiLCJpIiwiZ2V0SW50ZXJwcmV0ZXJJbmZvcm1hdGlvbiIsInZlcnNpb24iLCJwYXRoMSIsImNvbXBhbnlEaXNwbGF5TmFtZSIsIkFuYWNvbmRhQ29tcGFueU5hbWUiLCJ0eXBlIiwiSW50ZXJwcmV0ZXJUeXBlIiwiQ29uZGEiLCJwYXRoMiIsImV4dHJhY3REaXNwbGF5TmFtZUZyb21WZXJzaW9uSW5mb1N1ZmZpeGVkV2l0aEVudmlyb25tZW50TmFtZSIsImdldENvbmRhRmlsZSIsImdldENvbmRhSW5mbyIsImdldENvbmRhRW52aXJvbm1lbnRzIiwibmFtZSIsImFyZVBhdGhzU2FtZSIsInAxIiwicDIiLCJ0b1VwcGVyQ2FzZSIsImdldEludGVycHJldGVycyIsInVzZURlZmF1bHROYW1lSWZTeXNWZXJzaW9uSXNJbnZhbGlkIiwidXNlRGVmYXVsdE5hbWVJZlN5c1ZlcnNpb25Jc1ZhbGlkQW5kU3VmZml4V2l0aEVudmlyb25tZW50TmFtZSIsInVzZURlZmF1bHROYW1lSWZTeXNWZXJzaW9uSXNFbXB0eSIsInVzZURlZmF1bHROYW1lSWZTeXNWZXJzaW9uSXNFbXB0eUFuZFN1ZmZpeFdpdGhFbnZpcm9ubWVudE5hbWUiLCJpbmNsdWRlRGVmYXVsdFByZWZpeEludG9MaXN0T2ZJbnRlcnByZXRlcnMiLCJleGNsdWRlSW50ZXJwcmV0ZXJzVGhhdERvTm90RXhpc3RPbkZpbGVTeXN0ZW0iLCJ2YWxpZFBhdGhzIiwiZmlsdGVyIiwiXyIsImluZGV4IiwiZW52UGF0aCJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsU0FBUyxHQUFJLFVBQVEsU0FBS0EsU0FBZCxJQUE0QixVQUFV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JiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBUeXBlTW9xID0gcmVxdWlyZShcInR5cGVtb3FcIik7XHJcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbW1vbi90eXBlc1wiKTtcclxuY29uc3QgY29udHJhY3RzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2ludGVycHJldGVyL2NvbnRyYWN0c1wiKTtcclxuY29uc3QgY29uZGFfMSA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnQvaW50ZXJwcmV0ZXIvbG9jYXRvcnMvc2VydmljZXMvY29uZGFcIik7XHJcbmNvbnN0IGNvbmRhRW52U2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9pbnRlcnByZXRlci9sb2NhdG9ycy9zZXJ2aWNlcy9jb25kYUVudlNlcnZpY2VcIik7XHJcbmNvbnN0IHNlcnZpY2VSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4uL3VuaXR0ZXN0cy9zZXJ2aWNlUmVnaXN0cnlcIik7XHJcbmNvbnN0IG1vY2tzXzEgPSByZXF1aXJlKFwiLi9tb2Nrc1wiKTtcclxuY29uc3QgZW52aXJvbm1lbnRzUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICcuLicsICcuLicsICdzcmMnLCAndGVzdCcsICdweXRob25GaWxlcycsICdlbnZpcm9ubWVudHMnKTtcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1mdW5jLWJvZHktbGVuZ3RoXHJcbnN1aXRlKCdJbnRlcnByZXRlcnMgZnJvbSBDb25kYSBFbnZpcm9ubWVudHMnLCAoKSA9PiB7XHJcbiAgICBsZXQgaW9jO1xyXG4gICAgbGV0IGxvZ2dlcjtcclxuICAgIGxldCBjb25kYVByb3ZpZGVyO1xyXG4gICAgbGV0IGNvbmRhU2VydmljZTtcclxuICAgIGxldCBpbnRlcnByZXRlckhlbHBlcjtcclxuICAgIGxldCBmaWxlU3lzdGVtO1xyXG4gICAgc2V0dXAoKCkgPT4ge1xyXG4gICAgICAgIGluaXRpYWxpemVESSgpO1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VDb250YWluZXIgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgIHNlcnZpY2VDb250YWluZXIuc2V0dXAoYyA9PiBjLmdldChUeXBlTW9xLkl0LmlzVmFsdWUodHlwZXNfMS5JUGVyc2lzdGVudFN0YXRlRmFjdG9yeSkpKS5yZXR1cm5zKCgpID0+IHN0YXRlRmFjdG9yeS5vYmplY3QpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IG1vY2tzXzEuTW9ja1N0YXRlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgc3RhdGVGYWN0b3J5LnNldHVwKHMgPT4gcy5jcmVhdGVHbG9iYWxQZXJzaXN0ZW50U3RhdGUoVHlwZU1vcS5JdC5pc0FueSgpLCBUeXBlTW9xLkl0LmlzQW55KCkpKS5yZXR1cm5zKCgpID0+IHN0YXRlKTtcclxuICAgICAgICBjb25kYVNlcnZpY2UgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgaW50ZXJwcmV0ZXJIZWxwZXIgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgZmlsZVN5c3RlbSA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICBjb25kYVByb3ZpZGVyID0gbmV3IGNvbmRhRW52U2VydmljZV8xLkNvbmRhRW52U2VydmljZShjb25kYVNlcnZpY2Uub2JqZWN0LCBpbnRlcnByZXRlckhlbHBlci5vYmplY3QsIGxvZ2dlci5vYmplY3QsIHNlcnZpY2VDb250YWluZXIub2JqZWN0LCBmaWxlU3lzdGVtLm9iamVjdCk7XHJcbiAgICB9KTtcclxuICAgIHRlYXJkb3duKCgpID0+IGlvYy5kaXNwb3NlKCkpO1xyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZURJKCkge1xyXG4gICAgICAgIGlvYyA9IG5ldyBzZXJ2aWNlUmVnaXN0cnlfMS5Vbml0VGVzdElvY0NvbnRhaW5lcigpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlckNvbW1vblR5cGVzKCk7XHJcbiAgICAgICAgaW9jLnJlZ2lzdGVyVmFyaWFibGVUeXBlcygpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlclByb2Nlc3NUeXBlcygpO1xyXG4gICAgICAgIGxvZ2dlciA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgIH1cclxuICAgIHRlc3QoJ011c3QgcmV0dXJuIGFuIGVtcHR5IGxpc3QgZm9yIGVtcHR5IGpzb24nLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJwcmV0ZXJzID0geWllbGQgY29uZGFFbnZTZXJ2aWNlXzEucGFyc2VDb25kYUluZm8oXHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBwcmVmZXItdHlwZS1jYXN0XHJcbiAgICAgICAge30sIGNvbmRhU2VydmljZS5vYmplY3QsIGZpbGVTeXN0ZW0ub2JqZWN0LCBpbnRlcnByZXRlckhlbHBlci5vYmplY3QpO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnMubGVuZ3RoLCAwLCAnSW5jb3JyZWN0IG51bWJlciBvZiBlbnRyaWVzJyk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0RGlzcGxheU5hbWVGcm9tVmVyc2lvbkluZm8oaXNXaW5kb3dzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGVudnM6IFtwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ2NvbmRhJywgJ2VudnMnLCAnbnVtcHknKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ2NvbmRhJywgJ2VudnMnLCAnc2NpcHknKV0sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0X3ByZWZpeDogJycsXHJcbiAgICAgICAgICAgICAgICAnc3lzLnZlcnNpb24nOiAnMy42LjEgfEFuYWNvbmRhIDQuNC4wICg2NC1iaXQpfCAoZGVmYXVsdCwgTWF5IDExIDIwMTcsIDEzOjI1OjI0KSBbTVNDIHYuMTkwMCA2NCBiaXQgKEFNRDY0KV0nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbmRhU2VydmljZS5zZXR1cChjID0+IGMuZ2V0SW50ZXJwcmV0ZXJQYXRoKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoZW52aXJvbm1lbnRQYXRoID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1dpbmRvd3MgPyBwYXRoLmpvaW4oZW52aXJvbm1lbnRQYXRoLCAncHl0aG9uLmV4ZScpIDogcGF0aC5qb2luKGVudmlyb25tZW50UGF0aCwgJ2JpbicsICdweXRob24nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGluZm8uZW52cy5mb3JFYWNoKHZhbGlkUGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBweXRob25QYXRoID0gaXNXaW5kb3dzID8gcGF0aC5qb2luKHZhbGlkUGF0aCwgJ3B5dGhvbi5leGUnKSA6IHBhdGguam9pbih2YWxpZFBhdGgsICdiaW4nLCAncHl0aG9uJyk7XHJcbiAgICAgICAgICAgICAgICBmaWxlU3lzdGVtLnNldHVwKGZzID0+IGZzLmZpbGVFeGlzdHMoVHlwZU1vcS5JdC5pc1ZhbHVlKHB5dGhvblBhdGgpKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUodHJ1ZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW50ZXJwcmV0ZXJIZWxwZXIuc2V0dXAoaSA9PiBpLmdldEludGVycHJldGVySW5mb3JtYXRpb24oVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUoeyB2ZXJzaW9uOiAnJyB9KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVycHJldGVycyA9IHlpZWxkIGNvbmRhRW52U2VydmljZV8xLnBhcnNlQ29uZGFJbmZvKGluZm8sIGNvbmRhU2VydmljZS5vYmplY3QsIGZpbGVTeXN0ZW0ub2JqZWN0LCBpbnRlcnByZXRlckhlbHBlci5vYmplY3QpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzLmxlbmd0aCwgMiwgJ0luY29ycmVjdCBudW1iZXIgb2YgZW50cmllcycpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoMSA9IHBhdGguam9pbihpbmZvLmVudnNbMF0sIGlzV2luZG93cyA/ICdweXRob24uZXhlJyA6IHBhdGguam9pbignYmluJywgJ3B5dGhvbicpKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVyc1swXS5wYXRoLCBwYXRoMSwgJ0luY29ycmVjdCBwYXRoIGZvciBmaXJzdCBlbnYnKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVyc1swXS5jb21wYW55RGlzcGxheU5hbWUsIGNvbmRhXzEuQW5hY29uZGFDb21wYW55TmFtZSwgJ0luY29ycmVjdCBjb21wYW55IGRpc3BsYXkgbmFtZSBmb3IgZmlyc3QgZW52Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMF0udHlwZSwgY29udHJhY3RzXzEuSW50ZXJwcmV0ZXJUeXBlLkNvbmRhLCAnRW52aXJvbm1lbnQgbm90IGRldGVjdGVkIGFzIGEgY29uZGEgZW52aXJvbm1lbnQnKTtcclxuICAgICAgICAgICAgY29uc3QgcGF0aDIgPSBwYXRoLmpvaW4oaW5mby5lbnZzWzFdLCBpc1dpbmRvd3MgPyAncHl0aG9uLmV4ZScgOiBwYXRoLmpvaW4oJ2JpbicsICdweXRob24nKSk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMV0ucGF0aCwgcGF0aDIsICdJbmNvcnJlY3QgcGF0aCBmb3IgZmlyc3QgZW52Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMV0uY29tcGFueURpc3BsYXlOYW1lLCBjb25kYV8xLkFuYWNvbmRhQ29tcGFueU5hbWUsICdJbmNvcnJlY3QgY29tcGFueSBkaXNwbGF5IG5hbWUgZm9yIGZpcnN0IGVudicpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzFdLnR5cGUsIGNvbnRyYWN0c18xLkludGVycHJldGVyVHlwZS5Db25kYSwgJ0Vudmlyb25tZW50IG5vdCBkZXRlY3RlZCBhcyBhIGNvbmRhIGVudmlyb25tZW50Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0ZXN0KCdNdXN0IGV4dHJhY3QgZGlzcGxheSBuYW1lIGZyb20gdmVyc2lvbiBpbmZvIChub24gd2luZG93cyknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgZXh0cmFjdERpc3BsYXlOYW1lRnJvbVZlcnNpb25JbmZvKGZhbHNlKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ011c3QgZXh0cmFjdCBkaXNwbGF5IG5hbWUgZnJvbSB2ZXJzaW9uIGluZm8gKHdpbmRvd3MpJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIGV4dHJhY3REaXNwbGF5TmFtZUZyb21WZXJzaW9uSW5mbyh0cnVlKTtcclxuICAgIH0pKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3REaXNwbGF5TmFtZUZyb21WZXJzaW9uSW5mb1N1ZmZpeGVkV2l0aEVudmlyb25tZW50TmFtZShpc1dpbmRvd3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgZW52czogW3BhdGguam9pbihlbnZpcm9ubWVudHNQYXRoLCAnY29uZGEnLCAnZW52cycsICdudW1weScpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGguam9pbihlbnZpcm9ubWVudHNQYXRoLCAnY29uZGEnLCAnZW52cycsICdzY2lweScpXSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRfcHJlZml4OiBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ2NvbmRhJywgJ2VudnMnLCAncm9vdCcpLFxyXG4gICAgICAgICAgICAgICAgJ3N5cy52ZXJzaW9uJzogJzMuNi4xIHxBbmFjb25kYSA0LjQuMCAoNjQtYml0KXwgKGRlZmF1bHQsIE1heSAxMSAyMDE3LCAxMzoyNToyNCkgW01TQyB2LjE5MDAgNjQgYml0IChBTUQ2NCldJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25kYVNlcnZpY2Uuc2V0dXAoYyA9PiBjLmdldEludGVycHJldGVyUGF0aChUeXBlTW9xLkl0LmlzQW55KCkpKS5yZXR1cm5zKGVudmlyb25tZW50UGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNXaW5kb3dzID8gcGF0aC5qb2luKGVudmlyb25tZW50UGF0aCwgJ3B5dGhvbi5leGUnKSA6IHBhdGguam9pbihlbnZpcm9ubWVudFBhdGgsICdiaW4nLCAncHl0aG9uJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbmZvLmVudnMuZm9yRWFjaCh2YWxpZFBhdGggPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHl0aG9uUGF0aCA9IGlzV2luZG93cyA/IHBhdGguam9pbih2YWxpZFBhdGgsICdweXRob24uZXhlJykgOiBwYXRoLmpvaW4odmFsaWRQYXRoLCAnYmluJywgJ3B5dGhvbicpO1xyXG4gICAgICAgICAgICAgICAgZmlsZVN5c3RlbS5zZXR1cChmcyA9PiBmcy5maWxlRXhpc3RzKFR5cGVNb3EuSXQuaXNWYWx1ZShweXRob25QYXRoKSkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHRydWUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGludGVycHJldGVySGVscGVyLnNldHVwKGkgPT4gaS5nZXRJbnRlcnByZXRlckluZm9ybWF0aW9uKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgdmVyc2lvbjogJycgfSkpO1xyXG4gICAgICAgICAgICBjb25kYVNlcnZpY2Uuc2V0dXAoYyA9PiBjLmdldENvbmRhRmlsZSgpKS5yZXR1cm5zKCgpID0+IFByb21pc2UucmVzb2x2ZSgnY29uZGEnKSk7XHJcbiAgICAgICAgICAgIGNvbmRhU2VydmljZS5zZXR1cChjID0+IGMuZ2V0Q29uZGFJbmZvKCkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKGluZm8pKTtcclxuICAgICAgICAgICAgY29uZGFTZXJ2aWNlLnNldHVwKGMgPT4gYy5nZXRDb25kYUVudmlyb25tZW50cyhUeXBlTW9xLkl0LmlzQW55KCkpKS5yZXR1cm5zKCgpID0+IFByb21pc2UucmVzb2x2ZShbXHJcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdiYXNlJywgcGF0aDogZW52aXJvbm1lbnRzUGF0aCB9LFxyXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnbnVtcHknLCBwYXRoOiBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ2NvbmRhJywgJ2VudnMnLCAnbnVtcHknKSB9LFxyXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnc2NpcHknLCBwYXRoOiBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ2NvbmRhJywgJ2VudnMnLCAnc2NpcHknKSB9XHJcbiAgICAgICAgICAgIF0pKTtcclxuICAgICAgICAgICAgZmlsZVN5c3RlbS5zZXR1cChmcyA9PiBmcy5hcmVQYXRoc1NhbWUoVHlwZU1vcS5JdC5pc0FueSgpLCBUeXBlTW9xLkl0LmlzQW55KCkpKS5yZXR1cm5zKChwMSwgcDIpID0+IGlzV2luZG93cyA/IHAxID09PSBwMiA6IHAxLnRvVXBwZXJDYXNlKCkgPT09IHAyLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcnByZXRlcnMgPSB5aWVsZCBjb25kYVByb3ZpZGVyLmdldEludGVycHJldGVycygpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzLmxlbmd0aCwgMiwgJ0luY29ycmVjdCBudW1iZXIgb2YgZW50cmllcycpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoMSA9IHBhdGguam9pbihpbmZvLmVudnNbMF0sIGlzV2luZG93cyA/ICdweXRob24uZXhlJyA6IHBhdGguam9pbignYmluJywgJ3B5dGhvbicpKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVyc1swXS5wYXRoLCBwYXRoMSwgJ0luY29ycmVjdCBwYXRoIGZvciBmaXJzdCBlbnYnKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVyc1swXS5jb21wYW55RGlzcGxheU5hbWUsIGNvbmRhXzEuQW5hY29uZGFDb21wYW55TmFtZSwgJ0luY29ycmVjdCBjb21wYW55IGRpc3BsYXkgbmFtZSBmb3IgZmlyc3QgZW52Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMF0udHlwZSwgY29udHJhY3RzXzEuSW50ZXJwcmV0ZXJUeXBlLkNvbmRhLCAnRW52aXJvbm1lbnQgbm90IGRldGVjdGVkIGFzIGEgY29uZGEgZW52aXJvbm1lbnQnKTtcclxuICAgICAgICAgICAgY29uc3QgcGF0aDIgPSBwYXRoLmpvaW4oaW5mby5lbnZzWzFdLCBpc1dpbmRvd3MgPyAncHl0aG9uLmV4ZScgOiBwYXRoLmpvaW4oJ2JpbicsICdweXRob24nKSk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMV0ucGF0aCwgcGF0aDIsICdJbmNvcnJlY3QgcGF0aCBmb3IgZmlyc3QgZW52Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMV0uY29tcGFueURpc3BsYXlOYW1lLCBjb25kYV8xLkFuYWNvbmRhQ29tcGFueU5hbWUsICdJbmNvcnJlY3QgY29tcGFueSBkaXNwbGF5IG5hbWUgZm9yIGZpcnN0IGVudicpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzFdLnR5cGUsIGNvbnRyYWN0c18xLkludGVycHJldGVyVHlwZS5Db25kYSwgJ0Vudmlyb25tZW50IG5vdCBkZXRlY3RlZCBhcyBhIGNvbmRhIGVudmlyb25tZW50Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0ZXN0KCdNdXN0IGV4dHJhY3QgZGlzcGxheSBuYW1lIGZyb20gdmVyc2lvbiBpbmZvIHN1ZmZpeGVkIHdpdGggdGhlIGVudmlyb25tZW50IG5hbWUgKG94cy9saW51eCknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgZXh0cmFjdERpc3BsYXlOYW1lRnJvbVZlcnNpb25JbmZvU3VmZml4ZWRXaXRoRW52aXJvbm1lbnROYW1lKGZhbHNlKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ011c3QgZXh0cmFjdCBkaXNwbGF5IG5hbWUgZnJvbSB2ZXJzaW9uIGluZm8gc3VmZml4ZWQgd2l0aCB0aGUgZW52aXJvbm1lbnQgbmFtZSAod2luZG93cyknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgZXh0cmFjdERpc3BsYXlOYW1lRnJvbVZlcnNpb25JbmZvU3VmZml4ZWRXaXRoRW52aXJvbm1lbnROYW1lKHRydWUpO1xyXG4gICAgfSkpO1xyXG4gICAgZnVuY3Rpb24gdXNlRGVmYXVsdE5hbWVJZlN5c1ZlcnNpb25Jc0ludmFsaWQoaXNXaW5kb3dzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGVudnM6IFtwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ2NvbmRhJywgJ2VudnMnLCAnbnVtcHknKV0sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0X3ByZWZpeDogJycsXHJcbiAgICAgICAgICAgICAgICAnc3lzLnZlcnNpb24nOiAnMy42LjEgfEFuYW9uZGEgNC40LjAgKDY0LWJpdCl8IChkZWZhdWx0LCBNYXkgMTEgMjAxNywgMTM6MjU6MjQpIFtNU0Mgdi4xOTAwIDY0IGJpdCAoQU1ENjQpXSdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uZGFTZXJ2aWNlLnNldHVwKGMgPT4gYy5nZXRJbnRlcnByZXRlclBhdGgoVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucyhlbnZpcm9ubWVudFBhdGggPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93cyA/IHBhdGguam9pbihlbnZpcm9ubWVudFBhdGgsICdweXRob24uZXhlJykgOiBwYXRoLmpvaW4oZW52aXJvbm1lbnRQYXRoLCAnYmluJywgJ3B5dGhvbicpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW5mby5lbnZzLmZvckVhY2godmFsaWRQYXRoID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB5dGhvblBhdGggPSBpc1dpbmRvd3MgPyBwYXRoLmpvaW4odmFsaWRQYXRoLCAncHl0aG9uLmV4ZScpIDogcGF0aC5qb2luKHZhbGlkUGF0aCwgJ2JpbicsICdweXRob24nKTtcclxuICAgICAgICAgICAgICAgIGZpbGVTeXN0ZW0uc2V0dXAoZnMgPT4gZnMuZmlsZUV4aXN0cyhUeXBlTW9xLkl0LmlzVmFsdWUocHl0aG9uUGF0aCkpKS5yZXR1cm5zKCgpID0+IFByb21pc2UucmVzb2x2ZSh0cnVlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbnRlcnByZXRlckhlbHBlci5zZXR1cChpID0+IGkuZ2V0SW50ZXJwcmV0ZXJJbmZvcm1hdGlvbihUeXBlTW9xLkl0LmlzQW55KCkpKS5yZXR1cm5zKCgpID0+IFByb21pc2UucmVzb2x2ZSh7IHZlcnNpb246ICcnIH0pKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJwcmV0ZXJzID0geWllbGQgY29uZGFFbnZTZXJ2aWNlXzEucGFyc2VDb25kYUluZm8oaW5mbywgY29uZGFTZXJ2aWNlLm9iamVjdCwgZmlsZVN5c3RlbS5vYmplY3QsIGludGVycHJldGVySGVscGVyLm9iamVjdCk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnMubGVuZ3RoLCAxLCAnSW5jb3JyZWN0IG51bWJlciBvZiBlbnRyaWVzJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGgxID0gcGF0aC5qb2luKGluZm8uZW52c1swXSwgaXNXaW5kb3dzID8gJ3B5dGhvbi5leGUnIDogcGF0aC5qb2luKCdiaW4nLCAncHl0aG9uJykpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzBdLnBhdGgsIHBhdGgxLCAnSW5jb3JyZWN0IHBhdGggZm9yIGZpcnN0IGVudicpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzBdLmNvbXBhbnlEaXNwbGF5TmFtZSwgY29uZGFfMS5BbmFjb25kYUNvbXBhbnlOYW1lLCAnSW5jb3JyZWN0IGNvbXBhbnkgZGlzcGxheSBuYW1lIGZvciBmaXJzdCBlbnYnKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVyc1swXS50eXBlLCBjb250cmFjdHNfMS5JbnRlcnByZXRlclR5cGUuQ29uZGEsICdFbnZpcm9ubWVudCBub3QgZGV0ZWN0ZWQgYXMgYSBjb25kYSBlbnZpcm9ubWVudCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVzdCgnTXVzdCB1c2UgdGhlIGRlZmF1bHQgZGlzcGxheSBuYW1lIGlmIHN5cy52ZXJzaW9uIGlzIGludmFsaWQgKG5vbiB3aW5kb3dzKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCB1c2VEZWZhdWx0TmFtZUlmU3lzVmVyc2lvbklzSW52YWxpZChmYWxzZSk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdNdXN0IHVzZSB0aGUgZGVmYXVsdCBkaXNwbGF5IG5hbWUgaWYgc3lzLnZlcnNpb24gaXMgaW52YWxpZCAod2luZG93cyknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgdXNlRGVmYXVsdE5hbWVJZlN5c1ZlcnNpb25Jc0ludmFsaWQodHJ1ZSk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiB1c2VEZWZhdWx0TmFtZUlmU3lzVmVyc2lvbklzVmFsaWRBbmRTdWZmaXhXaXRoRW52aXJvbm1lbnROYW1lKGlzV2luZG93cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBlbnZzOiBbcGF0aC5qb2luKGVudmlyb25tZW50c1BhdGgsICdjb25kYScsICdlbnZzJywgJ251bXB5JyldLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdF9wcmVmaXg6ICcnLFxyXG4gICAgICAgICAgICAgICAgJ3N5cy52ZXJzaW9uJzogJzMuNi4xIHxBbmFvbmRhIDQuNC4wICg2NC1iaXQpfCAoZGVmYXVsdCwgTWF5IDExIDIwMTcsIDEzOjI1OjI0KSBbTVNDIHYuMTkwMCA2NCBiaXQgKEFNRDY0KV0nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGludGVycHJldGVySGVscGVyLnNldHVwKGkgPT4gaS5nZXRJbnRlcnByZXRlckluZm9ybWF0aW9uKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgdmVyc2lvbjogJycgfSkpO1xyXG4gICAgICAgICAgICBjb25kYVNlcnZpY2Uuc2V0dXAoYyA9PiBjLmdldENvbmRhSW5mbygpKS5yZXR1cm5zKCgpID0+IFByb21pc2UucmVzb2x2ZShpbmZvKSk7XHJcbiAgICAgICAgICAgIGNvbmRhU2VydmljZS5zZXR1cChjID0+IGMuZ2V0Q29uZGFFbnZpcm9ubWVudHMoVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUoW1xyXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnYmFzZScsIHBhdGg6IGVudmlyb25tZW50c1BhdGggfSxcclxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ251bXB5JywgcGF0aDogcGF0aC5qb2luKGVudmlyb25tZW50c1BhdGgsICdjb25kYScsICdlbnZzJywgJ251bXB5JykgfSxcclxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ3NjaXB5JywgcGF0aDogcGF0aC5qb2luKGVudmlyb25tZW50c1BhdGgsICdjb25kYScsICdlbnZzJywgJ3NjaXB5JykgfVxyXG4gICAgICAgICAgICBdKSk7XHJcbiAgICAgICAgICAgIGNvbmRhU2VydmljZS5zZXR1cChjID0+IGMuZ2V0SW50ZXJwcmV0ZXJQYXRoKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoZW52aXJvbm1lbnRQYXRoID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1dpbmRvd3MgPyBwYXRoLmpvaW4oZW52aXJvbm1lbnRQYXRoLCAncHl0aG9uLmV4ZScpIDogcGF0aC5qb2luKGVudmlyb25tZW50UGF0aCwgJ2JpbicsICdweXRob24nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGluZm8uZW52cy5mb3JFYWNoKHZhbGlkUGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBweXRob25QYXRoID0gaXNXaW5kb3dzID8gcGF0aC5qb2luKHZhbGlkUGF0aCwgJ3B5dGhvbi5leGUnKSA6IHBhdGguam9pbih2YWxpZFBhdGgsICdiaW4nLCAncHl0aG9uJyk7XHJcbiAgICAgICAgICAgICAgICBmaWxlU3lzdGVtLnNldHVwKGZzID0+IGZzLmZpbGVFeGlzdHMoVHlwZU1vcS5JdC5pc1ZhbHVlKHB5dGhvblBhdGgpKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUodHJ1ZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW50ZXJwcmV0ZXJIZWxwZXIuc2V0dXAoaSA9PiBpLmdldEludGVycHJldGVySW5mb3JtYXRpb24oVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSk7XHJcbiAgICAgICAgICAgIGZpbGVTeXN0ZW0uc2V0dXAoZnMgPT4gZnMuYXJlUGF0aHNTYW1lKFR5cGVNb3EuSXQuaXNBbnkoKSwgVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucygocDEsIHAyKSA9PiBpc1dpbmRvd3MgPyBwMSA9PT0gcDIgOiBwMS50b1VwcGVyQ2FzZSgpID09PSBwMi50b1VwcGVyQ2FzZSgpKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJwcmV0ZXJzID0geWllbGQgY29uZGFQcm92aWRlci5nZXRJbnRlcnByZXRlcnMoKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVycy5sZW5ndGgsIDEsICdJbmNvcnJlY3QgbnVtYmVyIG9mIGVudHJpZXMnKTtcclxuICAgICAgICAgICAgY29uc3QgcGF0aDEgPSBwYXRoLmpvaW4oaW5mby5lbnZzWzBdLCBpc1dpbmRvd3MgPyAncHl0aG9uLmV4ZScgOiBwYXRoLmpvaW4oJ2JpbicsICdweXRob24nKSk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMF0ucGF0aCwgcGF0aDEsICdJbmNvcnJlY3QgcGF0aCBmb3IgZmlyc3QgZW52Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMF0uY29tcGFueURpc3BsYXlOYW1lLCBjb25kYV8xLkFuYWNvbmRhQ29tcGFueU5hbWUsICdJbmNvcnJlY3QgY29tcGFueSBkaXNwbGF5IG5hbWUgZm9yIGZpcnN0IGVudicpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzBdLnR5cGUsIGNvbnRyYWN0c18xLkludGVycHJldGVyVHlwZS5Db25kYSwgJ0Vudmlyb25tZW50IG5vdCBkZXRlY3RlZCBhcyBhIGNvbmRhIGVudmlyb25tZW50Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0ZXN0KCdNdXN0IHVzZSB0aGUgZGVmYXVsdCBkaXNwbGF5IG5hbWUgaWYgc3lzLnZlcnNpb24gaXMgaW52YWxpZCBhbmQgc3VmZml4ZWQgd2l0aCBlbnZpcm9ubWVudCBuYW1lIChub24gd2luZG93cyknLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgdXNlRGVmYXVsdE5hbWVJZlN5c1ZlcnNpb25Jc1ZhbGlkQW5kU3VmZml4V2l0aEVudmlyb25tZW50TmFtZShmYWxzZSk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdNdXN0IHVzZSB0aGUgZGVmYXVsdCBkaXNwbGF5IG5hbWUgaWYgc3lzLnZlcnNpb24gaXMgaW52YWxpZCBhbmQgc3VmZml4ZWQgd2l0aCBlbnZpcm9ubWVudCBuYW1lICh3aW5kb3dzKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCB1c2VEZWZhdWx0TmFtZUlmU3lzVmVyc2lvbklzVmFsaWRBbmRTdWZmaXhXaXRoRW52aXJvbm1lbnROYW1lKGZhbHNlKTtcclxuICAgIH0pKTtcclxuICAgIGZ1bmN0aW9uIHVzZURlZmF1bHROYW1lSWZTeXNWZXJzaW9uSXNFbXB0eShpc1dpbmRvd3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgZW52czogW3BhdGguam9pbihlbnZpcm9ubWVudHNQYXRoLCAnY29uZGEnLCAnZW52cycsICdudW1weScpXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25kYVNlcnZpY2Uuc2V0dXAoYyA9PiBjLmdldEludGVycHJldGVyUGF0aChUeXBlTW9xLkl0LmlzQW55KCkpKS5yZXR1cm5zKGVudmlyb25tZW50UGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNXaW5kb3dzID8gcGF0aC5qb2luKGVudmlyb25tZW50UGF0aCwgJ3B5dGhvbi5leGUnKSA6IHBhdGguam9pbihlbnZpcm9ubWVudFBhdGgsICdiaW4nLCAncHl0aG9uJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbmZvLmVudnMuZm9yRWFjaCh2YWxpZFBhdGggPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHl0aG9uUGF0aCA9IGlzV2luZG93cyA/IHBhdGguam9pbih2YWxpZFBhdGgsICdweXRob24uZXhlJykgOiBwYXRoLmpvaW4odmFsaWRQYXRoLCAnYmluJywgJ3B5dGhvbicpO1xyXG4gICAgICAgICAgICAgICAgZmlsZVN5c3RlbS5zZXR1cChmcyA9PiBmcy5maWxlRXhpc3RzKFR5cGVNb3EuSXQuaXNWYWx1ZShweXRob25QYXRoKSkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHRydWUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGludGVycHJldGVySGVscGVyLnNldHVwKGkgPT4gaS5nZXRJbnRlcnByZXRlckluZm9ybWF0aW9uKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgdmVyc2lvbjogJycgfSkpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcnByZXRlcnMgPSB5aWVsZCBjb25kYUVudlNlcnZpY2VfMS5wYXJzZUNvbmRhSW5mbyhpbmZvLCBjb25kYVNlcnZpY2Uub2JqZWN0LCBmaWxlU3lzdGVtLm9iamVjdCwgaW50ZXJwcmV0ZXJIZWxwZXIub2JqZWN0KTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVycy5sZW5ndGgsIDEsICdJbmNvcnJlY3QgbnVtYmVyIG9mIGVudHJpZXMnKTtcclxuICAgICAgICAgICAgY29uc3QgcGF0aDEgPSBwYXRoLmpvaW4oaW5mby5lbnZzWzBdLCBpc1dpbmRvd3MgPyAncHl0aG9uLmV4ZScgOiBwYXRoLmpvaW4oJ2JpbicsICdweXRob24nKSk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMF0ucGF0aCwgcGF0aDEsICdJbmNvcnJlY3QgcGF0aCBmb3IgZmlyc3QgZW52Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbMF0uY29tcGFueURpc3BsYXlOYW1lLCBjb25kYV8xLkFuYWNvbmRhQ29tcGFueU5hbWUsICdJbmNvcnJlY3QgY29tcGFueSBkaXNwbGF5IG5hbWUgZm9yIGZpcnN0IGVudicpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzBdLnR5cGUsIGNvbnRyYWN0c18xLkludGVycHJldGVyVHlwZS5Db25kYSwgJ0Vudmlyb25tZW50IG5vdCBkZXRlY3RlZCBhcyBhIGNvbmRhIGVudmlyb25tZW50Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0ZXN0KCdNdXN0IHVzZSB0aGUgZGVmYXVsdCBkaXNwbGF5IG5hbWUgaWYgc3lzLnZlcnNpb24gaXMgZW1wdHkgKG5vbiB3aW5kb3dzKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCB1c2VEZWZhdWx0TmFtZUlmU3lzVmVyc2lvbklzRW1wdHkoZmFsc2UpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnTXVzdCB1c2UgdGhlIGRlZmF1bHQgZGlzcGxheSBuYW1lIGlmIHN5cy52ZXJzaW9uIGlzIGVtcHR5ICh3aW5kb3dzKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCB1c2VEZWZhdWx0TmFtZUlmU3lzVmVyc2lvbklzRW1wdHkodHJ1ZSk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiB1c2VEZWZhdWx0TmFtZUlmU3lzVmVyc2lvbklzRW1wdHlBbmRTdWZmaXhXaXRoRW52aXJvbm1lbnROYW1lKGlzV2luZG93cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBlbnZzOiBbcGF0aC5qb2luKGVudmlyb25tZW50c1BhdGgsICdjb25kYScsICdlbnZzJywgJ251bXB5JyldXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbmRhU2VydmljZS5zZXR1cChjID0+IGMuZ2V0SW50ZXJwcmV0ZXJQYXRoKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoZW52aXJvbm1lbnRQYXRoID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1dpbmRvd3MgPyBwYXRoLmpvaW4oZW52aXJvbm1lbnRQYXRoLCAncHl0aG9uLmV4ZScpIDogcGF0aC5qb2luKGVudmlyb25tZW50UGF0aCwgJ2JpbicsICdweXRob24nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGluZm8uZW52cy5mb3JFYWNoKHZhbGlkUGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBweXRob25QYXRoID0gaXNXaW5kb3dzID8gcGF0aC5qb2luKHZhbGlkUGF0aCwgJ3B5dGhvbi5leGUnKSA6IHBhdGguam9pbih2YWxpZFBhdGgsICdiaW4nLCAncHl0aG9uJyk7XHJcbiAgICAgICAgICAgICAgICBmaWxlU3lzdGVtLnNldHVwKGZzID0+IGZzLmZpbGVFeGlzdHMoVHlwZU1vcS5JdC5pc1ZhbHVlKHB5dGhvblBhdGgpKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUodHJ1ZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW50ZXJwcmV0ZXJIZWxwZXIuc2V0dXAoaSA9PiBpLmdldEludGVycHJldGVySW5mb3JtYXRpb24oVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUoeyB2ZXJzaW9uOiAnJyB9KSk7XHJcbiAgICAgICAgICAgIGNvbmRhU2VydmljZS5zZXR1cChjID0+IGMuZ2V0Q29uZGFGaWxlKCkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdjb25kYScpKTtcclxuICAgICAgICAgICAgY29uZGFTZXJ2aWNlLnNldHVwKGMgPT4gYy5nZXRDb25kYUluZm8oKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUoaW5mbykpO1xyXG4gICAgICAgICAgICBjb25kYVNlcnZpY2Uuc2V0dXAoYyA9PiBjLmdldENvbmRhRW52aXJvbm1lbnRzKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFtcclxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2Jhc2UnLCBwYXRoOiBlbnZpcm9ubWVudHNQYXRoIH0sXHJcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdudW1weScsIHBhdGg6IHBhdGguam9pbihlbnZpcm9ubWVudHNQYXRoLCAnY29uZGEnLCAnZW52cycsICdudW1weScpIH0sXHJcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdzY2lweScsIHBhdGg6IHBhdGguam9pbihlbnZpcm9ubWVudHNQYXRoLCAnY29uZGEnLCAnZW52cycsICdzY2lweScpIH1cclxuICAgICAgICAgICAgXSkpO1xyXG4gICAgICAgICAgICBmaWxlU3lzdGVtLnNldHVwKGZzID0+IGZzLmFyZVBhdGhzU2FtZShUeXBlTW9xLkl0LmlzQW55KCksIFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoKHAxLCBwMikgPT4gaXNXaW5kb3dzID8gcDEgPT09IHAyIDogcDEudG9VcHBlckNhc2UoKSA9PT0gcDIudG9VcHBlckNhc2UoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVycHJldGVycyA9IHlpZWxkIGNvbmRhUHJvdmlkZXIuZ2V0SW50ZXJwcmV0ZXJzKCk7XHJcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnMubGVuZ3RoLCAxLCAnSW5jb3JyZWN0IG51bWJlciBvZiBlbnRyaWVzJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGgxID0gcGF0aC5qb2luKGluZm8uZW52c1swXSwgaXNXaW5kb3dzID8gJ3B5dGhvbi5leGUnIDogcGF0aC5qb2luKCdiaW4nLCAncHl0aG9uJykpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzBdLnBhdGgsIHBhdGgxLCAnSW5jb3JyZWN0IHBhdGggZm9yIGZpcnN0IGVudicpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzBdLmNvbXBhbnlEaXNwbGF5TmFtZSwgY29uZGFfMS5BbmFjb25kYUNvbXBhbnlOYW1lLCAnSW5jb3JyZWN0IGNvbXBhbnkgZGlzcGxheSBuYW1lIGZvciBmaXJzdCBlbnYnKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVyc1swXS50eXBlLCBjb250cmFjdHNfMS5JbnRlcnByZXRlclR5cGUuQ29uZGEsICdFbnZpcm9ubWVudCBub3QgZGV0ZWN0ZWQgYXMgYSBjb25kYSBlbnZpcm9ubWVudCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVzdCgnTXVzdCB1c2UgdGhlIGRlZmF1bHQgZGlzcGxheSBuYW1lIGlmIHN5cy52ZXJzaW9uIGlzIGVtcHR5IGFuZCBzdWZmaXhlZCB3aXRoIGVudmlyb25tZW50IG5hbWUgKG5vbiB3aW5kb3dzKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCB1c2VEZWZhdWx0TmFtZUlmU3lzVmVyc2lvbklzRW1wdHlBbmRTdWZmaXhXaXRoRW52aXJvbm1lbnROYW1lKGZhbHNlKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ011c3QgdXNlIHRoZSBkZWZhdWx0IGRpc3BsYXkgbmFtZSBpZiBzeXMudmVyc2lvbiBpcyBlbXB0eSBhbmQgc3VmZml4ZWQgd2l0aCBlbnZpcm9ubWVudCBuYW1lICh3aW5kb3dzKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCB1c2VEZWZhdWx0TmFtZUlmU3lzVmVyc2lvbklzRW1wdHlBbmRTdWZmaXhXaXRoRW52aXJvbm1lbnROYW1lKHRydWUpO1xyXG4gICAgfSkpO1xyXG4gICAgZnVuY3Rpb24gaW5jbHVkZURlZmF1bHRQcmVmaXhJbnRvTGlzdE9mSW50ZXJwcmV0ZXJzKGlzV2luZG93cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0X3ByZWZpeDogcGF0aC5qb2luKGVudmlyb25tZW50c1BhdGgsICdjb25kYScsICdlbnZzJywgJ251bXB5JylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uZGFTZXJ2aWNlLnNldHVwKGMgPT4gYy5nZXRJbnRlcnByZXRlclBhdGgoVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucyhlbnZpcm9ubWVudFBhdGggPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93cyA/IHBhdGguam9pbihlbnZpcm9ubWVudFBhdGgsICdweXRob24uZXhlJykgOiBwYXRoLmpvaW4oZW52aXJvbm1lbnRQYXRoLCAnYmluJywgJ3B5dGhvbicpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgcHl0aG9uUGF0aCA9IGlzV2luZG93cyA/IHBhdGguam9pbihpbmZvLmRlZmF1bHRfcHJlZml4LCAncHl0aG9uLmV4ZScpIDogcGF0aC5qb2luKGluZm8uZGVmYXVsdF9wcmVmaXgsICdiaW4nLCAncHl0aG9uJyk7XHJcbiAgICAgICAgICAgIGZpbGVTeXN0ZW0uc2V0dXAoZnMgPT4gZnMuZmlsZUV4aXN0cyhUeXBlTW9xLkl0LmlzVmFsdWUocHl0aG9uUGF0aCkpKS5yZXR1cm5zKCgpID0+IFByb21pc2UucmVzb2x2ZSh0cnVlKSk7XHJcbiAgICAgICAgICAgIGludGVycHJldGVySGVscGVyLnNldHVwKGkgPT4gaS5nZXRJbnRlcnByZXRlckluZm9ybWF0aW9uKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgdmVyc2lvbjogJycgfSkpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcnByZXRlcnMgPSB5aWVsZCBjb25kYUVudlNlcnZpY2VfMS5wYXJzZUNvbmRhSW5mbyhpbmZvLCBjb25kYVNlcnZpY2Uub2JqZWN0LCBmaWxlU3lzdGVtLm9iamVjdCwgaW50ZXJwcmV0ZXJIZWxwZXIub2JqZWN0KTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVycy5sZW5ndGgsIDEsICdJbmNvcnJlY3QgbnVtYmVyIG9mIGVudHJpZXMnKTtcclxuICAgICAgICAgICAgY29uc3QgcGF0aDEgPSBwYXRoLmpvaW4oaW5mby5kZWZhdWx0X3ByZWZpeCwgaXNXaW5kb3dzID8gJ3B5dGhvbi5leGUnIDogcGF0aC5qb2luKCdiaW4nLCAncHl0aG9uJykpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzBdLnBhdGgsIHBhdGgxLCAnSW5jb3JyZWN0IHBhdGggZm9yIGZpcnN0IGVudicpO1xyXG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW50ZXJwcmV0ZXJzWzBdLmNvbXBhbnlEaXNwbGF5TmFtZSwgY29uZGFfMS5BbmFjb25kYUNvbXBhbnlOYW1lLCAnSW5jb3JyZWN0IGNvbXBhbnkgZGlzcGxheSBuYW1lIGZvciBmaXJzdCBlbnYnKTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVyc1swXS50eXBlLCBjb250cmFjdHNfMS5JbnRlcnByZXRlclR5cGUuQ29uZGEsICdFbnZpcm9ubWVudCBub3QgZGV0ZWN0ZWQgYXMgYSBjb25kYSBlbnZpcm9ubWVudCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVzdCgnTXVzdCBpbmNsdWRlIHRoZSBkZWZhdWx0X3ByZWZpeCBpbnRvIHRoZSBsaXN0IG9mIGludGVycHJldGVycyAobm9uIHdpbmRvd3MpJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIGluY2x1ZGVEZWZhdWx0UHJlZml4SW50b0xpc3RPZkludGVycHJldGVycyhmYWxzZSk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdNdXN0IGluY2x1ZGUgdGhlIGRlZmF1bHRfcHJlZml4IGludG8gdGhlIGxpc3Qgb2YgaW50ZXJwcmV0ZXJzICh3aW5kb3dzKScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBpbmNsdWRlRGVmYXVsdFByZWZpeEludG9MaXN0T2ZJbnRlcnByZXRlcnModHJ1ZSk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiBleGNsdWRlSW50ZXJwcmV0ZXJzVGhhdERvTm90RXhpc3RPbkZpbGVTeXN0ZW0oaXNXaW5kb3dzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGVudnM6IFtwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ2NvbmRhJywgJ2VudnMnLCAnbnVtcHknKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ3BhdGgwJywgJ29uZS5leGUnKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ3BhdGgxJywgJ29uZS5leGUnKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ3BhdGgyJywgJ29uZS5leGUnKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ2NvbmRhJywgJ2VudnMnLCAnc2NpcHknKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4oZW52aXJvbm1lbnRzUGF0aCwgJ3BhdGgzJywgJ3RocmVlLmV4ZScpXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCB2YWxpZFBhdGhzID0gaW5mby5lbnZzLmZpbHRlcigoXywgaW5kZXgpID0+IGluZGV4ICUgMiA9PT0gMCk7XHJcbiAgICAgICAgICAgIGludGVycHJldGVySGVscGVyLnNldHVwKGkgPT4gaS5nZXRJbnRlcnByZXRlckluZm9ybWF0aW9uKFR5cGVNb3EuSXQuaXNBbnkoKSkpLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgdmVyc2lvbjogJycgfSkpO1xyXG4gICAgICAgICAgICB2YWxpZFBhdGhzLmZvckVhY2goZW52UGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25kYVNlcnZpY2Uuc2V0dXAoYyA9PiBjLmdldEludGVycHJldGVyUGF0aChUeXBlTW9xLkl0LmlzVmFsdWUoZW52UGF0aCkpKS5yZXR1cm5zKGVudmlyb25tZW50UGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93cyA/IHBhdGguam9pbihlbnZpcm9ubWVudFBhdGgsICdweXRob24uZXhlJykgOiBwYXRoLmpvaW4oZW52aXJvbm1lbnRQYXRoLCAnYmluJywgJ3B5dGhvbicpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBweXRob25QYXRoID0gaXNXaW5kb3dzID8gcGF0aC5qb2luKGVudlBhdGgsICdweXRob24uZXhlJykgOiBwYXRoLmpvaW4oZW52UGF0aCwgJ2JpbicsICdweXRob24nKTtcclxuICAgICAgICAgICAgICAgIGZpbGVTeXN0ZW0uc2V0dXAoZnMgPT4gZnMuZmlsZUV4aXN0cyhUeXBlTW9xLkl0LmlzVmFsdWUocHl0aG9uUGF0aCkpKS5yZXR1cm5zKCgpID0+IFByb21pc2UucmVzb2x2ZSh0cnVlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcnByZXRlcnMgPSB5aWVsZCBjb25kYUVudlNlcnZpY2VfMS5wYXJzZUNvbmRhSW5mbyhpbmZvLCBjb25kYVNlcnZpY2Uub2JqZWN0LCBmaWxlU3lzdGVtLm9iamVjdCwgaW50ZXJwcmV0ZXJIZWxwZXIub2JqZWN0KTtcclxuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVycy5sZW5ndGgsIHZhbGlkUGF0aHMubGVuZ3RoLCAnSW5jb3JyZWN0IG51bWJlciBvZiBlbnRyaWVzJyk7XHJcbiAgICAgICAgICAgIHZhbGlkUGF0aHMuZm9yRWFjaCgoZW52UGF0aCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbnRlcnByZXRlcnNbaW5kZXhdLmVudlBhdGgsIGVudlBhdGgsICdJbmNvcnJlY3QgZW52IHBhdGgnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB5dGhvblBhdGggPSBpc1dpbmRvd3MgPyBwYXRoLmpvaW4oZW52UGF0aCwgJ3B5dGhvbi5leGUnKSA6IHBhdGguam9pbihlbnZQYXRoLCAnYmluJywgJ3B5dGhvbicpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGludGVycHJldGVyc1tpbmRleF0ucGF0aCwgcHl0aG9uUGF0aCwgJ0luY29ycmVjdCBweXRob24gUGF0aCcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRlc3QoJ011c3QgZXhjbHVkZSBpbnRlcnByZXRlcnMgdGhhdCBkbyBub3QgZXhpc3Qgb24gZGlzYyAobm9uIHdpbmRvd3MpJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIGV4Y2x1ZGVJbnRlcnByZXRlcnNUaGF0RG9Ob3RFeGlzdE9uRmlsZVN5c3RlbShmYWxzZSk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdNdXN0IGV4Y2x1ZGUgaW50ZXJwcmV0ZXJzIHRoYXQgZG8gbm90IGV4aXN0IG9uIGRpc2MgKHdpbmRvd3MpJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIGV4Y2x1ZGVJbnRlcnByZXRlcnNUaGF0RG9Ob3RFeGlzdE9uRmlsZVN5c3RlbSh0cnVlKTtcclxuICAgIH0pKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmRhRW52U2VydmljZS51bml0LnRlc3QuanMubWFwIl19