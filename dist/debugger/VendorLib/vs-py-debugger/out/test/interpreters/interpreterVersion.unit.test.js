"use strict"; // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const chai_1 = require("chai");

const path = require("path");

const typeMoq = require("typemoq");

require("../../client/common/extensions");

const interpreterVersion_1 = require("../../client/interpreter/interpreterVersion");

suite('Interpreters display version', () => {
  let processService;
  let interpreterVersionService;
  setup(() => {
    const processFactory = typeMoq.Mock.ofType();
    processService = typeMoq.Mock.ofType(); // tslint:disable-next-line:no-any

    processService.setup(p => p.then).returns(() => undefined);
    processFactory.setup(p => p.create()).returns(() => Promise.resolve(processService.object));
    interpreterVersionService = new interpreterVersion_1.InterpreterVersionService(processFactory.object);
  });
  test('Must return the Python Version', () => __awaiter(void 0, void 0, void 0, function* () {
    const pythonPath = path.join('a', 'b', 'python');
    const pythonVersion = 'Output from the Procecss';
    processService.setup(p => p.exec(typeMoq.It.isValue(pythonPath), typeMoq.It.isValue(['--version']), typeMoq.It.isAny())).returns(() => Promise.resolve({
      stdout: pythonVersion
    })).verifiable(typeMoq.Times.once());
    const pyVersion = yield interpreterVersionService.getVersion(pythonPath, 'DEFAULT_TEST_VALUE');
    chai_1.assert.equal(pyVersion, pythonVersion, 'Incorrect version');
  }));
  test('Must return the default value when Python path is invalid', () => __awaiter(void 0, void 0, void 0, function* () {
    const pythonPath = path.join('a', 'b', 'python');
    processService.setup(p => p.exec(typeMoq.It.isValue(pythonPath), typeMoq.It.isValue(['--version']), typeMoq.It.isAny())).returns(() => Promise.reject({})).verifiable(typeMoq.Times.once());
    const pyVersion = yield interpreterVersionService.getVersion(pythonPath, 'DEFAULT_TEST_VALUE');
    chai_1.assert.equal(pyVersion, 'DEFAULT_TEST_VALUE', 'Incorrect version');
  }));
  test('Must return the pip Version.', () => __awaiter(void 0, void 0, void 0, function* () {
    const pythonPath = path.join('a', 'b', 'python');
    const pipVersion = '1.2.3';
    processService.setup(p => p.exec(typeMoq.It.isValue(pythonPath), typeMoq.It.isValue(['-m', 'pip', '--version']), typeMoq.It.isAny())).returns(() => Promise.resolve({
      stdout: pipVersion
    })).verifiable(typeMoq.Times.once());
    const pyVersion = yield interpreterVersionService.getPipVersion(pythonPath);
    chai_1.assert.equal(pyVersion, pipVersion, 'Incorrect version');
  }));
  test('Must throw an exception when pip version cannot be determined', () => __awaiter(void 0, void 0, void 0, function* () {
    const pythonPath = path.join('a', 'b', 'python');
    processService.setup(p => p.exec(typeMoq.It.isValue(pythonPath), typeMoq.It.isValue(['-m', 'pip', '--version']), typeMoq.It.isAny())).returns(() => Promise.reject('error')).verifiable(typeMoq.Times.once());
    const pipVersionPromise = interpreterVersionService.getPipVersion(pythonPath);
    yield chai_1.expect(pipVersionPromise).to.be.rejectedWith();
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImludGVycHJldGVyVmVyc2lvbi51bml0LnRlc3QuanMiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImNoYWlfMSIsInJlcXVpcmUiLCJwYXRoIiwidHlwZU1vcSIsImludGVycHJldGVyVmVyc2lvbl8xIiwic3VpdGUiLCJwcm9jZXNzU2VydmljZSIsImludGVycHJldGVyVmVyc2lvblNlcnZpY2UiLCJzZXR1cCIsInByb2Nlc3NGYWN0b3J5IiwiTW9jayIsIm9mVHlwZSIsInAiLCJyZXR1cm5zIiwidW5kZWZpbmVkIiwiY3JlYXRlIiwib2JqZWN0IiwiSW50ZXJwcmV0ZXJWZXJzaW9uU2VydmljZSIsInRlc3QiLCJweXRob25QYXRoIiwiam9pbiIsInB5dGhvblZlcnNpb24iLCJleGVjIiwiSXQiLCJpc1ZhbHVlIiwiaXNBbnkiLCJzdGRvdXQiLCJ2ZXJpZmlhYmxlIiwiVGltZXMiLCJvbmNlIiwicHlWZXJzaW9uIiwiZ2V0VmVyc2lvbiIsImFzc2VydCIsImVxdWFsIiwicGlwVmVyc2lvbiIsImdldFBpcFZlcnNpb24iLCJwaXBWZXJzaW9uUHJvbWlzZSIsImV4cGVjdCIsInRvIiwiYmUiLCJyZWplY3RlZFdpdGgiXSwibWFwcGluZ3MiOiJBQUFBLGEsQ0FDQTtBQUNBOztBQUNBLElBQUlBLFNBQVMsR0FBSSxVQUFRLFNBQUtBLFNBQWQsSUFBNEIsVUFBVUMsT0FBVixFQUFtQkMsVUFBbkIsRUFBK0JDLENBQS9CLEVBQWtDQyxTQUFsQyxFQUE2QztBQUNyRixTQUFPLEtBQUtELENBQUMsS0FBS0EsQ0FBQyxHQUFHRSxPQUFULENB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QU47QUFDSCxHQVJvRixDQUFqRixDQUFKO0FBU0gsQ0FqREksQ0FBTCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNoYWlfMSA9IHJlcXVpcmUoXCJjaGFpXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IHR5cGVNb3EgPSByZXF1aXJlKFwidHlwZW1vcVwiKTtcclxucmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21tb24vZXh0ZW5zaW9uc1wiKTtcclxuY29uc3QgaW50ZXJwcmV0ZXJWZXJzaW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2ludGVycHJldGVyL2ludGVycHJldGVyVmVyc2lvblwiKTtcclxuc3VpdGUoJ0ludGVycHJldGVycyBkaXNwbGF5IHZlcnNpb24nLCAoKSA9PiB7XHJcbiAgICBsZXQgcHJvY2Vzc1NlcnZpY2U7XHJcbiAgICBsZXQgaW50ZXJwcmV0ZXJWZXJzaW9uU2VydmljZTtcclxuICAgIHNldHVwKCgpID0+IHtcclxuICAgICAgICBjb25zdCBwcm9jZXNzRmFjdG9yeSA9IHR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICBwcm9jZXNzU2VydmljZSA9IHR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgcHJvY2Vzc1NlcnZpY2Uuc2V0dXAoKHApID0+IHAudGhlbikucmV0dXJucygoKSA9PiB1bmRlZmluZWQpO1xyXG4gICAgICAgIHByb2Nlc3NGYWN0b3J5LnNldHVwKHAgPT4gcC5jcmVhdGUoKSkucmV0dXJucygoKSA9PiBQcm9taXNlLnJlc29sdmUocHJvY2Vzc1NlcnZpY2Uub2JqZWN0KSk7XHJcbiAgICAgICAgaW50ZXJwcmV0ZXJWZXJzaW9uU2VydmljZSA9IG5ldyBpbnRlcnByZXRlclZlcnNpb25fMS5JbnRlcnByZXRlclZlcnNpb25TZXJ2aWNlKHByb2Nlc3NGYWN0b3J5Lm9iamVjdCk7XHJcbiAgICB9KTtcclxuICAgIHRlc3QoJ011c3QgcmV0dXJuIHRoZSBQeXRob24gVmVyc2lvbicsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBweXRob25QYXRoID0gcGF0aC5qb2luKCdhJywgJ2InLCAncHl0aG9uJyk7XHJcbiAgICAgICAgY29uc3QgcHl0aG9uVmVyc2lvbiA9ICdPdXRwdXQgZnJvbSB0aGUgUHJvY2Vjc3MnO1xyXG4gICAgICAgIHByb2Nlc3NTZXJ2aWNlXHJcbiAgICAgICAgICAgIC5zZXR1cChwID0+IHAuZXhlYyh0eXBlTW9xLkl0LmlzVmFsdWUocHl0aG9uUGF0aCksIHR5cGVNb3EuSXQuaXNWYWx1ZShbJy0tdmVyc2lvbiddKSwgdHlwZU1vcS5JdC5pc0FueSgpKSlcclxuICAgICAgICAgICAgLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgc3Rkb3V0OiBweXRob25WZXJzaW9uIH0pKVxyXG4gICAgICAgICAgICAudmVyaWZpYWJsZSh0eXBlTW9xLlRpbWVzLm9uY2UoKSk7XHJcbiAgICAgICAgY29uc3QgcHlWZXJzaW9uID0geWllbGQgaW50ZXJwcmV0ZXJWZXJzaW9uU2VydmljZS5nZXRWZXJzaW9uKHB5dGhvblBhdGgsICdERUZBVUxUX1RFU1RfVkFMVUUnKTtcclxuICAgICAgICBjaGFpXzEuYXNzZXJ0LmVxdWFsKHB5VmVyc2lvbiwgcHl0aG9uVmVyc2lvbiwgJ0luY29ycmVjdCB2ZXJzaW9uJyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdNdXN0IHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIFB5dGhvbiBwYXRoIGlzIGludmFsaWQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHl0aG9uUGF0aCA9IHBhdGguam9pbignYScsICdiJywgJ3B5dGhvbicpO1xyXG4gICAgICAgIHByb2Nlc3NTZXJ2aWNlXHJcbiAgICAgICAgICAgIC5zZXR1cChwID0+IHAuZXhlYyh0eXBlTW9xLkl0LmlzVmFsdWUocHl0aG9uUGF0aCksIHR5cGVNb3EuSXQuaXNWYWx1ZShbJy0tdmVyc2lvbiddKSwgdHlwZU1vcS5JdC5pc0FueSgpKSlcclxuICAgICAgICAgICAgLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZWplY3Qoe30pKVxyXG4gICAgICAgICAgICAudmVyaWZpYWJsZSh0eXBlTW9xLlRpbWVzLm9uY2UoKSk7XHJcbiAgICAgICAgY29uc3QgcHlWZXJzaW9uID0geWllbGQgaW50ZXJwcmV0ZXJWZXJzaW9uU2VydmljZS5nZXRWZXJzaW9uKHB5dGhvblBhdGgsICdERUZBVUxUX1RFU1RfVkFMVUUnKTtcclxuICAgICAgICBjaGFpXzEuYXNzZXJ0LmVxdWFsKHB5VmVyc2lvbiwgJ0RFRkFVTFRfVEVTVF9WQUxVRScsICdJbmNvcnJlY3QgdmVyc2lvbicpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnTXVzdCByZXR1cm4gdGhlIHBpcCBWZXJzaW9uLicsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBweXRob25QYXRoID0gcGF0aC5qb2luKCdhJywgJ2InLCAncHl0aG9uJyk7XHJcbiAgICAgICAgY29uc3QgcGlwVmVyc2lvbiA9ICcxLjIuMyc7XHJcbiAgICAgICAgcHJvY2Vzc1NlcnZpY2VcclxuICAgICAgICAgICAgLnNldHVwKHAgPT4gcC5leGVjKHR5cGVNb3EuSXQuaXNWYWx1ZShweXRob25QYXRoKSwgdHlwZU1vcS5JdC5pc1ZhbHVlKFsnLW0nLCAncGlwJywgJy0tdmVyc2lvbiddKSwgdHlwZU1vcS5JdC5pc0FueSgpKSlcclxuICAgICAgICAgICAgLnJldHVybnMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgc3Rkb3V0OiBwaXBWZXJzaW9uIH0pKVxyXG4gICAgICAgICAgICAudmVyaWZpYWJsZSh0eXBlTW9xLlRpbWVzLm9uY2UoKSk7XHJcbiAgICAgICAgY29uc3QgcHlWZXJzaW9uID0geWllbGQgaW50ZXJwcmV0ZXJWZXJzaW9uU2VydmljZS5nZXRQaXBWZXJzaW9uKHB5dGhvblBhdGgpO1xyXG4gICAgICAgIGNoYWlfMS5hc3NlcnQuZXF1YWwocHlWZXJzaW9uLCBwaXBWZXJzaW9uLCAnSW5jb3JyZWN0IHZlcnNpb24nKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ011c3QgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gcGlwIHZlcnNpb24gY2Fubm90IGJlIGRldGVybWluZWQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHl0aG9uUGF0aCA9IHBhdGguam9pbignYScsICdiJywgJ3B5dGhvbicpO1xyXG4gICAgICAgIHByb2Nlc3NTZXJ2aWNlXHJcbiAgICAgICAgICAgIC5zZXR1cChwID0+IHAuZXhlYyh0eXBlTW9xLkl0LmlzVmFsdWUocHl0aG9uUGF0aCksIHR5cGVNb3EuSXQuaXNWYWx1ZShbJy1tJywgJ3BpcCcsICctLXZlcnNpb24nXSksIHR5cGVNb3EuSXQuaXNBbnkoKSkpXHJcbiAgICAgICAgICAgIC5yZXR1cm5zKCgpID0+IFByb21pc2UucmVqZWN0KCdlcnJvcicpKVxyXG4gICAgICAgICAgICAudmVyaWZpYWJsZSh0eXBlTW9xLlRpbWVzLm9uY2UoKSk7XHJcbiAgICAgICAgY29uc3QgcGlwVmVyc2lvblByb21pc2UgPSBpbnRlcnByZXRlclZlcnNpb25TZXJ2aWNlLmdldFBpcFZlcnNpb24ocHl0aG9uUGF0aCk7XHJcbiAgICAgICAgeWllbGQgY2hhaV8xLmV4cGVjdChwaXBWZXJzaW9uUHJvbWlzZSkudG8uYmUucmVqZWN0ZWRXaXRoKCk7XHJcbiAgICB9KSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnByZXRlclZlcnNpb24udW5pdC50ZXN0LmpzLm1hcCJdfQ==