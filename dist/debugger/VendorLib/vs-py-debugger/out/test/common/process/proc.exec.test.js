// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const chai_1 = require("chai");

const chaiAsPromised = require("chai-as-promised");

const vscode_1 = require("vscode");

const configSettings_1 = require("../../../client/common/configSettings");

const decoder_1 = require("../../../client/common/process/decoder");

const proc_1 = require("../../../client/common/process/proc");

const types_1 = require("../../../client/common/process/types");

const platform_1 = require("../../../client/common/utils/platform");

const common_1 = require("../../common");

const initialize_1 = require("./../../initialize");

chai_1.use(chaiAsPromised); // tslint:disable-next-line:max-func-body-length

suite('ProcessService Observable', () => {
  let pythonPath;
  suiteSetup(() => {
    pythonPath = configSettings_1.PythonSettings.getInstance().pythonPath;
    return initialize_1.initialize();
  });
  setup(initialize_1.initialize);
  teardown(initialize_1.initialize);
  test('exec should output print statements', () => __awaiter(void 0, void 0, void 0, function* () {
    const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
    const printOutput = '1234';
    const result = yield procService.exec(pythonPath, ['-c', `print("${printOutput}")`]);
    chai_1.expect(result).not.to.be.an('undefined', 'result is undefined');
    chai_1.expect(result.stdout.trim()).to.be.equal(printOutput, 'Invalid output');
    chai_1.expect(result.stderr).to.equal(undefined, 'stderr not undefined');
  }));
  test('exec should output print unicode characters', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // This test has not been working for many months in Python 2.7 under
      // Windows. Tracked by #2546. (unicode under Py2.7 is tough!)
      if (common_1.isOs(platform_1.OSType.Windows) && (yield common_1.isPythonVersion('2.7'))) {
        // tslint:disable-next-line:no-invalid-this
        return this.skip();
      }

      const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
      const printOutput = 'öä';
      const result = yield procService.exec(pythonPath, ['-c', `print("${printOutput}")`]);
      chai_1.expect(result).not.to.be.an('undefined', 'result is undefined');
      chai_1.expect(result.stdout.trim()).to.be.equal(printOutput, 'Invalid output');
      chai_1.expect(result.stderr).to.equal(undefined, 'stderr not undefined');
    });
  });
  test('exec should wait for completion of program with new lines', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // tslint:disable-next-line:no-invalid-this
      this.timeout(5000);
      const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
      const pythonCode = ['import sys', 'import time', 'print("1")', 'sys.stdout.flush()', 'time.sleep(1)', 'print("2")', 'sys.stdout.flush()', 'time.sleep(1)', 'print("3")'];
      const result = yield procService.exec(pythonPath, ['-c', pythonCode.join(';')]);
      const outputs = ['1', '2', '3'];
      chai_1.expect(result).not.to.be.an('undefined', 'result is undefined');
      const values = result.stdout.split(/\r?\n/g).map(line => line.trim()).filter(line => line.length > 0);
      chai_1.expect(values).to.deep.equal(outputs, 'Output values are incorrect');
      chai_1.expect(result.stderr).to.equal(undefined, 'stderr not undefined');
    });
  });
  test('exec should wait for completion of program without new lines', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // tslint:disable-next-line:no-invalid-this
      this.timeout(5000);
      const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
      const pythonCode = ['import sys', 'import time', 'sys.stdout.write("1")', 'sys.stdout.flush()', 'time.sleep(1)', 'sys.stdout.write("2")', 'sys.stdout.flush()', 'time.sleep(1)', 'sys.stdout.write("3")'];
      const result = yield procService.exec(pythonPath, ['-c', pythonCode.join(';')]);
      const outputs = ['123'];
      chai_1.expect(result).not.to.be.an('undefined', 'result is undefined');
      const values = result.stdout.split(/\r?\n/g).map(line => line.trim()).filter(line => line.length > 0);
      chai_1.expect(values).to.deep.equal(outputs, 'Output values are incorrect');
      chai_1.expect(result.stderr).to.equal(undefined, 'stderr not undefined');
    });
  });
  test('exec should end when cancellationToken is cancelled', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // tslint:disable-next-line:no-invalid-this
      this.timeout(15000);
      const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
      const pythonCode = ['import sys', 'import time', 'print("1")', 'sys.stdout.flush()', 'time.sleep(10)', 'print("2")', 'sys.stdout.flush()'];
      const cancellationToken = new vscode_1.CancellationTokenSource();
      setTimeout(() => cancellationToken.cancel(), 3000);
      const result = yield procService.exec(pythonPath, ['-c', pythonCode.join(';')], {
        token: cancellationToken.token
      });
      chai_1.expect(result).not.to.be.an('undefined', 'result is undefined');
      const values = result.stdout.split(/\r?\n/g).map(line => line.trim()).filter(line => line.length > 0);
      chai_1.expect(values).to.deep.equal(['1'], 'Output values are incorrect');
      chai_1.expect(result.stderr).to.equal(undefined, 'stderr not undefined');
    });
  });
  test('exec should stream stdout and stderr separately', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // tslint:disable-next-line:no-invalid-this
      this.timeout(7000);
      const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
      const pythonCode = ['import sys', 'import time', 'print("1")', 'sys.stdout.flush()', 'time.sleep(1)', 'sys.stderr.write("a")', 'sys.stderr.flush()', 'time.sleep(1)', 'print("2")', 'sys.stdout.flush()', 'time.sleep(1)', 'sys.stderr.write("b")', 'sys.stderr.flush()', 'time.sleep(1)', 'print("3")', 'sys.stdout.flush()', 'time.sleep(1)', 'sys.stderr.write("c")', 'sys.stderr.flush()'];
      const result = yield procService.exec(pythonPath, ['-c', pythonCode.join(';')]);
      const expectedStdout = ['1', '2', '3'];
      const expectedStderr = ['abc'];
      chai_1.expect(result).not.to.be.an('undefined', 'result is undefined');
      const stdouts = result.stdout.split(/\r?\n/g).map(line => line.trim()).filter(line => line.length > 0);
      chai_1.expect(stdouts).to.deep.equal(expectedStdout, 'stdout values are incorrect');
      const stderrs = result.stderr.split(/\r?\n/g).map(line => line.trim()).filter(line => line.length > 0);
      chai_1.expect(stderrs).to.deep.equal(expectedStderr, 'stderr values are incorrect');
    });
  });
  test('exec should merge stdout and stderr streams', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // tslint:disable-next-line:no-invalid-this
      this.timeout(7000);
      const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
      const pythonCode = ['import sys', 'import time', 'sys.stdout.write("1")', 'sys.stdout.flush()', 'time.sleep(1)', 'sys.stderr.write("a")', 'sys.stderr.flush()', 'time.sleep(1)', 'sys.stdout.write("2")', 'sys.stdout.flush()', 'time.sleep(1)', 'sys.stderr.write("b")', 'sys.stderr.flush()', 'time.sleep(1)', 'sys.stdout.write("3")', 'sys.stdout.flush()', 'time.sleep(1)', 'sys.stderr.write("c")', 'sys.stderr.flush()'];
      const result = yield procService.exec(pythonPath, ['-c', pythonCode.join(';')], {
        mergeStdOutErr: true
      });
      const expectedOutput = ['1a2b3c'];
      chai_1.expect(result).not.to.be.an('undefined', 'result is undefined');
      const outputs = result.stdout.split(/\r?\n/g).map(line => line.trim()).filter(line => line.length > 0);
      chai_1.expect(outputs).to.deep.equal(expectedOutput, 'Output values are incorrect');
    });
  });
  test('exec should throw an error with stderr output', () => __awaiter(void 0, void 0, void 0, function* () {
    const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
    const pythonCode = ['import sys', 'sys.stderr.write("a")', 'sys.stderr.flush()'];
    const result = procService.exec(pythonPath, ['-c', pythonCode.join(';')], {
      throwOnStdErr: true
    });
    yield chai_1.expect(result).to.eventually.be.rejectedWith(types_1.StdErrError, 'a', 'Expected error to be thrown');
  }));
  test('exec should throw an error when spawn file not found', () => __awaiter(void 0, void 0, void 0, function* () {
    const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
    const result = procService.exec(Date.now().toString(), []);
    yield chai_1.expect(result).to.eventually.be.rejected.and.to.have.property('code', 'ENOENT', 'Invalid error code');
  }));
  test('exec should exit without no output', () => __awaiter(void 0, void 0, void 0, function* () {
    const procService = new proc_1.ProcessService(new decoder_1.BufferDecoder());
    const result = yield procService.exec(pythonPath, ['-c', 'import sys', 'sys.exit()']);
    chai_1.expect(result.stdout).equals('', 'stdout is invalid');
    chai_1.expect(result.stderr).equals(undefined, 'stderr is invalid');
  }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByb2MuZXhlYy50ZXN0LmpzIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJjaGFpXzEiLCJyZXF1aXJlIiwiY2hhaUFzUHJvbWlzZWQiLCJ2c2NvZGVfMSIsImNvbmZpZ1NldHRpbmdzXzEiLCJkZWNvZGVyXzEiLCJwcm9jXzEiLCJ0eXBlc18xIiwicGxhdGZvcm1fMSIsImNvbW1vbl8xIiwiaW5pdGlhbGl6ZV8xIiwidXNlIiwic3VpdGUiLCJweXRob25QYXRoIiwic3VpdGVTZXR1cCIsIlB5dGhvblNldHRpbmdzIiwiZ2V0SW5zdGFuY2UiLCJpbml0aWFsaXplIiwic2V0dXAiLCJ0ZWFyZG93biIsInRlc3QiLCJwcm9jU2VydmljZSIsIlByb2Nlc3NTZXJ2aWNlIiwiQnVmZmVyRGVjb2RlciIsInByaW50T3V0cHV0IiwiZXhlYyIsImV4cGVjdCIsIm5vdCIsInRvIiwiYmUiLCJhbiIsInN0ZG91dCIsInRyaW0iLCJlcXVhbCIsInN0ZGVyciIsInVuZGVmaW5lZCIsImlzT3MiLCJPU1R5cGUiLCJXaW5kb3dzIiwiaXNQeXRob25WZXJzaW9uIiwic2tpcCIsInRpbWVvdXQiLCJweXRob25Db2RlIiwiam9pbiIsIm91dHB1dHMiLCJ2YWx1ZXMiLCJzcGxpdCIsIm1hcCIsImxpbmUiLCJmaWx0ZXIiLCJsZW5ndGgiLCJkZWVwIiwiY2FuY2VsbGF0aW9uVG9rZW4iLCJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSIsInNldFRpbWVvdXQiLCJjYW5jZWwiLCJ0b2tlbiIsImV4cGVjdGVkU3Rkb3V0IiwiZXhwZWN0ZWRTdGRlcnIiLCJzdGRvdXRzIiwic3RkZXJycyIsIm1lcmdlU3RkT3V0RXJyIiwiZXhwZWN0ZWRPdXRwdXQiLCJ0aHJvd09uU3RkRXJyIiwiZXZlbnR1YWxseSIsInJlamVjdGVkV2l0aCIsIlN0ZEVyckVycm9yIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwiYW5kIiwiaGF2ZSIsInByb3BlcnR5IiwiZXF1YWxzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsU0FBUyxHQUFJLFVBQVEsU0FBS0EsU0FBZCxJQUE0QixVQUFVQyxPQUFWLEVBQW1CQyxVQUFuQixFQUErQkMsQ0FBL0IsRUFBa0NDLFNBQWxDLEVBQTZDO0FBQ3JGLFNBQU8sS0FBS0QsQ0FBQyxLQUFLQSxDQUFDLEdBQUdFLE9BQVQsQ0FBTixFQUF5QixVQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUN2RCxhQUFTQyxTQUFULENBQW1CQyxLQUFuQixFQUEwQjtBQUFFLFVBQUk7QUFBRUMsUUFBQUEsSUFBSSxDQUFDTixTQUFTLENBQUNPLElBQVYsQ0FBZUYsS0FBZixDQUFELENBQUo7QUFBOEIsT0FBcEMsQ0FBcUMsT0FBT0csQ0FBUCxFQUFVO0FBQUVMLFFBQUFBLE1BQU0sQ0FBQ0ssQ0FBRCxDQUFOO0FBQVk7QUFBRTs7QUFDM0YsYUFBU0MsUUFBVCxDQUFrQkosS0FBbEIsRUFBeUI7QUFBRSxVQUFJO0FBQUVDLFFBQUFBLElBQUksQ0FBQ04sU0FBUyxDQUFDLE9BQUQsQ0FBVCxDQUFtQkssS0FBbkIsQ0FBRCxDQUFKO0FBQWtDLE9BQXhDLENBQXlDLE9BQU9HLENBQVAsRUFBVTtBQUFFTCxRQUFBQSxNQUFNLENBQUNLLENBQUQsQ0FBTjtBQUFZO0FBQUU7O0FBQzlGLGFBQVNGLElBQVQsQ0FBY0ksTUFBZCxFQUFzQjtBQUFFQSxNQUFBQSxNQUFNLENBQUNDLElBQVAsR0FBY1QsT0FBTyxDQUFDUSxNQUFNLENBQUNMLEtBQVIsQ0FBckIsR0FBc0MsSUFBSU4sQ0FBSixDQUFNLFVBQVVHLE9BQVYsRUFBbUI7QUFBRUEsUUFBQUEsT0FBTyxDQUFDUSxNQUFNLENBQUNMLEtBQVIsQ0FBUDtBQUF3QixPQUFuRCxFQUFxRE8sSUFBckQsQ0FBMERSLFNBQTFELEVBQXFFSyxRQUFyRSxDQUF0QztBQUF1SDs7QUFDL0lILElBQUFBLElBQUksQ0FBQyxDQUFDTixTQUFTLEdBQUdBLFNBQVMsQ0FBQ2EsS0FBVixDQUFnQmhCLE9BQWhCLEVBQXlCQyxVQUFVLElBQUksRUFBdkMsQ0FBYixFQUF5RFMsSUFBekQsRUFBRCxDQUFKO0FBQ0gsR0FMTSxDQUFQO0FBTUgsQ0FQRDs7QUFRQU8sTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFWCxFQUFBQSxLQUFLLEVBQUU7QUFBVCxDQUE3Qzs7QUFDQSxNQUFNWSxNQUFNLEdBQUdDLE9BQU8sQ0FBQyxNQUFELENBQXRCOztBQUNBLE1BQU1DLGNBQWMsR0FBR0QsT0FBTyxDQUFDLGtCQUFELENBQTlCOztBQUNBLE1BQU1FLFFBQVEsR0FBR0YsT0FBTyxDQUFDLFFBQUQsQ0FBeEI7O0FBQ0EsTUFBTUcsZ0JBQWdCLEdBQUdILE9BQU8sQ0FBQyx1Q0FBRCxDQUFoQzs7QUFDQSxNQUFNSSxTQUFTLEdBQUdKLE9BQU8sQ0FBQyx3Q0FBRCxDQUF6Qjs7QUFDQSxNQUFNSyxNQUFNLEdBQUdMLE9BQU8sQ0FBQyxxQ0FBRCxDQUF0Qjs7QUFDQSxNQUFNTSxPQUFPLEdBQUdOLE9BQU8sQ0FBQyxzQ0FBRCxDQUF2Qjs7QUFDQSxNQUFNTyxVQUFVLEdBQUdQLE9BQU8sQ0FBQyx1Q0FBRCxDQUExQjs7QUFDQSxNQUFNUSxRQUFRLEdBQUdSLE9BQU8sQ0FBQyxjQUFELENBQXhCOztBQUNBLE1BQU1TLFlBQVksR0FBR1QsT0FBTyxDQUFDLG9CQUFELENBQTVCOztBQUNBRCxNQUFNLENBQUNXLEdBQVAsQ0FBV1QsY0FBWCxFLENBQ0E7O0FBQ0FVLEtBQUssQ0FBQywyQkFBRCxFQUE4QixNQUFNO0FBQ3JDLE1BQUlDLFVBQUo7QUFDQUMsRUFBQUEsVUFBVSxDQUFDLE1BQU07QUFDYkQsSUFBQUEsVUFBVSxHQUFHVCxnQkFBZ0IsQ0FBQ1csY0FBakIsQ0FBZ0NDLFdBQWhDLEdBQThDSCxVQUEzRDtBQUNBLFdBQU9ILFlBQVksQ0FBQ08sVUFBYixFQUFQO0FBQ0gsR0FIUyxDQUFWO0FBSUFDLEVBQUFBLEtBQUssQ0FBQ1IsWUFBWSxDQUFDTyxVQUFkLENBQUw7QUFDQUUsRUFBQUEsUUFBUSxDQUFDVCxZQUFZLENBQUNPLFVBQWQsQ0FBUjtBQUNBRyxFQUFBQSxJQUFJLENBQUMscUNBQUQsRUFBd0MsTUFBTXpDLFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDM0YsVUFBTTBDLFdBQVcsR0FBRyxJQUFJZixNQUFNLENBQUNnQixjQUFYLENBQTBCLElBQUlqQixTQUFTLENBQUNrQixhQUFkLEVBQTFCLENBQXBCO0FBQ0EsVUFBTUMsV0FBVyxHQUFHLE1BQXBCO0FBQ0EsVUFBTS9CLE1BQU0sR0FBRyxNQUFNNEIsV0FBVyxDQUFDSSxJQUFaLENBQWlCWixVQUFqQixFQUE2QixDQUFDLElBQUQsRUFBUSxVQUFTVyxXQUFZLElBQTdCLENBQTdCLENBQXJCO0FBQ0F4QixJQUFBQSxNQUFNLENBQUMwQixNQUFQLENBQWNqQyxNQUFkLEVBQXNCa0MsR0FBdEIsQ0FBMEJDLEVBQTFCLENBQTZCQyxFQUE3QixDQUFnQ0MsRUFBaEMsQ0FBbUMsV0FBbkMsRUFBZ0QscUJBQWhEO0FBQ0E5QixJQUFBQSxNQUFNLENBQUMwQixNQUFQLENBQWNqQyxNQUFNLENBQUNzQyxNQUFQLENBQWNDLElBQWQsRUFBZCxFQUFvQ0osRUFBcEMsQ0FBdUNDLEVBQXZDLENBQTBDSSxLQUExQyxDQUFnRFQsV0FBaEQsRUFBNkQsZ0JBQTdEO0FBQ0F4QixJQUFBQSxNQUFNLENBQUMwQixNQUFQLENBQWNqQyxNQUFNLENBQUN5QyxNQUFyQixFQUE2Qk4sRUFBN0IsQ0FBZ0NLLEtBQWhDLENBQXNDRSxTQUF0QyxFQUFpRCxzQkFBakQ7QUFDSCxHQVAwRCxDQUF2RCxDQUFKO0FBUUFmLEVBQUFBLElBQUksQ0FBQyw2Q0FBRCxFQUFnRCxZQUFZO0FBQzVELFdBQU96QyxTQUFTLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsYUFBYTtBQUNoRDtBQUNBO0FBQ0EsVUFBSThCLFFBQVEsQ0FBQzJCLElBQVQsQ0FBYzVCLFVBQVUsQ0FBQzZCLE1BQVgsQ0FBa0JDLE9BQWhDLE1BQTZDLE1BQU03QixRQUFRLENBQUM4QixlQUFULENBQXlCLEtBQXpCLENBQW5ELENBQUosRUFBeUY7QUFDckY7QUFDQSxlQUFPLEtBQUtDLElBQUwsRUFBUDtBQUNIOztBQUNELFlBQU1uQixXQUFXLEdBQUcsSUFBSWYsTUFBTSxDQUFDZ0IsY0FBWCxDQUEwQixJQUFJakIsU0FBUyxDQUFDa0IsYUFBZCxFQUExQixDQUFwQjtBQUNBLFlBQU1DLFdBQVcsR0FBRyxJQUFwQjtBQUNBLFlBQU0vQixNQUFNLEdBQUcsTUFBTTRCLFdBQVcsQ0FBQ0ksSUFBWixDQUFpQlosVUFBakIsRUFBNkIsQ0FBQyxJQUFELEVBQVEsVUFBU1csV0FBWSxJQUE3QixDQUE3QixDQUFyQjtBQUNBeEIsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjakMsTUFBZCxFQUFzQmtDLEdBQXRCLENBQTBCQyxFQUExQixDQUE2QkMsRUFBN0IsQ0FBZ0NDLEVBQWhDLENBQW1DLFdBQW5DLEVBQWdELHFCQUFoRDtBQUNBOUIsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjakMsTUFBTSxDQUFDc0MsTUFBUCxDQUFjQyxJQUFkLEVBQWQsRUFBb0NKLEVBQXBDLENBQXVDQyxFQUF2QyxDQUEwQ0ksS0FBMUMsQ0FBZ0RULFdBQWhELEVBQTZELGdCQUE3RDtBQUNBeEIsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjakMsTUFBTSxDQUFDeUMsTUFBckIsRUFBNkJOLEVBQTdCLENBQWdDSyxLQUFoQyxDQUFzQ0UsU0FBdEMsRUFBaUQsc0JBQWpEO0FBQ0gsS0FiZSxDQUFoQjtBQWNILEdBZkcsQ0FBSjtBQWdCQWYsRUFBQUEsSUFBSSxDQUFDLDJEQUFELEVBQThELFlBQVk7QUFDMUUsV0FBT3pDLFNBQVMsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFaLEVBQWUsS0FBSyxDQUFwQixFQUF1QixhQUFhO0FBQ2hEO0FBQ0EsV0FBSzhELE9BQUwsQ0FBYSxJQUFiO0FBQ0EsWUFBTXBCLFdBQVcsR0FBRyxJQUFJZixNQUFNLENBQUNnQixjQUFYLENBQTBCLElBQUlqQixTQUFTLENBQUNrQixhQUFkLEVBQTFCLENBQXBCO0FBQ0EsWUFBTW1CLFVBQVUsR0FBRyxDQUFDLFlBQUQsRUFBZSxhQUFmLEVBQ2YsWUFEZSxFQUNELG9CQURDLEVBQ3FCLGVBRHJCLEVBRWYsWUFGZSxFQUVELG9CQUZDLEVBRXFCLGVBRnJCLEVBR2YsWUFIZSxDQUFuQjtBQUlBLFlBQU1qRCxNQUFNLEdBQUcsTUFBTTRCLFdBQVcsQ0FBQ0ksSUFBWixDQUFpQlosVUFBakIsRUFBNkIsQ0FBQyxJQUFELEVBQU82QixVQUFVLENBQUNDLElBQVgsQ0FBZ0IsR0FBaEIsQ0FBUCxDQUE3QixDQUFyQjtBQUNBLFlBQU1DLE9BQU8sR0FBRyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxDQUFoQjtBQUNBNUMsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjakMsTUFBZCxFQUFzQmtDLEdBQXRCLENBQTBCQyxFQUExQixDQUE2QkMsRUFBN0IsQ0FBZ0NDLEVBQWhDLENBQW1DLFdBQW5DLEVBQWdELHFCQUFoRDtBQUNBLFlBQU1lLE1BQU0sR0FBR3BELE1BQU0sQ0FBQ3NDLE1BQVAsQ0FBY2UsS0FBZCxDQUFvQixRQUFwQixFQUE4QkMsR0FBOUIsQ0FBa0NDLElBQUksSUFBSUEsSUFBSSxDQUFDaEIsSUFBTCxFQUExQyxFQUF1RGlCLE1BQXZELENBQThERCxJQUFJLElBQUlBLElBQUksQ0FBQ0UsTUFBTCxHQUFjLENBQXBGLENBQWY7QUFDQWxELE1BQUFBLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBY21CLE1BQWQsRUFBc0JqQixFQUF0QixDQUF5QnVCLElBQXpCLENBQThCbEIsS0FBOUIsQ0FBb0NXLE9BQXBDLEVBQTZDLDZCQUE3QztBQUNBNUMsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjakMsTUFBTSxDQUFDeUMsTUFBckIsRUFBNkJOLEVBQTdCLENBQWdDSyxLQUFoQyxDQUFzQ0UsU0FBdEMsRUFBaUQsc0JBQWpEO0FBQ0gsS0FkZSxDQUFoQjtBQWVILEdBaEJHLENBQUo7QUFpQkFmLEVBQUFBLElBQUksQ0FBQyw4REFBRCxFQUFpRSxZQUFZO0FBQzdFLFdBQU96QyxTQUFTLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsYUFBYTtBQUNoRDtBQUNBLFdBQUs4RCxPQUFMLENBQWEsSUFBYjtBQUNBLFlBQU1wQixXQUFXLEdBQUcsSUFBSWYsTUFBTSxDQUFDZ0IsY0FBWCxDQUEwQixJQUFJakIsU0FBUyxDQUFDa0IsYUFBZCxFQUExQixDQUFwQjtBQUNBLFlBQU1tQixVQUFVLEdBQUcsQ0FBQyxZQUFELEVBQWUsYUFBZixFQUNmLHVCQURlLEVBQ1Usb0JBRFYsRUFDZ0MsZUFEaEMsRUFFZix1QkFGZSxFQUVVLG9CQUZWLEVBRWdDLGVBRmhDLEVBR2YsdUJBSGUsQ0FBbkI7QUFJQSxZQUFNakQsTUFBTSxHQUFHLE1BQU00QixXQUFXLENBQUNJLElBQVosQ0FBaUJaLFVBQWpCLEVBQTZCLENBQUMsSUFBRCxFQUFPNkIsVUFBVSxDQUFDQyxJQUFYLENBQWdCLEdBQWhCLENBQVAsQ0FBN0IsQ0FBckI7QUFDQSxZQUFNQyxPQUFPLEdBQUcsQ0FBQyxLQUFELENBQWhCO0FBQ0E1QyxNQUFBQSxNQUFNLENBQUMwQixNQUFQLENBQWNqQyxNQUFkLEVBQXNCa0MsR0FBdEIsQ0FBMEJDLEVBQTFCLENBQTZCQyxFQUE3QixDQUFnQ0MsRUFBaEMsQ0FBbUMsV0FBbkMsRUFBZ0QscUJBQWhEO0FBQ0EsWUFBTWUsTUFBTSxHQUFHcEQsTUFBTSxDQUFDc0MsTUFBUCxDQUFjZSxLQUFkLENBQW9CLFFBQXBCLEVBQThCQyxHQUE5QixDQUFrQ0MsSUFBSSxJQUFJQSxJQUFJLENBQUNoQixJQUFMLEVBQTFDLEVBQXVEaUIsTUFBdkQsQ0FBOERELElBQUksSUFBSUEsSUFBSSxDQUFDRSxNQUFMLEdBQWMsQ0FBcEYsQ0FBZjtBQUNBbEQsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjbUIsTUFBZCxFQUFzQmpCLEVBQXRCLENBQXlCdUIsSUFBekIsQ0FBOEJsQixLQUE5QixDQUFvQ1csT0FBcEMsRUFBNkMsNkJBQTdDO0FBQ0E1QyxNQUFBQSxNQUFNLENBQUMwQixNQUFQLENBQWNqQyxNQUFNLENBQUN5QyxNQUFyQixFQUE2Qk4sRUFBN0IsQ0FBZ0NLLEtBQWhDLENBQXNDRSxTQUF0QyxFQUFpRCxzQkFBakQ7QUFDSCxLQWRlLENBQWhCO0FBZUgsR0FoQkcsQ0FBSjtBQWlCQWYsRUFBQUEsSUFBSSxDQUFDLHFEQUFELEVBQXdELFlBQVk7QUFDcEUsV0FBT3pDLFNBQVMsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFaLEVBQWUsS0FBSyxDQUFwQixFQUF1QixhQUFhO0FBQ2hEO0FBQ0EsV0FBSzhELE9BQUwsQ0FBYSxLQUFiO0FBQ0EsWUFBTXBCLFdBQVcsR0FBRyxJQUFJZixNQUFNLENBQUNnQixjQUFYLENBQTBCLElBQUlqQixTQUFTLENBQUNrQixhQUFkLEVBQTFCLENBQXBCO0FBQ0EsWUFBTW1CLFVBQVUsR0FBRyxDQUFDLFlBQUQsRUFBZSxhQUFmLEVBQ2YsWUFEZSxFQUNELG9CQURDLEVBQ3FCLGdCQURyQixFQUVmLFlBRmUsRUFFRCxvQkFGQyxDQUFuQjtBQUdBLFlBQU1VLGlCQUFpQixHQUFHLElBQUlqRCxRQUFRLENBQUNrRCx1QkFBYixFQUExQjtBQUNBQyxNQUFBQSxVQUFVLENBQUMsTUFBTUYsaUJBQWlCLENBQUNHLE1BQWxCLEVBQVAsRUFBbUMsSUFBbkMsQ0FBVjtBQUNBLFlBQU05RCxNQUFNLEdBQUcsTUFBTTRCLFdBQVcsQ0FBQ0ksSUFBWixDQUFpQlosVUFBakIsRUFBNkIsQ0FBQyxJQUFELEVBQU82QixVQUFVLENBQUNDLElBQVgsQ0FBZ0IsR0FBaEIsQ0FBUCxDQUE3QixFQUEyRDtBQUFFYSxRQUFBQSxLQUFLLEVBQUVKLGlCQUFpQixDQUFDSTtBQUEzQixPQUEzRCxDQUFyQjtBQUNBeEQsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjakMsTUFBZCxFQUFzQmtDLEdBQXRCLENBQTBCQyxFQUExQixDQUE2QkMsRUFBN0IsQ0FBZ0NDLEVBQWhDLENBQW1DLFdBQW5DLEVBQWdELHFCQUFoRDtBQUNBLFlBQU1lLE1BQU0sR0FBR3BELE1BQU0sQ0FBQ3NDLE1BQVAsQ0FBY2UsS0FBZCxDQUFvQixRQUFwQixFQUE4QkMsR0FBOUIsQ0FBa0NDLElBQUksSUFBSUEsSUFBSSxDQUFDaEIsSUFBTCxFQUExQyxFQUF1RGlCLE1BQXZELENBQThERCxJQUFJLElBQUlBLElBQUksQ0FBQ0UsTUFBTCxHQUFjLENBQXBGLENBQWY7QUFDQWxELE1BQUFBLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBY21CLE1BQWQsRUFBc0JqQixFQUF0QixDQUF5QnVCLElBQXpCLENBQThCbEIsS0FBOUIsQ0FBb0MsQ0FBQyxHQUFELENBQXBDLEVBQTJDLDZCQUEzQztBQUNBakMsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjakMsTUFBTSxDQUFDeUMsTUFBckIsRUFBNkJOLEVBQTdCLENBQWdDSyxLQUFoQyxDQUFzQ0UsU0FBdEMsRUFBaUQsc0JBQWpEO0FBQ0gsS0FkZSxDQUFoQjtBQWVILEdBaEJHLENBQUo7QUFpQkFmLEVBQUFBLElBQUksQ0FBQyxpREFBRCxFQUFvRCxZQUFZO0FBQ2hFLFdBQU96QyxTQUFTLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsYUFBYTtBQUNoRDtBQUNBLFdBQUs4RCxPQUFMLENBQWEsSUFBYjtBQUNBLFlBQU1wQixXQUFXLEdBQUcsSUFBSWYsTUFBTSxDQUFDZ0IsY0FBWCxDQUEwQixJQUFJakIsU0FBUyxDQUFDa0IsYUFBZCxFQUExQixDQUFwQjtBQUNBLFlBQU1tQixVQUFVLEdBQUcsQ0FBQyxZQUFELEVBQWUsYUFBZixFQUNmLFlBRGUsRUFDRCxvQkFEQyxFQUNxQixlQURyQixFQUVmLHVCQUZlLEVBRVUsb0JBRlYsRUFFZ0MsZUFGaEMsRUFHZixZQUhlLEVBR0Qsb0JBSEMsRUFHcUIsZUFIckIsRUFJZix1QkFKZSxFQUlVLG9CQUpWLEVBSWdDLGVBSmhDLEVBS2YsWUFMZSxFQUtELG9CQUxDLEVBS3FCLGVBTHJCLEVBTWYsdUJBTmUsRUFNVSxvQkFOVixDQUFuQjtBQU9BLFlBQU1qRCxNQUFNLEdBQUcsTUFBTTRCLFdBQVcsQ0FBQ0ksSUFBWixDQUFpQlosVUFBakIsRUFBNkIsQ0FBQyxJQUFELEVBQU82QixVQUFVLENBQUNDLElBQVgsQ0FBZ0IsR0FBaEIsQ0FBUCxDQUE3QixDQUFyQjtBQUNBLFlBQU1jLGNBQWMsR0FBRyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxDQUF2QjtBQUNBLFlBQU1DLGNBQWMsR0FBRyxDQUFDLEtBQUQsQ0FBdkI7QUFDQTFELE1BQUFBLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBY2pDLE1BQWQsRUFBc0JrQyxHQUF0QixDQUEwQkMsRUFBMUIsQ0FBNkJDLEVBQTdCLENBQWdDQyxFQUFoQyxDQUFtQyxXQUFuQyxFQUFnRCxxQkFBaEQ7QUFDQSxZQUFNNkIsT0FBTyxHQUFHbEUsTUFBTSxDQUFDc0MsTUFBUCxDQUFjZSxLQUFkLENBQW9CLFFBQXBCLEVBQThCQyxHQUE5QixDQUFrQ0MsSUFBSSxJQUFJQSxJQUFJLENBQUNoQixJQUFMLEVBQTFDLEVBQXVEaUIsTUFBdkQsQ0FBOERELElBQUksSUFBSUEsSUFBSSxDQUFDRSxNQUFMLEdBQWMsQ0FBcEYsQ0FBaEI7QUFDQWxELE1BQUFBLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBY2lDLE9BQWQsRUFBdUIvQixFQUF2QixDQUEwQnVCLElBQTFCLENBQStCbEIsS0FBL0IsQ0FBcUN3QixjQUFyQyxFQUFxRCw2QkFBckQ7QUFDQSxZQUFNRyxPQUFPLEdBQUduRSxNQUFNLENBQUN5QyxNQUFQLENBQWNZLEtBQWQsQ0FBb0IsUUFBcEIsRUFBOEJDLEdBQTlCLENBQWtDQyxJQUFJLElBQUlBLElBQUksQ0FBQ2hCLElBQUwsRUFBMUMsRUFBdURpQixNQUF2RCxDQUE4REQsSUFBSSxJQUFJQSxJQUFJLENBQUNFLE1BQUwsR0FBYyxDQUFwRixDQUFoQjtBQUNBbEQsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFja0MsT0FBZCxFQUF1QmhDLEVBQXZCLENBQTBCdUIsSUFBMUIsQ0FBK0JsQixLQUEvQixDQUFxQ3lCLGNBQXJDLEVBQXFELDZCQUFyRDtBQUNILEtBbkJlLENBQWhCO0FBb0JILEdBckJHLENBQUo7QUFzQkF0QyxFQUFBQSxJQUFJLENBQUMsNkNBQUQsRUFBZ0QsWUFBWTtBQUM1RCxXQUFPekMsU0FBUyxDQUFDLElBQUQsRUFBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDaEQ7QUFDQSxXQUFLOEQsT0FBTCxDQUFhLElBQWI7QUFDQSxZQUFNcEIsV0FBVyxHQUFHLElBQUlmLE1BQU0sQ0FBQ2dCLGNBQVgsQ0FBMEIsSUFBSWpCLFNBQVMsQ0FBQ2tCLGFBQWQsRUFBMUIsQ0FBcEI7QUFDQSxZQUFNbUIsVUFBVSxHQUFHLENBQUMsWUFBRCxFQUFlLGFBQWYsRUFDZix1QkFEZSxFQUNVLG9CQURWLEVBQ2dDLGVBRGhDLEVBRWYsdUJBRmUsRUFFVSxvQkFGVixFQUVnQyxlQUZoQyxFQUdmLHVCQUhlLEVBR1Usb0JBSFYsRUFHZ0MsZUFIaEMsRUFJZix1QkFKZSxFQUlVLG9CQUpWLEVBSWdDLGVBSmhDLEVBS2YsdUJBTGUsRUFLVSxvQkFMVixFQUtnQyxlQUxoQyxFQU1mLHVCQU5lLEVBTVUsb0JBTlYsQ0FBbkI7QUFPQSxZQUFNakQsTUFBTSxHQUFHLE1BQU00QixXQUFXLENBQUNJLElBQVosQ0FBaUJaLFVBQWpCLEVBQTZCLENBQUMsSUFBRCxFQUFPNkIsVUFBVSxDQUFDQyxJQUFYLENBQWdCLEdBQWhCLENBQVAsQ0FBN0IsRUFBMkQ7QUFBRWtCLFFBQUFBLGNBQWMsRUFBRTtBQUFsQixPQUEzRCxDQUFyQjtBQUNBLFlBQU1DLGNBQWMsR0FBRyxDQUFDLFFBQUQsQ0FBdkI7QUFDQTlELE1BQUFBLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBY2pDLE1BQWQsRUFBc0JrQyxHQUF0QixDQUEwQkMsRUFBMUIsQ0FBNkJDLEVBQTdCLENBQWdDQyxFQUFoQyxDQUFtQyxXQUFuQyxFQUFnRCxxQkFBaEQ7QUFDQSxZQUFNYyxPQUFPLEdBQUduRCxNQUFNLENBQUNzQyxNQUFQLENBQWNlLEtBQWQsQ0FBb0IsUUFBcEIsRUFBOEJDLEdBQTlCLENBQWtDQyxJQUFJLElBQUlBLElBQUksQ0FBQ2hCLElBQUwsRUFBMUMsRUFBdURpQixNQUF2RCxDQUE4REQsSUFBSSxJQUFJQSxJQUFJLENBQUNFLE1BQUwsR0FBYyxDQUFwRixDQUFoQjtBQUNBbEQsTUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFja0IsT0FBZCxFQUF1QmhCLEVBQXZCLENBQTBCdUIsSUFBMUIsQ0FBK0JsQixLQUEvQixDQUFxQzZCLGNBQXJDLEVBQXFELDZCQUFyRDtBQUNILEtBaEJlLENBQWhCO0FBaUJILEdBbEJHLENBQUo7QUFtQkExQyxFQUFBQSxJQUFJLENBQUMsK0NBQUQsRUFBa0QsTUFBTXpDLFNBQVMsU0FBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDckcsVUFBTTBDLFdBQVcsR0FBRyxJQUFJZixNQUFNLENBQUNnQixjQUFYLENBQTBCLElBQUlqQixTQUFTLENBQUNrQixhQUFkLEVBQTFCLENBQXBCO0FBQ0EsVUFBTW1CLFVBQVUsR0FBRyxDQUFDLFlBQUQsRUFBZSx1QkFBZixFQUF3QyxvQkFBeEMsQ0FBbkI7QUFDQSxVQUFNakQsTUFBTSxHQUFHNEIsV0FBVyxDQUFDSSxJQUFaLENBQWlCWixVQUFqQixFQUE2QixDQUFDLElBQUQsRUFBTzZCLFVBQVUsQ0FBQ0MsSUFBWCxDQUFnQixHQUFoQixDQUFQLENBQTdCLEVBQTJEO0FBQUVvQixNQUFBQSxhQUFhLEVBQUU7QUFBakIsS0FBM0QsQ0FBZjtBQUNBLFVBQU0vRCxNQUFNLENBQUMwQixNQUFQLENBQWNqQyxNQUFkLEVBQXNCbUMsRUFBdEIsQ0FBeUJvQyxVQUF6QixDQUFvQ25DLEVBQXBDLENBQXVDb0MsWUFBdkMsQ0FBb0QxRCxPQUFPLENBQUMyRCxXQUE1RCxFQUF5RSxHQUF6RSxFQUE4RSw2QkFBOUUsQ0FBTjtBQUNILEdBTG9FLENBQWpFLENBQUo7QUFNQTlDLEVBQUFBLElBQUksQ0FBQyxzREFBRCxFQUF5RCxNQUFNekMsU0FBUyxTQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsYUFBYTtBQUM1RyxVQUFNMEMsV0FBVyxHQUFHLElBQUlmLE1BQU0sQ0FBQ2dCLGNBQVgsQ0FBMEIsSUFBSWpCLFNBQVMsQ0FBQ2tCLGFBQWQsRUFBMUIsQ0FBcEI7QUFDQSxVQUFNOUIsTUFBTSxHQUFHNEIsV0FBVyxDQUFDSSxJQUFaLENBQWlCMEMsSUFBSSxDQUFDQyxHQUFMLEdBQVdDLFFBQVgsRUFBakIsRUFBd0MsRUFBeEMsQ0FBZjtBQUNBLFVBQU1yRSxNQUFNLENBQUMwQixNQUFQLENBQWNqQyxNQUFkLEVBQXNCbUMsRUFBdEIsQ0FBeUJvQyxVQUF6QixDQUFvQ25DLEVBQXBDLENBQXVDckMsUUFBdkMsQ0FBZ0Q4RSxHQUFoRCxDQUFvRDFDLEVBQXBELENBQXVEMkMsSUFBdkQsQ0FBNERDLFFBQTVELENBQXFFLE1BQXJFLEVBQTZFLFFBQTdFLEVBQXVGLG9CQUF2RixDQUFOO0FBQ0gsR0FKMkUsQ0FBeEUsQ0FBSjtBQUtBcEQsRUFBQUEsSUFBSSxDQUFDLG9DQUFELEVBQXVDLE1BQU16QyxTQUFTLFNBQU8sS0FBSyxDQUFaLEVBQWUsS0FBSyxDQUFwQixFQUF1QixhQUFhO0FBQzFGLFVBQU0wQyxXQUFXLEdBQUcsSUFBSWYsTUFBTSxDQUFDZ0IsY0FBWCxDQUEwQixJQUFJakIsU0FBUyxDQUFDa0IsYUFBZCxFQUExQixDQUFwQjtBQUNBLFVBQU05QixNQUFNLEdBQUcsTUFBTTRCLFdBQVcsQ0FBQ0ksSUFBWixDQUFpQlosVUFBakIsRUFBNkIsQ0FBQyxJQUFELEVBQU8sWUFBUCxFQUFxQixZQUFyQixDQUE3QixDQUFyQjtBQUNBYixJQUFBQSxNQUFNLENBQUMwQixNQUFQLENBQWNqQyxNQUFNLENBQUNzQyxNQUFyQixFQUE2QjBDLE1BQTdCLENBQW9DLEVBQXBDLEVBQXdDLG1CQUF4QztBQUNBekUsSUFBQUEsTUFBTSxDQUFDMEIsTUFBUCxDQUFjakMsTUFBTSxDQUFDeUMsTUFBckIsRUFBNkJ1QyxNQUE3QixDQUFvQ3RDLFNBQXBDLEVBQStDLG1CQUEvQztBQUNILEdBTHlELENBQXRELENBQUo7QUFNSCxDQTdJSSxDQUFMIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNoYWlfMSA9IHJlcXVpcmUoXCJjaGFpXCIpO1xyXG5jb25zdCBjaGFpQXNQcm9taXNlZCA9IHJlcXVpcmUoXCJjaGFpLWFzLXByb21pc2VkXCIpO1xyXG5jb25zdCB2c2NvZGVfMSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IGNvbmZpZ1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi9jb25maWdTZXR0aW5nc1wiKTtcclxuY29uc3QgZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vcHJvY2Vzcy9kZWNvZGVyXCIpO1xyXG5jb25zdCBwcm9jXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi9wcm9jZXNzL3Byb2NcIik7XHJcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi9wcm9jZXNzL3R5cGVzXCIpO1xyXG5jb25zdCBwbGF0Zm9ybV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vdXRpbHMvcGxhdGZvcm1cIik7XHJcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vblwiKTtcclxuY29uc3QgaW5pdGlhbGl6ZV8xID0gcmVxdWlyZShcIi4vLi4vLi4vaW5pdGlhbGl6ZVwiKTtcclxuY2hhaV8xLnVzZShjaGFpQXNQcm9taXNlZCk7XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtZnVuYy1ib2R5LWxlbmd0aFxyXG5zdWl0ZSgnUHJvY2Vzc1NlcnZpY2UgT2JzZXJ2YWJsZScsICgpID0+IHtcclxuICAgIGxldCBweXRob25QYXRoO1xyXG4gICAgc3VpdGVTZXR1cCgoKSA9PiB7XHJcbiAgICAgICAgcHl0aG9uUGF0aCA9IGNvbmZpZ1NldHRpbmdzXzEuUHl0aG9uU2V0dGluZ3MuZ2V0SW5zdGFuY2UoKS5weXRob25QYXRoO1xyXG4gICAgICAgIHJldHVybiBpbml0aWFsaXplXzEuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfSk7XHJcbiAgICBzZXR1cChpbml0aWFsaXplXzEuaW5pdGlhbGl6ZSk7XHJcbiAgICB0ZWFyZG93bihpbml0aWFsaXplXzEuaW5pdGlhbGl6ZSk7XHJcbiAgICB0ZXN0KCdleGVjIHNob3VsZCBvdXRwdXQgcHJpbnQgc3RhdGVtZW50cycsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBwcm9jU2VydmljZSA9IG5ldyBwcm9jXzEuUHJvY2Vzc1NlcnZpY2UobmV3IGRlY29kZXJfMS5CdWZmZXJEZWNvZGVyKCkpO1xyXG4gICAgICAgIGNvbnN0IHByaW50T3V0cHV0ID0gJzEyMzQnO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHByb2NTZXJ2aWNlLmV4ZWMocHl0aG9uUGF0aCwgWyctYycsIGBwcmludChcIiR7cHJpbnRPdXRwdXR9XCIpYF0pO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QocmVzdWx0KS5ub3QudG8uYmUuYW4oJ3VuZGVmaW5lZCcsICdyZXN1bHQgaXMgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdChyZXN1bHQuc3Rkb3V0LnRyaW0oKSkudG8uYmUuZXF1YWwocHJpbnRPdXRwdXQsICdJbnZhbGlkIG91dHB1dCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QocmVzdWx0LnN0ZGVycikudG8uZXF1YWwodW5kZWZpbmVkLCAnc3RkZXJyIG5vdCB1bmRlZmluZWQnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ2V4ZWMgc2hvdWxkIG91dHB1dCBwcmludCB1bmljb2RlIGNoYXJhY3RlcnMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB0ZXN0IGhhcyBub3QgYmVlbiB3b3JraW5nIGZvciBtYW55IG1vbnRocyBpbiBQeXRob24gMi43IHVuZGVyXHJcbiAgICAgICAgICAgIC8vIFdpbmRvd3MuIFRyYWNrZWQgYnkgIzI1NDYuICh1bmljb2RlIHVuZGVyIFB5Mi43IGlzIHRvdWdoISlcclxuICAgICAgICAgICAgaWYgKGNvbW1vbl8xLmlzT3MocGxhdGZvcm1fMS5PU1R5cGUuV2luZG93cykgJiYgKHlpZWxkIGNvbW1vbl8xLmlzUHl0aG9uVmVyc2lvbignMi43JykpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10aGlzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5za2lwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHJvY1NlcnZpY2UgPSBuZXcgcHJvY18xLlByb2Nlc3NTZXJ2aWNlKG5ldyBkZWNvZGVyXzEuQnVmZmVyRGVjb2RlcigpKTtcclxuICAgICAgICAgICAgY29uc3QgcHJpbnRPdXRwdXQgPSAnw7bDpCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHByb2NTZXJ2aWNlLmV4ZWMocHl0aG9uUGF0aCwgWyctYycsIGBwcmludChcIiR7cHJpbnRPdXRwdXR9XCIpYF0pO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHJlc3VsdCkubm90LnRvLmJlLmFuKCd1bmRlZmluZWQnLCAncmVzdWx0IGlzIHVuZGVmaW5lZCcpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHJlc3VsdC5zdGRvdXQudHJpbSgpKS50by5iZS5lcXVhbChwcmludE91dHB1dCwgJ0ludmFsaWQgb3V0cHV0Jyk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QocmVzdWx0LnN0ZGVycikudG8uZXF1YWwodW5kZWZpbmVkLCAnc3RkZXJyIG5vdCB1bmRlZmluZWQnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgdGVzdCgnZXhlYyBzaG91bGQgd2FpdCBmb3IgY29tcGxldGlvbiBvZiBwcm9ncmFtIHdpdGggbmV3IGxpbmVzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRoaXNcclxuICAgICAgICAgICAgdGhpcy50aW1lb3V0KDUwMDApO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jU2VydmljZSA9IG5ldyBwcm9jXzEuUHJvY2Vzc1NlcnZpY2UobmV3IGRlY29kZXJfMS5CdWZmZXJEZWNvZGVyKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBweXRob25Db2RlID0gWydpbXBvcnQgc3lzJywgJ2ltcG9ydCB0aW1lJyxcclxuICAgICAgICAgICAgICAgICdwcmludChcIjFcIiknLCAnc3lzLnN0ZG91dC5mbHVzaCgpJywgJ3RpbWUuc2xlZXAoMSknLFxyXG4gICAgICAgICAgICAgICAgJ3ByaW50KFwiMlwiKScsICdzeXMuc3Rkb3V0LmZsdXNoKCknLCAndGltZS5zbGVlcCgxKScsXHJcbiAgICAgICAgICAgICAgICAncHJpbnQoXCIzXCIpJ107XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHByb2NTZXJ2aWNlLmV4ZWMocHl0aG9uUGF0aCwgWyctYycsIHB5dGhvbkNvZGUuam9pbignOycpXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBbJzEnLCAnMicsICczJ107XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QocmVzdWx0KS5ub3QudG8uYmUuYW4oJ3VuZGVmaW5lZCcsICdyZXN1bHQgaXMgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHJlc3VsdC5zdGRvdXQuc3BsaXQoL1xccj9cXG4vZykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpLmZpbHRlcihsaW5lID0+IGxpbmUubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFsdWVzKS50by5kZWVwLmVxdWFsKG91dHB1dHMsICdPdXRwdXQgdmFsdWVzIGFyZSBpbmNvcnJlY3QnKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChyZXN1bHQuc3RkZXJyKS50by5lcXVhbCh1bmRlZmluZWQsICdzdGRlcnIgbm90IHVuZGVmaW5lZCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB0ZXN0KCdleGVjIHNob3VsZCB3YWl0IGZvciBjb21wbGV0aW9uIG9mIHByb2dyYW0gd2l0aG91dCBuZXcgbGluZXMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGhpc1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQoNTAwMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2NTZXJ2aWNlID0gbmV3IHByb2NfMS5Qcm9jZXNzU2VydmljZShuZXcgZGVjb2Rlcl8xLkJ1ZmZlckRlY29kZXIoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHB5dGhvbkNvZGUgPSBbJ2ltcG9ydCBzeXMnLCAnaW1wb3J0IHRpbWUnLFxyXG4gICAgICAgICAgICAgICAgJ3N5cy5zdGRvdXQud3JpdGUoXCIxXCIpJywgJ3N5cy5zdGRvdXQuZmx1c2goKScsICd0aW1lLnNsZWVwKDEpJyxcclxuICAgICAgICAgICAgICAgICdzeXMuc3Rkb3V0LndyaXRlKFwiMlwiKScsICdzeXMuc3Rkb3V0LmZsdXNoKCknLCAndGltZS5zbGVlcCgxKScsXHJcbiAgICAgICAgICAgICAgICAnc3lzLnN0ZG91dC53cml0ZShcIjNcIiknXTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgcHJvY1NlcnZpY2UuZXhlYyhweXRob25QYXRoLCBbJy1jJywgcHl0aG9uQ29kZS5qb2luKCc7JyldKTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IFsnMTIzJ107XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QocmVzdWx0KS5ub3QudG8uYmUuYW4oJ3VuZGVmaW5lZCcsICdyZXN1bHQgaXMgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHJlc3VsdC5zdGRvdXQuc3BsaXQoL1xccj9cXG4vZykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpLmZpbHRlcihsaW5lID0+IGxpbmUubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFsdWVzKS50by5kZWVwLmVxdWFsKG91dHB1dHMsICdPdXRwdXQgdmFsdWVzIGFyZSBpbmNvcnJlY3QnKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChyZXN1bHQuc3RkZXJyKS50by5lcXVhbCh1bmRlZmluZWQsICdzdGRlcnIgbm90IHVuZGVmaW5lZCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB0ZXN0KCdleGVjIHNob3VsZCBlbmQgd2hlbiBjYW5jZWxsYXRpb25Ub2tlbiBpcyBjYW5jZWxsZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGhpc1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQoMTUwMDApO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jU2VydmljZSA9IG5ldyBwcm9jXzEuUHJvY2Vzc1NlcnZpY2UobmV3IGRlY29kZXJfMS5CdWZmZXJEZWNvZGVyKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBweXRob25Db2RlID0gWydpbXBvcnQgc3lzJywgJ2ltcG9ydCB0aW1lJyxcclxuICAgICAgICAgICAgICAgICdwcmludChcIjFcIiknLCAnc3lzLnN0ZG91dC5mbHVzaCgpJywgJ3RpbWUuc2xlZXAoMTApJyxcclxuICAgICAgICAgICAgICAgICdwcmludChcIjJcIiknLCAnc3lzLnN0ZG91dC5mbHVzaCgpJ107XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gbmV3IHZzY29kZV8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsKCksIDMwMDApO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBwcm9jU2VydmljZS5leGVjKHB5dGhvblBhdGgsIFsnLWMnLCBweXRob25Db2RlLmpvaW4oJzsnKV0sIHsgdG9rZW46IGNhbmNlbGxhdGlvblRva2VuLnRva2VuIH0pO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHJlc3VsdCkubm90LnRvLmJlLmFuKCd1bmRlZmluZWQnLCAncmVzdWx0IGlzIHVuZGVmaW5lZCcpO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSByZXN1bHQuc3Rkb3V0LnNwbGl0KC9cXHI/XFxuL2cpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKS5maWx0ZXIobGluZSA9PiBsaW5lLmxlbmd0aCA+IDApO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHZhbHVlcykudG8uZGVlcC5lcXVhbChbJzEnXSwgJ091dHB1dCB2YWx1ZXMgYXJlIGluY29ycmVjdCcpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHJlc3VsdC5zdGRlcnIpLnRvLmVxdWFsKHVuZGVmaW5lZCwgJ3N0ZGVyciBub3QgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHRlc3QoJ2V4ZWMgc2hvdWxkIHN0cmVhbSBzdGRvdXQgYW5kIHN0ZGVyciBzZXBhcmF0ZWx5JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRoaXNcclxuICAgICAgICAgICAgdGhpcy50aW1lb3V0KDcwMDApO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jU2VydmljZSA9IG5ldyBwcm9jXzEuUHJvY2Vzc1NlcnZpY2UobmV3IGRlY29kZXJfMS5CdWZmZXJEZWNvZGVyKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBweXRob25Db2RlID0gWydpbXBvcnQgc3lzJywgJ2ltcG9ydCB0aW1lJyxcclxuICAgICAgICAgICAgICAgICdwcmludChcIjFcIiknLCAnc3lzLnN0ZG91dC5mbHVzaCgpJywgJ3RpbWUuc2xlZXAoMSknLFxyXG4gICAgICAgICAgICAgICAgJ3N5cy5zdGRlcnIud3JpdGUoXCJhXCIpJywgJ3N5cy5zdGRlcnIuZmx1c2goKScsICd0aW1lLnNsZWVwKDEpJyxcclxuICAgICAgICAgICAgICAgICdwcmludChcIjJcIiknLCAnc3lzLnN0ZG91dC5mbHVzaCgpJywgJ3RpbWUuc2xlZXAoMSknLFxyXG4gICAgICAgICAgICAgICAgJ3N5cy5zdGRlcnIud3JpdGUoXCJiXCIpJywgJ3N5cy5zdGRlcnIuZmx1c2goKScsICd0aW1lLnNsZWVwKDEpJyxcclxuICAgICAgICAgICAgICAgICdwcmludChcIjNcIiknLCAnc3lzLnN0ZG91dC5mbHVzaCgpJywgJ3RpbWUuc2xlZXAoMSknLFxyXG4gICAgICAgICAgICAgICAgJ3N5cy5zdGRlcnIud3JpdGUoXCJjXCIpJywgJ3N5cy5zdGRlcnIuZmx1c2goKSddO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBwcm9jU2VydmljZS5leGVjKHB5dGhvblBhdGgsIFsnLWMnLCBweXRob25Db2RlLmpvaW4oJzsnKV0pO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFN0ZG91dCA9IFsnMScsICcyJywgJzMnXTtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRTdGRlcnIgPSBbJ2FiYyddO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHJlc3VsdCkubm90LnRvLmJlLmFuKCd1bmRlZmluZWQnLCAncmVzdWx0IGlzIHVuZGVmaW5lZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBzdGRvdXRzID0gcmVzdWx0LnN0ZG91dC5zcGxpdCgvXFxyP1xcbi9nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSkuZmlsdGVyKGxpbmUgPT4gbGluZS5sZW5ndGggPiAwKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChzdGRvdXRzKS50by5kZWVwLmVxdWFsKGV4cGVjdGVkU3Rkb3V0LCAnc3Rkb3V0IHZhbHVlcyBhcmUgaW5jb3JyZWN0Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ZGVycnMgPSByZXN1bHQuc3RkZXJyLnNwbGl0KC9cXHI/XFxuL2cpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKS5maWx0ZXIobGluZSA9PiBsaW5lLmxlbmd0aCA+IDApO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHN0ZGVycnMpLnRvLmRlZXAuZXF1YWwoZXhwZWN0ZWRTdGRlcnIsICdzdGRlcnIgdmFsdWVzIGFyZSBpbmNvcnJlY3QnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgdGVzdCgnZXhlYyBzaG91bGQgbWVyZ2Ugc3Rkb3V0IGFuZCBzdGRlcnIgc3RyZWFtcycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10aGlzXHJcbiAgICAgICAgICAgIHRoaXMudGltZW91dCg3MDAwKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY1NlcnZpY2UgPSBuZXcgcHJvY18xLlByb2Nlc3NTZXJ2aWNlKG5ldyBkZWNvZGVyXzEuQnVmZmVyRGVjb2RlcigpKTtcclxuICAgICAgICAgICAgY29uc3QgcHl0aG9uQ29kZSA9IFsnaW1wb3J0IHN5cycsICdpbXBvcnQgdGltZScsXHJcbiAgICAgICAgICAgICAgICAnc3lzLnN0ZG91dC53cml0ZShcIjFcIiknLCAnc3lzLnN0ZG91dC5mbHVzaCgpJywgJ3RpbWUuc2xlZXAoMSknLFxyXG4gICAgICAgICAgICAgICAgJ3N5cy5zdGRlcnIud3JpdGUoXCJhXCIpJywgJ3N5cy5zdGRlcnIuZmx1c2goKScsICd0aW1lLnNsZWVwKDEpJyxcclxuICAgICAgICAgICAgICAgICdzeXMuc3Rkb3V0LndyaXRlKFwiMlwiKScsICdzeXMuc3Rkb3V0LmZsdXNoKCknLCAndGltZS5zbGVlcCgxKScsXHJcbiAgICAgICAgICAgICAgICAnc3lzLnN0ZGVyci53cml0ZShcImJcIiknLCAnc3lzLnN0ZGVyci5mbHVzaCgpJywgJ3RpbWUuc2xlZXAoMSknLFxyXG4gICAgICAgICAgICAgICAgJ3N5cy5zdGRvdXQud3JpdGUoXCIzXCIpJywgJ3N5cy5zdGRvdXQuZmx1c2goKScsICd0aW1lLnNsZWVwKDEpJyxcclxuICAgICAgICAgICAgICAgICdzeXMuc3RkZXJyLndyaXRlKFwiY1wiKScsICdzeXMuc3RkZXJyLmZsdXNoKCknXTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgcHJvY1NlcnZpY2UuZXhlYyhweXRob25QYXRoLCBbJy1jJywgcHl0aG9uQ29kZS5qb2luKCc7JyldLCB7IG1lcmdlU3RkT3V0RXJyOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZE91dHB1dCA9IFsnMWEyYjNjJ107XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QocmVzdWx0KS5ub3QudG8uYmUuYW4oJ3VuZGVmaW5lZCcsICdyZXN1bHQgaXMgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSByZXN1bHQuc3Rkb3V0LnNwbGl0KC9cXHI/XFxuL2cpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKS5maWx0ZXIobGluZSA9PiBsaW5lLmxlbmd0aCA+IDApO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KG91dHB1dHMpLnRvLmRlZXAuZXF1YWwoZXhwZWN0ZWRPdXRwdXQsICdPdXRwdXQgdmFsdWVzIGFyZSBpbmNvcnJlY3QnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgdGVzdCgnZXhlYyBzaG91bGQgdGhyb3cgYW4gZXJyb3Igd2l0aCBzdGRlcnIgb3V0cHV0JywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb2NTZXJ2aWNlID0gbmV3IHByb2NfMS5Qcm9jZXNzU2VydmljZShuZXcgZGVjb2Rlcl8xLkJ1ZmZlckRlY29kZXIoKSk7XHJcbiAgICAgICAgY29uc3QgcHl0aG9uQ29kZSA9IFsnaW1wb3J0IHN5cycsICdzeXMuc3RkZXJyLndyaXRlKFwiYVwiKScsICdzeXMuc3RkZXJyLmZsdXNoKCknXTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jU2VydmljZS5leGVjKHB5dGhvblBhdGgsIFsnLWMnLCBweXRob25Db2RlLmpvaW4oJzsnKV0sIHsgdGhyb3dPblN0ZEVycjogdHJ1ZSB9KTtcclxuICAgICAgICB5aWVsZCBjaGFpXzEuZXhwZWN0KHJlc3VsdCkudG8uZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgodHlwZXNfMS5TdGRFcnJFcnJvciwgJ2EnLCAnRXhwZWN0ZWQgZXJyb3IgdG8gYmUgdGhyb3duJyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdleGVjIHNob3VsZCB0aHJvdyBhbiBlcnJvciB3aGVuIHNwYXduIGZpbGUgbm90IGZvdW5kJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb2NTZXJ2aWNlID0gbmV3IHByb2NfMS5Qcm9jZXNzU2VydmljZShuZXcgZGVjb2Rlcl8xLkJ1ZmZlckRlY29kZXIoKSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY1NlcnZpY2UuZXhlYyhEYXRlLm5vdygpLnRvU3RyaW5nKCksIFtdKTtcclxuICAgICAgICB5aWVsZCBjaGFpXzEuZXhwZWN0KHJlc3VsdCkudG8uZXZlbnR1YWxseS5iZS5yZWplY3RlZC5hbmQudG8uaGF2ZS5wcm9wZXJ0eSgnY29kZScsICdFTk9FTlQnLCAnSW52YWxpZCBlcnJvciBjb2RlJyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdleGVjIHNob3VsZCBleGl0IHdpdGhvdXQgbm8gb3V0cHV0JywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb2NTZXJ2aWNlID0gbmV3IHByb2NfMS5Qcm9jZXNzU2VydmljZShuZXcgZGVjb2Rlcl8xLkJ1ZmZlckRlY29kZXIoKSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgcHJvY1NlcnZpY2UuZXhlYyhweXRob25QYXRoLCBbJy1jJywgJ2ltcG9ydCBzeXMnLCAnc3lzLmV4aXQoKSddKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHJlc3VsdC5zdGRvdXQpLmVxdWFscygnJywgJ3N0ZG91dCBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdChyZXN1bHQuc3RkZXJyKS5lcXVhbHModW5kZWZpbmVkLCAnc3RkZXJyIGlzIGludmFsaWQnKTtcclxuICAgIH0pKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2MuZXhlYy50ZXN0LmpzLm1hcCJdfQ==