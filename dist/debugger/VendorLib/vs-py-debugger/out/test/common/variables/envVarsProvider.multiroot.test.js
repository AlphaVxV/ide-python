"use strict"; // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const chai_1 = require("chai");

const chaiAsPromised = require("chai-as-promised");

const fs = require("fs-extra");

const os_1 = require("os");

const path = require("path");

const vscode_1 = require("vscode");

const constants_1 = require("../../../client/common/platform/constants");

const types_1 = require("../../../client/common/types");

const util_1 = require("../../../client/common/util");

const async_1 = require("../../../client/common/utils/async");

const environment_1 = require("../../../client/common/variables/environment");

const environmentVariablesProvider_1 = require("../../../client/common/variables/environmentVariablesProvider");

const common_1 = require("../../common");

const initialize_1 = require("../../initialize");

const process_1 = require("../../mocks/process");

const serviceRegistry_1 = require("../../unittests/serviceRegistry");

chai_1.use(chaiAsPromised);
const multirootPath = path.join(__dirname, '..', '..', '..', '..', 'src', 'testMultiRootWkspc');
const workspace4Path = vscode_1.Uri.file(path.join(multirootPath, 'workspace4'));
const workspace4PyFile = vscode_1.Uri.file(path.join(workspace4Path.fsPath, 'one.py')); // tslint:disable-next-line:max-func-body-length

suite('Multiroot Environment Variables Provider', () => {
  let ioc;
  const pathVariableName = util_1.IS_WINDOWS ? constants_1.WINDOWS_PATH_VARIABLE_NAME : constants_1.NON_WINDOWS_PATH_VARIABLE_NAME;
  suiteSetup(function () {
    return __awaiter(this, void 0, void 0, function* () {
      if (!initialize_1.IS_MULTI_ROOT_TEST) {
        // tslint:disable-next-line:no-invalid-this
        this.skip();
      }

      yield common_1.clearPythonPathInWorkspaceFolder(workspace4Path);
      yield common_1.updateSetting('envFile', undefined, workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
      yield initialize_1.initialize();
    });
  });
  setup(() => {
    ioc = new serviceRegistry_1.UnitTestIocContainer();
    ioc.registerCommonTypes();
    ioc.registerVariableTypes();
    ioc.registerProcessTypes();
    return initialize_1.initializeTest();
  });
  suiteTeardown(initialize_1.closeActiveWindows);
  teardown(() => __awaiter(void 0, void 0, void 0, function* () {
    ioc.dispose();
    yield initialize_1.closeActiveWindows();
    yield common_1.clearPythonPathInWorkspaceFolder(workspace4Path);
    yield common_1.updateSetting('envFile', undefined, workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    yield initialize_1.initializeTest();
  }));

  function getVariablesProvider(mockVariables = Object.assign({}, process.env)) {
    const pathUtils = ioc.serviceContainer.get(types_1.IPathUtils);
    const mockProcess = new process_1.MockProcess(mockVariables);
    const variablesService = new environment_1.EnvironmentVariablesService(pathUtils);
    const disposables = ioc.serviceContainer.get(types_1.IDisposableRegistry);
    const isWindows = ioc.serviceContainer.get(types_1.IsWindows);
    return new environmentVariablesProvider_1.EnvironmentVariablesProvider(variablesService, disposables, isWindows, mockProcess);
  }

  test('Custom variables should not be undefined without an env file', () => __awaiter(void 0, void 0, void 0, function* () {
    yield common_1.updateSetting('envFile', 'someInvalidFile.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const envProvider = getVariablesProvider();
    const vars = envProvider.getEnvironmentVariables(workspace4PyFile);
    yield chai_1.expect(vars).to.eventually.not.equal(undefined, 'Variables is not undefiend');
  }));
  test('Custom variables should be parsed from env file', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);

    if (processVariables.PYTHONPATH) {
      delete processVariables.PYTHONPATH;
    }

    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid');
  }));
  test('All process environment variables should be included in variables returned', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);

    if (processVariables.PYTHONPATH) {
      delete processVariables.PYTHONPATH;
    }

    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid');
    Object.keys(processVariables).forEach(variable => {
      chai_1.expect(vars).to.have.property(variable, processVariables[variable], 'Value of the variable is incorrect');
    });
  }));
  test('Variables from file should take precedence over variables in process', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);

    if (processVariables.PYTHONPATH) {
      delete processVariables.PYTHONPATH;
    }

    processVariables.X1234PYEXTUNITTESTVAR = 'abcd';
    processVariables.ABCD = 'abcd';
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('ABCD', 'abcd', 'ABCD value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid');
  }));
  test('PYTHONPATH from process variables should be merged with that in env file', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);
    processVariables.PYTHONPATH = '/usr/one/TWO';
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    const expectedPythonPath = `../workspace5${path.delimiter}${processVariables.PYTHONPATH}`;
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', expectedPythonPath, 'PYTHONPATH value is invalid');
  }));
  test('PATH from process variables should be included in in variables returned (mock variables)', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);
    processVariables.PYTHONPATH = '/usr/one/TWO';
    processVariables[pathVariableName] = '/usr/one/THREE';
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    const expectedPythonPath = `../workspace5${path.delimiter}${processVariables.PYTHONPATH}`;
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', expectedPythonPath, 'PYTHONPATH value is invalid');
    chai_1.expect(vars).to.have.property(pathVariableName, processVariables[pathVariableName], 'PATH value is invalid');
  }));
  test('PATH from process variables should be included in in variables returned', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);
    processVariables.PYTHONPATH = '/usr/one/TWO';
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    const expectedPythonPath = `../workspace5${path.delimiter}${processVariables.PYTHONPATH}`;
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', expectedPythonPath, 'PYTHONPATH value is invalid');
    chai_1.expect(vars).to.have.property(pathVariableName, processVariables[pathVariableName], 'PATH value is invalid');
  }));
  test('PYTHONPATH and PATH from process variables should be merged with that in env file', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env5', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);
    processVariables.PYTHONPATH = '/usr/one/TWO';
    processVariables[pathVariableName] = '/usr/one/THREE';
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    const expectedPythonPath = `/usr/one/three:/usr/one/four${path.delimiter}${processVariables.PYTHONPATH}`;
    const expectedPath = `/usr/x:/usr/y${path.delimiter}${processVariables[pathVariableName]}`;
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X', '1', 'X value is invalid');
    chai_1.expect(vars).to.have.property('Y', '2', 'Y value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', expectedPythonPath, 'PYTHONPATH value is invalid');
    chai_1.expect(vars).to.have.property(pathVariableName, expectedPath, 'PATH value is invalid');
  }));
  test('PATH and PYTHONPATH from env file should be returned as is', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env5', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);

    if (processVariables.PYTHONPATH) {
      delete processVariables.PYTHONPATH;
    }

    if (processVariables[pathVariableName]) {
      delete processVariables[pathVariableName];
    }

    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    const expectedPythonPath = '/usr/one/three:/usr/one/four';
    const expectedPath = '/usr/x:/usr/y';
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X', '1', 'X value is invalid');
    chai_1.expect(vars).to.have.property('Y', '2', 'Y value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', expectedPythonPath, 'PYTHONPATH value is invalid');
    chai_1.expect(vars).to.have.property(pathVariableName, expectedPath, 'PATH value is invalid');
  }));
  test('PYTHONPATH and PATH from process variables should be included in variables returned', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env2', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);
    processVariables.PYTHONPATH = '/usr/one/TWO';
    processVariables[pathVariableName] = '/usr/one/THREE';
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X12345PYEXTUNITTESTVAR', '12345', 'X12345PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', processVariables.PYTHONPATH, 'PYTHONPATH value is invalid');
    chai_1.expect(vars).to.have.property(pathVariableName, processVariables[pathVariableName], 'PATH value is invalid');
  }));
  test('PYTHONPATH should not exist in variables returned', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env2', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);

    if (processVariables.PYTHONPATH) {
      delete processVariables.PYTHONPATH;
    }

    processVariables[pathVariableName] = '/usr/one/THREE';
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X12345PYEXTUNITTESTVAR', '12345', 'X12345PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.not.have.property('PYTHONPATH');
    chai_1.expect(vars).to.have.property(pathVariableName, processVariables[pathVariableName], 'PATH value is invalid');
  }));
  test('Custom variables should not be merged with process environment varaibles', () => __awaiter(void 0, void 0, void 0, function* () {
    const randomEnvVariable = `UNIT_TEST_PYTHON_EXT_RANDOM_VARIABLE_${new Date().getSeconds()}`;
    const processVariables = Object.assign({}, process.env);
    processVariables[randomEnvVariable] = '1234';

    if (processVariables.PYTHONPATH) {
      delete processVariables.PYTHONPATH;
    } // tslint:disable-next-line:no-invalid-template-strings


    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid');
    chai_1.expect(vars).to.not.to.have.property(randomEnvVariable, undefined, 'Yikes process variable has leaked');
  }));
  test('Custom variables should be merged with process environment varaibles', () => __awaiter(void 0, void 0, void 0, function* () {
    const randomEnvVariable = `UNIT_TEST_PYTHON_EXT_RANDOM_VARIABLE_${new Date().getSeconds()}`;
    const processVariables = Object.assign({}, process.env);
    processVariables[randomEnvVariable] = '1234';

    if (processVariables.PYTHONPATH) {
      delete processVariables.PYTHONPATH;
    } // tslint:disable-next-line:no-invalid-template-strings


    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid');
    chai_1.expect(vars).to.have.property(randomEnvVariable, '1234', 'Yikes process variable has leaked');
  }));
  test('Custom variables will be refreshed when settings points to a different env file', () => __awaiter(void 0, void 0, void 0, function* () {
    // tslint:disable-next-line:no-invalid-template-strings
    yield common_1.updateSetting('envFile', '${workspaceRoot}/.env', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
    const processVariables = Object.assign({}, process.env);

    if (processVariables.PYTHONPATH) {
      delete processVariables.PYTHONPATH;
    }

    const envProvider = getVariablesProvider(processVariables);
    const vars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(vars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(vars).to.have.property('X1234PYEXTUNITTESTVAR', '1234', 'X1234PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(vars).to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid');
    const settings = vscode_1.workspace.getConfiguration('python', workspace4PyFile); // tslint:disable-next-line:no-invalid-template-strings

    yield settings.update('envFile', '${workspaceRoot}/.env2', vscode_1.ConfigurationTarget.WorkspaceFolder); // Wait for settings to get refreshed.

    yield new Promise(resolve => setTimeout(resolve, 5000));
    const newVars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
    chai_1.expect(newVars).to.not.equal(undefined, 'Variables is is undefiend');
    chai_1.expect(newVars).to.have.property('X12345PYEXTUNITTESTVAR', '12345', 'X12345PYEXTUNITTESTVAR value is invalid');
    chai_1.expect(newVars).to.not.to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid');
  }));
  test('Custom variables will be refreshed when .env file is created, modified and deleted', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // tslint:disable-next-line:no-invalid-this
      this.timeout(20000);
      const env3 = path.join(workspace4Path.fsPath, '.env3');
      const fileExists = yield fs.pathExists(env3);

      if (fileExists) {
        yield fs.remove(env3);
      } // tslint:disable-next-line:no-invalid-template-strings


      yield common_1.updateSetting('envFile', '${workspaceRoot}/.env3', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
      const processVariables = Object.assign({}, process.env);

      if (processVariables.PYTHONPATH) {
        delete processVariables.PYTHONPATH;
      }

      const envProvider = getVariablesProvider(processVariables);
      const vars = envProvider.getEnvironmentVariables(workspace4PyFile);
      yield chai_1.expect(vars).to.eventually.not.equal(undefined, 'Variables is is undefiend'); // Create env3.

      const contents = fs.readFileSync(path.join(workspace4Path.fsPath, '.env2'));
      fs.writeFileSync(env3, contents); // Wait for settings to get refreshed.

      yield new Promise(resolve => setTimeout(resolve, 5000));
      const newVars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
      chai_1.expect(newVars).to.not.equal(undefined, 'Variables is is undefiend after creating');
      chai_1.expect(newVars).to.have.property('X12345PYEXTUNITTESTVAR', '12345', 'X12345PYEXTUNITTESTVAR value is invalid after creating');
      chai_1.expect(newVars).to.not.to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid after creating'); // Modify env3.

      fs.writeFileSync(env3, `${contents}${os_1.EOL}X123456PYEXTUNITTESTVAR=123456`); // Wait for settings to get refreshed.

      yield new Promise(resolve => setTimeout(resolve, 5000));
      const updatedVars = yield envProvider.getEnvironmentVariables(workspace4PyFile);
      chai_1.expect(updatedVars).to.not.equal(undefined, 'Variables is is undefiend after modifying');
      chai_1.expect(updatedVars).to.have.property('X12345PYEXTUNITTESTVAR', '12345', 'X12345PYEXTUNITTESTVAR value is invalid after modifying');
      chai_1.expect(updatedVars).to.not.to.have.property('PYTHONPATH', '../workspace5', 'PYTHONPATH value is invalid after modifying');
      chai_1.expect(updatedVars).to.have.property('X123456PYEXTUNITTESTVAR', '123456', 'X123456PYEXTUNITTESTVAR value is invalid after modifying'); // Now remove env3.

      yield fs.remove(env3); // Wait for settings to get refreshed.

      yield new Promise(resolve => setTimeout(resolve, 5000));
      const varsAfterDeleting = yield envProvider.getEnvironmentVariables(workspace4PyFile);
      chai_1.expect(varsAfterDeleting).to.not.equal(undefined, 'Variables is undefiend after deleting');
    });
  });
  test('Change event will be raised when when .env file is created, modified and deleted', function () {
    return __awaiter(this, void 0, void 0, function* () {
      // tslint:disable-next-line:no-invalid-this
      this.timeout(20000);
      const env3 = path.join(workspace4Path.fsPath, '.env3');
      const fileExists = yield fs.pathExists(env3);

      if (fileExists) {
        yield fs.remove(env3);
      } // tslint:disable-next-line:no-invalid-template-strings


      yield common_1.updateSetting('envFile', '${workspaceRoot}/.env3', workspace4PyFile, vscode_1.ConfigurationTarget.WorkspaceFolder);
      const processVariables = Object.assign({}, process.env);

      if (processVariables.PYTHONPATH) {
        delete processVariables.PYTHONPATH;
      }

      const envProvider = getVariablesProvider(processVariables);
      let eventRaisedPromise = async_1.createDeferred();
      envProvider.onDidEnvironmentVariablesChange(() => eventRaisedPromise.resolve(true));
      const vars = envProvider.getEnvironmentVariables(workspace4PyFile);
      yield chai_1.expect(vars).to.eventually.not.equal(undefined, 'Variables is is undefiend'); // Create env3.

      const contents = fs.readFileSync(path.join(workspace4Path.fsPath, '.env2'));
      fs.writeFileSync(env3, contents); // Wait for settings to get refreshed.

      yield new Promise(resolve => setTimeout(resolve, 5000));
      let eventRaised = yield eventRaisedPromise.promise;
      chai_1.expect(eventRaised).to.equal(true, 'Create notification not raised'); // Modify env3.

      eventRaisedPromise = async_1.createDeferred();
      fs.writeFileSync(env3, `${contents}${os_1.EOL}X123456PYEXTUNITTESTVAR=123456`); // Wait for settings to get refreshed.

      yield new Promise(resolve => setTimeout(resolve, 5000));
      eventRaised = yield eventRaisedPromise.promise;
      chai_1.expect(eventRaised).to.equal(true, 'Change notification not raised'); // Now remove env3.

      eventRaisedPromise = async_1.createDeferred();
      yield fs.remove(env3); // Wait for settings to get refreshed.

      yield new Promise(resolve => setTimeout(resolve, 5000));
      eventRaised = yield eventRaisedPromise.promise;
      chai_1.expect(eventRaised).to.equal(true, 'Delete notification not raised');
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVudlZhcnNQcm92aWRlci5tdWx0aXJvb3QudGVzdC5qcyJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInZhbHVlIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiY2hhaV8xIiwicmVxdWlyZSIsImNoYWlBc1Byb21pc2VkIiwiZnMiLCJvc18xIiwicGF0aCIsInZzY29kZV8xIiwiY29uc3RhbnRzXzEiLCJ0eXBlc18xIiwidXRpbF8xIiwiYXN5bmNfMSIsImVudmlyb25tZW50XzEiLCJlbnZpcm9ubWVudFZhcmlhYmxlc1Byb3ZpZGVyXzEiLCJjb21tb25fMSIsImluaXRpYWxpemVfMSIsInByb2Nlc3NfMSIsInNlcnZpY2VSZWdpc3RyeV8xIiwidXNlIiwibXVsdGlyb290UGF0aCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJ3b3Jrc3BhY2U0UGF0aCIsIlVyaSIsImZpbGUiLCJ3b3Jrc3BhY2U0UHlGaWxlIiwiZnNQYXRoIiwic3VpdGUiLCJpb2MiLCJwYXRoVmFyaWFibGVOYW1lIiwiSVNfV0lORE9XUyIsIldJTkRPV1NfUEFUSF9WQVJJQUJMRV9OQU1FIiwiTk9OX1dJTkRPV1NfUEFUSF9WQVJJQUJMRV9OQU1FIiwic3VpdGVTZXR1cCIsIklTX01VTFRJX1JPT1RfVEVTVCIsInNraXAiLCJjbGVhclB5dGhvblBhdGhJbldvcmtzcGFjZUZvbGRlciIsInVwZGF0ZVNldHRpbmciLCJ1bmRlZmluZWQiLCJDb25maWd1cmF0aW9uVGFyZ2V0IiwiV29ya3NwYWNlRm9sZGVyIiwiaW5pdGlhbGl6ZSIsInNldHVwIiwiVW5pdFRlc3RJb2NDb250YWluZXIiLCJyZWdpc3RlckNvbW1vblR5cGVzIiwicmVnaXN0ZXJWYXJpYWJsZVR5cGVzIiwicmVnaXN0ZXJQcm9jZXNzVHlwZXMiLCJpbml0aWFsaXplVGVzdCIsInN1aXRlVGVhcmRvd24iLCJjbG9zZUFjdGl2ZVdpbmRvd3MiLCJ0ZWFyZG93biIsImRpc3Bvc2UiLCJnZXRWYXJpYWJsZXNQcm92aWRlciIsIm1vY2tWYXJpYWJsZXMiLCJhc3NpZ24iLCJwcm9jZXNzIiwiZW52IiwicGF0aFV0aWxzIiwic2VydmljZUNvbnRhaW5lciIsImdldCIsIklQYXRoVXRpbHMiLCJtb2NrUHJvY2VzcyIsIk1vY2tQcm9jZXNzIiwidmFyaWFibGVzU2VydmljZSIsIkVudmlyb25tZW50VmFyaWFibGVzU2VydmljZSIsImRpc3Bvc2FibGVzIiwiSURpc3Bvc2FibGVSZWdpc3RyeSIsImlzV2luZG93cyIsIklzV2luZG93cyIsIkVudmlyb25tZW50VmFyaWFibGVzUHJvdmlkZXIiLCJ0ZXN0IiwiZW52UHJvdmlkZXIiLCJ2YXJzIiwiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMiLCJleHBlY3QiLCJ0byIsImV2ZW50dWFsbHkiLCJub3QiLCJlcXVhbCIsInByb2Nlc3NWYXJpYWJsZXMiLCJQWVRIT05QQVRIIiwiaGF2ZSIsInByb3BlcnR5Iiwia2V5cyIsImZvckVhY2giLCJ2YXJpYWJsZSIsIlgxMjM0UFlFWFRVTklUVEVTVFZBUiIsIkFCQ0QiLCJleHBlY3RlZFB5dGhvblBhdGgiLCJkZWxpbWl0ZXIiLCJleHBlY3RlZFBhdGgiLCJyYW5kb21FbnZWYXJpYWJsZSIsIkRhdGUiLCJnZXRTZWNvbmRzIiwic2V0dGluZ3MiLCJ3b3Jrc3BhY2UiLCJnZXRDb25maWd1cmF0aW9uIiwidXBkYXRlIiwic2V0VGltZW91dCIsIm5ld1ZhcnMiLCJ0aW1lb3V0IiwiZW52MyIsImZpbGVFeGlzdHMiLCJwYXRoRXhpc3RzIiwicmVtb3ZlIiwiY29udGVudHMiLCJyZWFkRmlsZVN5bmMiLCJ3cml0ZUZpbGVTeW5jIiwiRU9MIiwidXBkYXRlZFZhcnMiLCJ2YXJzQWZ0ZXJEZWxldGluZyIsImV2ZW50UmFpc2VkUHJvbWlzZSIsImNyZWF0ZURlZmVycmVkIiwib25EaWRFbnZpcm9ubWVudFZhcmlhYmxlc0NoYW5nZSIsImV2ZW50UmFpc2VkIiwicHJvbWlzZSJdLCJtYXBwaW5ncyI6IkFBQUEsYSxDQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsU0FBUyxHQUFJLFVBQVEsU0FBS0EsU0FBZCxJQUE0QixVQUFVQyxPQUFWLEVBQW1CQyxVQUFuQixFQUErQkMsQ0FBL0IsRUFBa0NDLFNBQWxDLEVBQTZDO0FBQ3JGLFNBQU8sS0FBS0QsQ0FBQyxLQUFLQSxDQUFDLEdBQUdFLE9BQVQsQ0FBTixFQUF5QixVQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUN2RCxhQUFTQyxTQUFULENBQW1CQyxLQUFuQixFQUEwQjtBQUFFLFVBQUk7QUFBRUMsUUFBQUEsSUFBSSxDQUFDTixTQUFTLENBQUNPLElBQVYsQ0FBZUYsS0FBZixDQUFELENBQUo7QUFBOEIsT0FBcEMsQ0FBcUMsT0FBT0csQ0FBUCxFQUFVO0FBQUVMLFFBQUFBLE1BQU0sQ0FBQ0ssQ0FBRCxDQUFOO0FBQVk7QUFBRTs7QUFDM0YsYUFBU0MsUUFBVCxDQUFrQkosS0FBbEIsRUFBeUI7QUFBRSxVQUFJO0FBQUVDLFFBQUFBLElBQUksQ0FBQ04sU0FBUyxDQUFDLE9BQUQsQ0FBVCxDQUFtQkssS0FBbkIsQ0FBRCxDQUFKO0FBQWtDLE9BQXhDLENBQXlDLE9BQU9HLENBQVAsRUFBVTtBQUFFTCxRQUFBQSxNQUFNLENBQUNLLENBQUQsQ0FBTjtBQUFZO0FBQUU7O0FBQzlGLGFBQVNGLElBQVQsQ0FBY0ksTUFBZCxFQUFzQjtBQUFFQSxNQUFBQSxNQUFNLENBQUNDLElBQVAsR0FBY1QsT0FBTyxDQUFDUSxNQUFNLENBQUNMLEtBQVIsQ0FBckIsR0FBc0MsSUFBSU4sQ0FBSixDQUFNLFVBQVVHLE9BQVYsRUFBbUI7QUFBRUEsUUFBQUEsT0FBTyxDQUFDUSxNQUFNLENBQUNMLEtBQVIsQ0FBUDtBQUF3QixPQUFuRCxFQUFxRE8sSUFBckQsQ0FB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QUFILENBQVVILElBQVYsQ0FBTixDQW5DZ0QsQ0FvQ2hEOztBQUNBLFlBQU0sSUFBSXBILE9BQUosQ0FBWUMsT0FBTyxJQUFJZ0gsVUFBVSxDQUFDaEgsT0FBRCxFQUFVLElBQVYsQ0FBakMsQ0FBTjtBQUNBZ0ksTUFBQUEsV0FBVyxHQUFHLE1BQU1ILGtCQUFrQixDQUFDSSxPQUF2QztBQUNBbEgsTUFBQUEsTUFBTSxDQUFDeUUsTUFBUCxDQUFjd0MsV0FBZCxFQUEyQnZDLEVBQTNCLENBQThCRyxLQUE5QixDQUFvQyxJQUFwQyxFQUEwQyxnQ0FBMUM7QUFDSCxLQXhDZSxDQUFoQjtBQXlDSCxHQTFDRyxDQUFKO0FBMkNILENBNVVJLENBQUwiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjaGFpXzEgPSByZXF1aXJlKFwiY2hhaVwiKTtcclxuY29uc3QgY2hhaUFzUHJvbWlzZWQgPSByZXF1aXJlKFwiY2hhaS1hcy1wcm9taXNlZFwiKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XHJcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvY29tbW9uL3BsYXRmb3JtL2NvbnN0YW50c1wiKTtcclxuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvY29tbW9uL3R5cGVzXCIpO1xyXG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi91dGlsXCIpO1xyXG5jb25zdCBhc3luY18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vdXRpbHMvYXN5bmNcIik7XHJcbmNvbnN0IGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi92YXJpYWJsZXMvZW52aXJvbm1lbnRcIik7XHJcbmNvbnN0IGVudmlyb25tZW50VmFyaWFibGVzUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvY29tbW9uL3ZhcmlhYmxlcy9lbnZpcm9ubWVudFZhcmlhYmxlc1Byb3ZpZGVyXCIpO1xyXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XHJcbmNvbnN0IGluaXRpYWxpemVfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbml0aWFsaXplXCIpO1xyXG5jb25zdCBwcm9jZXNzXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9ja3MvcHJvY2Vzc1wiKTtcclxuY29uc3Qgc2VydmljZVJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vdW5pdHRlc3RzL3NlcnZpY2VSZWdpc3RyeVwiKTtcclxuY2hhaV8xLnVzZShjaGFpQXNQcm9taXNlZCk7XHJcbmNvbnN0IG11bHRpcm9vdFBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAnLi4nLCAnc3JjJywgJ3Rlc3RNdWx0aVJvb3RXa3NwYycpO1xyXG5jb25zdCB3b3Jrc3BhY2U0UGF0aCA9IHZzY29kZV8xLlVyaS5maWxlKHBhdGguam9pbihtdWx0aXJvb3RQYXRoLCAnd29ya3NwYWNlNCcpKTtcclxuY29uc3Qgd29ya3NwYWNlNFB5RmlsZSA9IHZzY29kZV8xLlVyaS5maWxlKHBhdGguam9pbih3b3Jrc3BhY2U0UGF0aC5mc1BhdGgsICdvbmUucHknKSk7XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtZnVuYy1ib2R5LWxlbmd0aFxyXG5zdWl0ZSgnTXVsdGlyb290IEVudmlyb25tZW50IFZhcmlhYmxlcyBQcm92aWRlcicsICgpID0+IHtcclxuICAgIGxldCBpb2M7XHJcbiAgICBjb25zdCBwYXRoVmFyaWFibGVOYW1lID0gdXRpbF8xLklTX1dJTkRPV1MgPyBjb25zdGFudHNfMS5XSU5ET1dTX1BBVEhfVkFSSUFCTEVfTkFNRSA6IGNvbnN0YW50c18xLk5PTl9XSU5ET1dTX1BBVEhfVkFSSUFCTEVfTkFNRTtcclxuICAgIHN1aXRlU2V0dXAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5pdGlhbGl6ZV8xLklTX01VTFRJX1JPT1RfVEVTVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGhpc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeWllbGQgY29tbW9uXzEuY2xlYXJQeXRob25QYXRoSW5Xb3Jrc3BhY2VGb2xkZXIod29ya3NwYWNlNFBhdGgpO1xyXG4gICAgICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgdW5kZWZpbmVkLCB3b3Jrc3BhY2U0UHlGaWxlLCB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZUZvbGRlcik7XHJcbiAgICAgICAgICAgIHlpZWxkIGluaXRpYWxpemVfMS5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHNldHVwKCgpID0+IHtcclxuICAgICAgICBpb2MgPSBuZXcgc2VydmljZVJlZ2lzdHJ5XzEuVW5pdFRlc3RJb2NDb250YWluZXIoKTtcclxuICAgICAgICBpb2MucmVnaXN0ZXJDb21tb25UeXBlcygpO1xyXG4gICAgICAgIGlvYy5yZWdpc3RlclZhcmlhYmxlVHlwZXMoKTtcclxuICAgICAgICBpb2MucmVnaXN0ZXJQcm9jZXNzVHlwZXMoKTtcclxuICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZV8xLmluaXRpYWxpemVUZXN0KCk7XHJcbiAgICB9KTtcclxuICAgIHN1aXRlVGVhcmRvd24oaW5pdGlhbGl6ZV8xLmNsb3NlQWN0aXZlV2luZG93cyk7XHJcbiAgICB0ZWFyZG93bigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaW9jLmRpc3Bvc2UoKTtcclxuICAgICAgICB5aWVsZCBpbml0aWFsaXplXzEuY2xvc2VBY3RpdmVXaW5kb3dzKCk7XHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEuY2xlYXJQeXRob25QYXRoSW5Xb3Jrc3BhY2VGb2xkZXIod29ya3NwYWNlNFBhdGgpO1xyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLnVwZGF0ZVNldHRpbmcoJ2VudkZpbGUnLCB1bmRlZmluZWQsIHdvcmtzcGFjZTRQeUZpbGUsIHZzY29kZV8xLkNvbmZpZ3VyYXRpb25UYXJnZXQuV29ya3NwYWNlRm9sZGVyKTtcclxuICAgICAgICB5aWVsZCBpbml0aWFsaXplXzEuaW5pdGlhbGl6ZVRlc3QoKTtcclxuICAgIH0pKTtcclxuICAgIGZ1bmN0aW9uIGdldFZhcmlhYmxlc1Byb3ZpZGVyKG1vY2tWYXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudikpIHtcclxuICAgICAgICBjb25zdCBwYXRoVXRpbHMgPSBpb2Muc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JUGF0aFV0aWxzKTtcclxuICAgICAgICBjb25zdCBtb2NrUHJvY2VzcyA9IG5ldyBwcm9jZXNzXzEuTW9ja1Byb2Nlc3MobW9ja1ZhcmlhYmxlcyk7XHJcbiAgICAgICAgY29uc3QgdmFyaWFibGVzU2VydmljZSA9IG5ldyBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50VmFyaWFibGVzU2VydmljZShwYXRoVXRpbHMpO1xyXG4gICAgICAgIGNvbnN0IGRpc3Bvc2FibGVzID0gaW9jLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSURpc3Bvc2FibGVSZWdpc3RyeSk7XHJcbiAgICAgICAgY29uc3QgaXNXaW5kb3dzID0gaW9jLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSXNXaW5kb3dzKTtcclxuICAgICAgICByZXR1cm4gbmV3IGVudmlyb25tZW50VmFyaWFibGVzUHJvdmlkZXJfMS5FbnZpcm9ubWVudFZhcmlhYmxlc1Byb3ZpZGVyKHZhcmlhYmxlc1NlcnZpY2UsIGRpc3Bvc2FibGVzLCBpc1dpbmRvd3MsIG1vY2tQcm9jZXNzKTtcclxuICAgIH1cclxuICAgIHRlc3QoJ0N1c3RvbSB2YXJpYWJsZXMgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQgd2l0aG91dCBhbiBlbnYgZmlsZScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgJ3NvbWVJbnZhbGlkRmlsZS5lbnYnLCB3b3Jrc3BhY2U0UHlGaWxlLCB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZUZvbGRlcik7XHJcbiAgICAgICAgY29uc3QgZW52UHJvdmlkZXIgPSBnZXRWYXJpYWJsZXNQcm92aWRlcigpO1xyXG4gICAgICAgIGNvbnN0IHZhcnMgPSBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICB5aWVsZCBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmV2ZW50dWFsbHkubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBub3QgdW5kZWZpZW5kJyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdDdXN0b20gdmFyaWFibGVzIHNob3VsZCBiZSBwYXJzZWQgZnJvbSBlbnYgZmlsZScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10ZW1wbGF0ZS1zdHJpbmdzXHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygnZW52RmlsZScsICcke3dvcmtzcGFjZVJvb3R9Ly5lbnYnLCB3b3Jrc3BhY2U0UHlGaWxlLCB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZUZvbGRlcik7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc1ZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb2Nlc3MuZW52KTtcclxuICAgICAgICBpZiAocHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVudlByb3ZpZGVyID0gZ2V0VmFyaWFibGVzUHJvdmlkZXIocHJvY2Vzc1ZhcmlhYmxlcyk7XHJcbiAgICAgICAgY29uc3QgdmFycyA9IHlpZWxkIGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0UFlFWFRVTklUVEVTVFZBUicsICcxMjM0JywgJ1gxMjM0UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05QQVRIJywgJy4uL3dvcmtzcGFjZTUnLCAnUFlUSE9OUEFUSCB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdBbGwgcHJvY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHZhcmlhYmxlcyByZXR1cm5lZCcsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10ZW1wbGF0ZS1zdHJpbmdzXHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygnZW52RmlsZScsICcke3dvcmtzcGFjZVJvb3R9Ly5lbnYnLCB3b3Jrc3BhY2U0UHlGaWxlLCB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZUZvbGRlcik7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc1ZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb2Nlc3MuZW52KTtcclxuICAgICAgICBpZiAocHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVudlByb3ZpZGVyID0gZ2V0VmFyaWFibGVzUHJvdmlkZXIocHJvY2Vzc1ZhcmlhYmxlcyk7XHJcbiAgICAgICAgY29uc3QgdmFycyA9IHlpZWxkIGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0UFlFWFRVTklUVEVTVFZBUicsICcxMjM0JywgJ1gxMjM0UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05QQVRIJywgJy4uL3dvcmtzcGFjZTUnLCAnUFlUSE9OUEFUSCB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgT2JqZWN0LmtleXMocHJvY2Vzc1ZhcmlhYmxlcykuZm9yRWFjaCh2YXJpYWJsZSA9PiB7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8uaGF2ZS5wcm9wZXJ0eSh2YXJpYWJsZSwgcHJvY2Vzc1ZhcmlhYmxlc1t2YXJpYWJsZV0sICdWYWx1ZSBvZiB0aGUgdmFyaWFibGUgaXMgaW5jb3JyZWN0Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdWYXJpYWJsZXMgZnJvbSBmaWxlIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB2YXJpYWJsZXMgaW4gcHJvY2VzcycsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10ZW1wbGF0ZS1zdHJpbmdzXHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygnZW52RmlsZScsICcke3dvcmtzcGFjZVJvb3R9Ly5lbnYnLCB3b3Jrc3BhY2U0UHlGaWxlLCB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZUZvbGRlcik7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc1ZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb2Nlc3MuZW52KTtcclxuICAgICAgICBpZiAocHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2Nlc3NWYXJpYWJsZXMuWDEyMzRQWUVYVFVOSVRURVNUVkFSID0gJ2FiY2QnO1xyXG4gICAgICAgIHByb2Nlc3NWYXJpYWJsZXMuQUJDRCA9ICdhYmNkJztcclxuICAgICAgICBjb25zdCBlbnZQcm92aWRlciA9IGdldFZhcmlhYmxlc1Byb3ZpZGVyKHByb2Nlc3NWYXJpYWJsZXMpO1xyXG4gICAgICAgIGNvbnN0IHZhcnMgPSB5aWVsZCBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLm5vdC5lcXVhbCh1bmRlZmluZWQsICdWYXJpYWJsZXMgaXMgaXMgdW5kZWZpZW5kJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdYMTIzNFBZRVhUVU5JVFRFU1RWQVInLCAnMTIzNCcsICdYMTIzNFBZRVhUVU5JVFRFU1RWQVIgdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8uaGF2ZS5wcm9wZXJ0eSgnQUJDRCcsICdhYmNkJywgJ0FCQ0QgdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8uaGF2ZS5wcm9wZXJ0eSgnUFlUSE9OUEFUSCcsICcuLi93b3Jrc3BhY2U1JywgJ1BZVEhPTlBBVEggdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnUFlUSE9OUEFUSCBmcm9tIHByb2Nlc3MgdmFyaWFibGVzIHNob3VsZCBiZSBtZXJnZWQgd2l0aCB0aGF0IGluIGVudiBmaWxlJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRlbXBsYXRlLXN0cmluZ3NcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgJyR7d29ya3NwYWNlUm9vdH0vLmVudicsIHdvcmtzcGFjZTRQeUZpbGUsIHZzY29kZV8xLkNvbmZpZ3VyYXRpb25UYXJnZXQuV29ya3NwYWNlRm9sZGVyKTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzVmFyaWFibGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYpO1xyXG4gICAgICAgIHByb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSCA9ICcvdXNyL29uZS9UV08nO1xyXG4gICAgICAgIGNvbnN0IGVudlByb3ZpZGVyID0gZ2V0VmFyaWFibGVzUHJvdmlkZXIocHJvY2Vzc1ZhcmlhYmxlcyk7XHJcbiAgICAgICAgY29uc3QgdmFycyA9IHlpZWxkIGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUHl0aG9uUGF0aCA9IGAuLi93b3Jrc3BhY2U1JHtwYXRoLmRlbGltaXRlcn0ke3Byb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSH1gO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0UFlFWFRVTklUVEVTVFZBUicsICcxMjM0JywgJ1gxMjM0UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05QQVRIJywgZXhwZWN0ZWRQeXRob25QYXRoLCAnUFlUSE9OUEFUSCB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdQQVRIIGZyb20gcHJvY2VzcyB2YXJpYWJsZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIGluIHZhcmlhYmxlcyByZXR1cm5lZCAobW9jayB2YXJpYWJsZXMpJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRlbXBsYXRlLXN0cmluZ3NcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgJyR7d29ya3NwYWNlUm9vdH0vLmVudicsIHdvcmtzcGFjZTRQeUZpbGUsIHZzY29kZV8xLkNvbmZpZ3VyYXRpb25UYXJnZXQuV29ya3NwYWNlRm9sZGVyKTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzVmFyaWFibGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYpO1xyXG4gICAgICAgIHByb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSCA9ICcvdXNyL29uZS9UV08nO1xyXG4gICAgICAgIHByb2Nlc3NWYXJpYWJsZXNbcGF0aFZhcmlhYmxlTmFtZV0gPSAnL3Vzci9vbmUvVEhSRUUnO1xyXG4gICAgICAgIGNvbnN0IGVudlByb3ZpZGVyID0gZ2V0VmFyaWFibGVzUHJvdmlkZXIocHJvY2Vzc1ZhcmlhYmxlcyk7XHJcbiAgICAgICAgY29uc3QgdmFycyA9IHlpZWxkIGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUHl0aG9uUGF0aCA9IGAuLi93b3Jrc3BhY2U1JHtwYXRoLmRlbGltaXRlcn0ke3Byb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSH1gO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0UFlFWFRVTklUVEVTVFZBUicsICcxMjM0JywgJ1gxMjM0UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05QQVRIJywgZXhwZWN0ZWRQeXRob25QYXRoLCAnUFlUSE9OUEFUSCB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KHBhdGhWYXJpYWJsZU5hbWUsIHByb2Nlc3NWYXJpYWJsZXNbcGF0aFZhcmlhYmxlTmFtZV0sICdQQVRIIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ1BBVEggZnJvbSBwcm9jZXNzIHZhcmlhYmxlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gaW4gdmFyaWFibGVzIHJldHVybmVkJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRlbXBsYXRlLXN0cmluZ3NcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgJyR7d29ya3NwYWNlUm9vdH0vLmVudicsIHdvcmtzcGFjZTRQeUZpbGUsIHZzY29kZV8xLkNvbmZpZ3VyYXRpb25UYXJnZXQuV29ya3NwYWNlRm9sZGVyKTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzVmFyaWFibGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYpO1xyXG4gICAgICAgIHByb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSCA9ICcvdXNyL29uZS9UV08nO1xyXG4gICAgICAgIGNvbnN0IGVudlByb3ZpZGVyID0gZ2V0VmFyaWFibGVzUHJvdmlkZXIocHJvY2Vzc1ZhcmlhYmxlcyk7XHJcbiAgICAgICAgY29uc3QgdmFycyA9IHlpZWxkIGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUHl0aG9uUGF0aCA9IGAuLi93b3Jrc3BhY2U1JHtwYXRoLmRlbGltaXRlcn0ke3Byb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSH1gO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0UFlFWFRVTklUVEVTVFZBUicsICcxMjM0JywgJ1gxMjM0UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05QQVRIJywgZXhwZWN0ZWRQeXRob25QYXRoLCAnUFlUSE9OUEFUSCB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KHBhdGhWYXJpYWJsZU5hbWUsIHByb2Nlc3NWYXJpYWJsZXNbcGF0aFZhcmlhYmxlTmFtZV0sICdQQVRIIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ1BZVEhPTlBBVEggYW5kIFBBVEggZnJvbSBwcm9jZXNzIHZhcmlhYmxlcyBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhhdCBpbiBlbnYgZmlsZScsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10ZW1wbGF0ZS1zdHJpbmdzXHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygnZW52RmlsZScsICcke3dvcmtzcGFjZVJvb3R9Ly5lbnY1Jywgd29ya3NwYWNlNFB5RmlsZSwgdnNjb2RlXzEuQ29uZmlndXJhdGlvblRhcmdldC5Xb3Jrc3BhY2VGb2xkZXIpO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NWYXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudik7XHJcbiAgICAgICAgcHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIID0gJy91c3Ivb25lL1RXTyc7XHJcbiAgICAgICAgcHJvY2Vzc1ZhcmlhYmxlc1twYXRoVmFyaWFibGVOYW1lXSA9ICcvdXNyL29uZS9USFJFRSc7XHJcbiAgICAgICAgY29uc3QgZW52UHJvdmlkZXIgPSBnZXRWYXJpYWJsZXNQcm92aWRlcihwcm9jZXNzVmFyaWFibGVzKTtcclxuICAgICAgICBjb25zdCB2YXJzID0geWllbGQgZW52UHJvdmlkZXIuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMod29ya3NwYWNlNFB5RmlsZSk7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRQeXRob25QYXRoID0gYC91c3Ivb25lL3RocmVlOi91c3Ivb25lL2ZvdXIke3BhdGguZGVsaW1pdGVyfSR7cHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIfWA7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRQYXRoID0gYC91c3IveDovdXNyL3kke3BhdGguZGVsaW1pdGVyfSR7cHJvY2Vzc1ZhcmlhYmxlc1twYXRoVmFyaWFibGVOYW1lXX1gO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gnLCAnMScsICdYIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1knLCAnMicsICdZIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlBBVEgnLCBleHBlY3RlZFB5dGhvblBhdGgsICdQWVRIT05QQVRIIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkocGF0aFZhcmlhYmxlTmFtZSwgZXhwZWN0ZWRQYXRoLCAnUEFUSCB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdQQVRIIGFuZCBQWVRIT05QQVRIIGZyb20gZW52IGZpbGUgc2hvdWxkIGJlIHJldHVybmVkIGFzIGlzJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRlbXBsYXRlLXN0cmluZ3NcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgJyR7d29ya3NwYWNlUm9vdH0vLmVudjUnLCB3b3Jrc3BhY2U0UHlGaWxlLCB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZUZvbGRlcik7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc1ZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb2Nlc3MuZW52KTtcclxuICAgICAgICBpZiAocHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzVmFyaWFibGVzW3BhdGhWYXJpYWJsZU5hbWVdKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9jZXNzVmFyaWFibGVzW3BhdGhWYXJpYWJsZU5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbnZQcm92aWRlciA9IGdldFZhcmlhYmxlc1Byb3ZpZGVyKHByb2Nlc3NWYXJpYWJsZXMpO1xyXG4gICAgICAgIGNvbnN0IHZhcnMgPSB5aWVsZCBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICBjb25zdCBleHBlY3RlZFB5dGhvblBhdGggPSAnL3Vzci9vbmUvdGhyZWU6L3Vzci9vbmUvZm91cic7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRQYXRoID0gJy91c3IveDovdXNyL3knO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gnLCAnMScsICdYIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1knLCAnMicsICdZIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlBBVEgnLCBleHBlY3RlZFB5dGhvblBhdGgsICdQWVRIT05QQVRIIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkocGF0aFZhcmlhYmxlTmFtZSwgZXhwZWN0ZWRQYXRoLCAnUEFUSCB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICB9KSk7XHJcbiAgICB0ZXN0KCdQWVRIT05QQVRIIGFuZCBQQVRIIGZyb20gcHJvY2VzcyB2YXJpYWJsZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHZhcmlhYmxlcyByZXR1cm5lZCcsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10ZW1wbGF0ZS1zdHJpbmdzXHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygnZW52RmlsZScsICcke3dvcmtzcGFjZVJvb3R9Ly5lbnYyJywgd29ya3NwYWNlNFB5RmlsZSwgdnNjb2RlXzEuQ29uZmlndXJhdGlvblRhcmdldC5Xb3Jrc3BhY2VGb2xkZXIpO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NWYXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudik7XHJcbiAgICAgICAgcHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIID0gJy91c3Ivb25lL1RXTyc7XHJcbiAgICAgICAgcHJvY2Vzc1ZhcmlhYmxlc1twYXRoVmFyaWFibGVOYW1lXSA9ICcvdXNyL29uZS9USFJFRSc7XHJcbiAgICAgICAgY29uc3QgZW52UHJvdmlkZXIgPSBnZXRWYXJpYWJsZXNQcm92aWRlcihwcm9jZXNzVmFyaWFibGVzKTtcclxuICAgICAgICBjb25zdCB2YXJzID0geWllbGQgZW52UHJvdmlkZXIuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMod29ya3NwYWNlNFB5RmlsZSk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5ub3QuZXF1YWwodW5kZWZpbmVkLCAnVmFyaWFibGVzIGlzIGlzIHVuZGVmaWVuZCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8uaGF2ZS5wcm9wZXJ0eSgnWDEyMzQ1UFlFWFRVTklUVEVTVFZBUicsICcxMjM0NScsICdYMTIzNDVQWUVYVFVOSVRURVNUVkFSIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlBBVEgnLCBwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEgsICdQWVRIT05QQVRIIHZhbHVlIGlzIGludmFsaWQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkocGF0aFZhcmlhYmxlTmFtZSwgcHJvY2Vzc1ZhcmlhYmxlc1twYXRoVmFyaWFibGVOYW1lXSwgJ1BBVEggdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnUFlUSE9OUEFUSCBzaG91bGQgbm90IGV4aXN0IGluIHZhcmlhYmxlcyByZXR1cm5lZCcsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10ZW1wbGF0ZS1zdHJpbmdzXHJcbiAgICAgICAgeWllbGQgY29tbW9uXzEudXBkYXRlU2V0dGluZygnZW52RmlsZScsICcke3dvcmtzcGFjZVJvb3R9Ly5lbnYyJywgd29ya3NwYWNlNFB5RmlsZSwgdnNjb2RlXzEuQ29uZmlndXJhdGlvblRhcmdldC5Xb3Jrc3BhY2VGb2xkZXIpO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NWYXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudik7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSCkge1xyXG4gICAgICAgICAgICBkZWxldGUgcHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9jZXNzVmFyaWFibGVzW3BhdGhWYXJpYWJsZU5hbWVdID0gJy91c3Ivb25lL1RIUkVFJztcclxuICAgICAgICBjb25zdCBlbnZQcm92aWRlciA9IGdldFZhcmlhYmxlc1Byb3ZpZGVyKHByb2Nlc3NWYXJpYWJsZXMpO1xyXG4gICAgICAgIGNvbnN0IHZhcnMgPSB5aWVsZCBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLm5vdC5lcXVhbCh1bmRlZmluZWQsICdWYXJpYWJsZXMgaXMgaXMgdW5kZWZpZW5kJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdYMTIzNDVQWUVYVFVOSVRURVNUVkFSJywgJzEyMzQ1JywgJ1gxMjM0NVBZRVhUVU5JVFRFU1RWQVIgdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmhhdmUucHJvcGVydHkoJ1BZVEhPTlBBVEgnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkocGF0aFZhcmlhYmxlTmFtZSwgcHJvY2Vzc1ZhcmlhYmxlc1twYXRoVmFyaWFibGVOYW1lXSwgJ1BBVEggdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnQ3VzdG9tIHZhcmlhYmxlcyBzaG91bGQgbm90IGJlIG1lcmdlZCB3aXRoIHByb2Nlc3MgZW52aXJvbm1lbnQgdmFyYWlibGVzJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJhbmRvbUVudlZhcmlhYmxlID0gYFVOSVRfVEVTVF9QWVRIT05fRVhUX1JBTkRPTV9WQVJJQUJMRV8ke25ldyBEYXRlKCkuZ2V0U2Vjb25kcygpfWA7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc1ZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb2Nlc3MuZW52KTtcclxuICAgICAgICBwcm9jZXNzVmFyaWFibGVzW3JhbmRvbUVudlZhcmlhYmxlXSA9ICcxMjM0JztcclxuICAgICAgICBpZiAocHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRlbXBsYXRlLXN0cmluZ3NcclxuICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgJyR7d29ya3NwYWNlUm9vdH0vLmVudicsIHdvcmtzcGFjZTRQeUZpbGUsIHZzY29kZV8xLkNvbmZpZ3VyYXRpb25UYXJnZXQuV29ya3NwYWNlRm9sZGVyKTtcclxuICAgICAgICBjb25zdCBlbnZQcm92aWRlciA9IGdldFZhcmlhYmxlc1Byb3ZpZGVyKHByb2Nlc3NWYXJpYWJsZXMpO1xyXG4gICAgICAgIGNvbnN0IHZhcnMgPSB5aWVsZCBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLm5vdC5lcXVhbCh1bmRlZmluZWQsICdWYXJpYWJsZXMgaXMgaXMgdW5kZWZpZW5kJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdYMTIzNFBZRVhUVU5JVFRFU1RWQVInLCAnMTIzNCcsICdYMTIzNFBZRVhUVU5JVFRFU1RWQVIgdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8uaGF2ZS5wcm9wZXJ0eSgnUFlUSE9OUEFUSCcsICcuLi93b3Jrc3BhY2U1JywgJ1BZVEhPTlBBVEggdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LnRvLmhhdmUucHJvcGVydHkocmFuZG9tRW52VmFyaWFibGUsIHVuZGVmaW5lZCwgJ1lpa2VzIHByb2Nlc3MgdmFyaWFibGUgaGFzIGxlYWtlZCcpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnQ3VzdG9tIHZhcmlhYmxlcyBzaG91bGQgYmUgbWVyZ2VkIHdpdGggcHJvY2VzcyBlbnZpcm9ubWVudCB2YXJhaWJsZXMnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZG9tRW52VmFyaWFibGUgPSBgVU5JVF9URVNUX1BZVEhPTl9FWFRfUkFORE9NX1ZBUklBQkxFXyR7bmV3IERhdGUoKS5nZXRTZWNvbmRzKCl9YDtcclxuICAgICAgICBjb25zdCBwcm9jZXNzVmFyaWFibGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYpO1xyXG4gICAgICAgIHByb2Nlc3NWYXJpYWJsZXNbcmFuZG9tRW52VmFyaWFibGVdID0gJzEyMzQnO1xyXG4gICAgICAgIGlmIChwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEgpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHByb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGVtcGxhdGUtc3RyaW5nc1xyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLnVwZGF0ZVNldHRpbmcoJ2VudkZpbGUnLCAnJHt3b3Jrc3BhY2VSb290fS8uZW52Jywgd29ya3NwYWNlNFB5RmlsZSwgdnNjb2RlXzEuQ29uZmlndXJhdGlvblRhcmdldC5Xb3Jrc3BhY2VGb2xkZXIpO1xyXG4gICAgICAgIGNvbnN0IGVudlByb3ZpZGVyID0gZ2V0VmFyaWFibGVzUHJvdmlkZXIocHJvY2Vzc1ZhcmlhYmxlcyk7XHJcbiAgICAgICAgY29uc3QgdmFycyA9IHlpZWxkIGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0UFlFWFRVTklUVEVTVFZBUicsICcxMjM0JywgJ1gxMjM0UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdQWVRIT05QQVRIJywgJy4uL3dvcmtzcGFjZTUnLCAnUFlUSE9OUEFUSCB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KHJhbmRvbUVudlZhcmlhYmxlLCAnMTIzNCcsICdZaWtlcyBwcm9jZXNzIHZhcmlhYmxlIGhhcyBsZWFrZWQnKTtcclxuICAgIH0pKTtcclxuICAgIHRlc3QoJ0N1c3RvbSB2YXJpYWJsZXMgd2lsbCBiZSByZWZyZXNoZWQgd2hlbiBzZXR0aW5ncyBwb2ludHMgdG8gYSBkaWZmZXJlbnQgZW52IGZpbGUnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGVtcGxhdGUtc3RyaW5nc1xyXG4gICAgICAgIHlpZWxkIGNvbW1vbl8xLnVwZGF0ZVNldHRpbmcoJ2VudkZpbGUnLCAnJHt3b3Jrc3BhY2VSb290fS8uZW52Jywgd29ya3NwYWNlNFB5RmlsZSwgdnNjb2RlXzEuQ29uZmlndXJhdGlvblRhcmdldC5Xb3Jrc3BhY2VGb2xkZXIpO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NWYXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudik7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NWYXJpYWJsZXMuUFlUSE9OUEFUSCkge1xyXG4gICAgICAgICAgICBkZWxldGUgcHJvY2Vzc1ZhcmlhYmxlcy5QWVRIT05QQVRIO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbnZQcm92aWRlciA9IGdldFZhcmlhYmxlc1Byb3ZpZGVyKHByb2Nlc3NWYXJpYWJsZXMpO1xyXG4gICAgICAgIGNvbnN0IHZhcnMgPSB5aWVsZCBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLm5vdC5lcXVhbCh1bmRlZmluZWQsICdWYXJpYWJsZXMgaXMgaXMgdW5kZWZpZW5kJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5oYXZlLnByb3BlcnR5KCdYMTIzNFBZRVhUVU5JVFRFU1RWQVInLCAnMTIzNCcsICdYMTIzNFBZRVhUVU5JVFRFU1RWQVIgdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QodmFycykudG8uaGF2ZS5wcm9wZXJ0eSgnUFlUSE9OUEFUSCcsICcuLi93b3Jrc3BhY2U1JywgJ1BZVEhPTlBBVEggdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gdnNjb2RlXzEud29ya3NwYWNlLmdldENvbmZpZ3VyYXRpb24oJ3B5dGhvbicsIHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnZhbGlkLXRlbXBsYXRlLXN0cmluZ3NcclxuICAgICAgICB5aWVsZCBzZXR0aW5ncy51cGRhdGUoJ2VudkZpbGUnLCAnJHt3b3Jrc3BhY2VSb290fS8uZW52MicsIHZzY29kZV8xLkNvbmZpZ3VyYXRpb25UYXJnZXQuV29ya3NwYWNlRm9sZGVyKTtcclxuICAgICAgICAvLyBXYWl0IGZvciBzZXR0aW5ncyB0byBnZXQgcmVmcmVzaGVkLlxyXG4gICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XHJcbiAgICAgICAgY29uc3QgbmV3VmFycyA9IHlpZWxkIGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgIGNoYWlfMS5leHBlY3QobmV3VmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICBjaGFpXzEuZXhwZWN0KG5ld1ZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0NVBZRVhUVU5JVFRFU1RWQVInLCAnMTIzNDUnLCAnWDEyMzQ1UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgY2hhaV8xLmV4cGVjdChuZXdWYXJzKS50by5ub3QudG8uaGF2ZS5wcm9wZXJ0eSgnUFlUSE9OUEFUSCcsICcuLi93b3Jrc3BhY2U1JywgJ1BZVEhPTlBBVEggdmFsdWUgaXMgaW52YWxpZCcpO1xyXG4gICAgfSkpO1xyXG4gICAgdGVzdCgnQ3VzdG9tIHZhcmlhYmxlcyB3aWxsIGJlIHJlZnJlc2hlZCB3aGVuIC5lbnYgZmlsZSBpcyBjcmVhdGVkLCBtb2RpZmllZCBhbmQgZGVsZXRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10aGlzXHJcbiAgICAgICAgICAgIHRoaXMudGltZW91dCgyMDAwMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudjMgPSBwYXRoLmpvaW4od29ya3NwYWNlNFBhdGguZnNQYXRoLCAnLmVudjMnKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZUV4aXN0cyA9IHlpZWxkIGZzLnBhdGhFeGlzdHMoZW52Myk7XHJcbiAgICAgICAgICAgIGlmIChmaWxlRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBmcy5yZW1vdmUoZW52Myk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGVtcGxhdGUtc3RyaW5nc1xyXG4gICAgICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgJyR7d29ya3NwYWNlUm9vdH0vLmVudjMnLCB3b3Jrc3BhY2U0UHlGaWxlLCB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZUZvbGRlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NWYXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudik7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEgpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZW52UHJvdmlkZXIgPSBnZXRWYXJpYWJsZXNQcm92aWRlcihwcm9jZXNzVmFyaWFibGVzKTtcclxuICAgICAgICAgICAgY29uc3QgdmFycyA9IGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgICAgICB5aWVsZCBjaGFpXzEuZXhwZWN0KHZhcnMpLnRvLmV2ZW50dWFsbHkubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQnKTtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGVudjMuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHBhdGguam9pbih3b3Jrc3BhY2U0UGF0aC5mc1BhdGgsICcuZW52MicpKTtcclxuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhlbnYzLCBjb250ZW50cyk7XHJcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHNldHRpbmdzIHRvIGdldCByZWZyZXNoZWQuXHJcbiAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhcnMgPSB5aWVsZCBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChuZXdWYXJzKS50by5ub3QuZXF1YWwodW5kZWZpbmVkLCAnVmFyaWFibGVzIGlzIGlzIHVuZGVmaWVuZCBhZnRlciBjcmVhdGluZycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KG5ld1ZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0NVBZRVhUVU5JVFRFU1RWQVInLCAnMTIzNDUnLCAnWDEyMzQ1UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkIGFmdGVyIGNyZWF0aW5nJyk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QobmV3VmFycykudG8ubm90LnRvLmhhdmUucHJvcGVydHkoJ1BZVEhPTlBBVEgnLCAnLi4vd29ya3NwYWNlNScsICdQWVRIT05QQVRIIHZhbHVlIGlzIGludmFsaWQgYWZ0ZXIgY3JlYXRpbmcnKTtcclxuICAgICAgICAgICAgLy8gTW9kaWZ5IGVudjMuXHJcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZW52MywgYCR7Y29udGVudHN9JHtvc18xLkVPTH1YMTIzNDU2UFlFWFRVTklUVEVTVFZBUj0xMjM0NTZgKTtcclxuICAgICAgICAgICAgLy8gV2FpdCBmb3Igc2V0dGluZ3MgdG8gZ2V0IHJlZnJlc2hlZC5cclxuICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFZhcnMgPSB5aWVsZCBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdCh1cGRhdGVkVmFycykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCwgJ1ZhcmlhYmxlcyBpcyBpcyB1bmRlZmllbmQgYWZ0ZXIgbW9kaWZ5aW5nJyk7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodXBkYXRlZFZhcnMpLnRvLmhhdmUucHJvcGVydHkoJ1gxMjM0NVBZRVhUVU5JVFRFU1RWQVInLCAnMTIzNDUnLCAnWDEyMzQ1UFlFWFRVTklUVEVTVFZBUiB2YWx1ZSBpcyBpbnZhbGlkIGFmdGVyIG1vZGlmeWluZycpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHVwZGF0ZWRWYXJzKS50by5ub3QudG8uaGF2ZS5wcm9wZXJ0eSgnUFlUSE9OUEFUSCcsICcuLi93b3Jrc3BhY2U1JywgJ1BZVEhPTlBBVEggdmFsdWUgaXMgaW52YWxpZCBhZnRlciBtb2RpZnlpbmcnKTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdCh1cGRhdGVkVmFycykudG8uaGF2ZS5wcm9wZXJ0eSgnWDEyMzQ1NlBZRVhUVU5JVFRFU1RWQVInLCAnMTIzNDU2JywgJ1gxMjM0NTZQWUVYVFVOSVRURVNUVkFSIHZhbHVlIGlzIGludmFsaWQgYWZ0ZXIgbW9kaWZ5aW5nJyk7XHJcbiAgICAgICAgICAgIC8vIE5vdyByZW1vdmUgZW52My5cclxuICAgICAgICAgICAgeWllbGQgZnMucmVtb3ZlKGVudjMpO1xyXG4gICAgICAgICAgICAvLyBXYWl0IGZvciBzZXR0aW5ncyB0byBnZXQgcmVmcmVzaGVkLlxyXG4gICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xyXG4gICAgICAgICAgICBjb25zdCB2YXJzQWZ0ZXJEZWxldGluZyA9IHlpZWxkIGVudlByb3ZpZGVyLmdldEVudmlyb25tZW50VmFyaWFibGVzKHdvcmtzcGFjZTRQeUZpbGUpO1xyXG4gICAgICAgICAgICBjaGFpXzEuZXhwZWN0KHZhcnNBZnRlckRlbGV0aW5nKS50by5ub3QuZXF1YWwodW5kZWZpbmVkLCAnVmFyaWFibGVzIGlzIHVuZGVmaWVuZCBhZnRlciBkZWxldGluZycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB0ZXN0KCdDaGFuZ2UgZXZlbnQgd2lsbCBiZSByYWlzZWQgd2hlbiB3aGVuIC5lbnYgZmlsZSBpcyBjcmVhdGVkLCBtb2RpZmllZCBhbmQgZGVsZXRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW52YWxpZC10aGlzXHJcbiAgICAgICAgICAgIHRoaXMudGltZW91dCgyMDAwMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudjMgPSBwYXRoLmpvaW4od29ya3NwYWNlNFBhdGguZnNQYXRoLCAnLmVudjMnKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZUV4aXN0cyA9IHlpZWxkIGZzLnBhdGhFeGlzdHMoZW52Myk7XHJcbiAgICAgICAgICAgIGlmIChmaWxlRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBmcy5yZW1vdmUoZW52Myk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWludmFsaWQtdGVtcGxhdGUtc3RyaW5nc1xyXG4gICAgICAgICAgICB5aWVsZCBjb21tb25fMS51cGRhdGVTZXR0aW5nKCdlbnZGaWxlJywgJyR7d29ya3NwYWNlUm9vdH0vLmVudjMnLCB3b3Jrc3BhY2U0UHlGaWxlLCB2c2NvZGVfMS5Db25maWd1cmF0aW9uVGFyZ2V0LldvcmtzcGFjZUZvbGRlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NWYXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudik7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEgpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9jZXNzVmFyaWFibGVzLlBZVEhPTlBBVEg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZW52UHJvdmlkZXIgPSBnZXRWYXJpYWJsZXNQcm92aWRlcihwcm9jZXNzVmFyaWFibGVzKTtcclxuICAgICAgICAgICAgbGV0IGV2ZW50UmFpc2VkUHJvbWlzZSA9IGFzeW5jXzEuY3JlYXRlRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgZW52UHJvdmlkZXIub25EaWRFbnZpcm9ubWVudFZhcmlhYmxlc0NoYW5nZSgoKSA9PiBldmVudFJhaXNlZFByb21pc2UucmVzb2x2ZSh0cnVlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhcnMgPSBlbnZQcm92aWRlci5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh3b3Jrc3BhY2U0UHlGaWxlKTtcclxuICAgICAgICAgICAgeWllbGQgY2hhaV8xLmV4cGVjdCh2YXJzKS50by5ldmVudHVhbGx5Lm5vdC5lcXVhbCh1bmRlZmluZWQsICdWYXJpYWJsZXMgaXMgaXMgdW5kZWZpZW5kJyk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBlbnYzLlxyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4od29ya3NwYWNlNFBhdGguZnNQYXRoLCAnLmVudjInKSk7XHJcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZW52MywgY29udGVudHMpO1xyXG4gICAgICAgICAgICAvLyBXYWl0IGZvciBzZXR0aW5ncyB0byBnZXQgcmVmcmVzaGVkLlxyXG4gICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRSYWlzZWQgPSB5aWVsZCBldmVudFJhaXNlZFByb21pc2UucHJvbWlzZTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChldmVudFJhaXNlZCkudG8uZXF1YWwodHJ1ZSwgJ0NyZWF0ZSBub3RpZmljYXRpb24gbm90IHJhaXNlZCcpO1xyXG4gICAgICAgICAgICAvLyBNb2RpZnkgZW52My5cclxuICAgICAgICAgICAgZXZlbnRSYWlzZWRQcm9taXNlID0gYXN5bmNfMS5jcmVhdGVEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGVudjMsIGAke2NvbnRlbnRzfSR7b3NfMS5FT0x9WDEyMzQ1NlBZRVhUVU5JVFRFU1RWQVI9MTIzNDU2YCk7XHJcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHNldHRpbmdzIHRvIGdldCByZWZyZXNoZWQuXHJcbiAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XHJcbiAgICAgICAgICAgIGV2ZW50UmFpc2VkID0geWllbGQgZXZlbnRSYWlzZWRQcm9taXNlLnByb21pc2U7XHJcbiAgICAgICAgICAgIGNoYWlfMS5leHBlY3QoZXZlbnRSYWlzZWQpLnRvLmVxdWFsKHRydWUsICdDaGFuZ2Ugbm90aWZpY2F0aW9uIG5vdCByYWlzZWQnKTtcclxuICAgICAgICAgICAgLy8gTm93IHJlbW92ZSBlbnYzLlxyXG4gICAgICAgICAgICBldmVudFJhaXNlZFByb21pc2UgPSBhc3luY18xLmNyZWF0ZURlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIHlpZWxkIGZzLnJlbW92ZShlbnYzKTtcclxuICAgICAgICAgICAgLy8gV2FpdCBmb3Igc2V0dGluZ3MgdG8gZ2V0IHJlZnJlc2hlZC5cclxuICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcclxuICAgICAgICAgICAgZXZlbnRSYWlzZWQgPSB5aWVsZCBldmVudFJhaXNlZFByb21pc2UucHJvbWlzZTtcclxuICAgICAgICAgICAgY2hhaV8xLmV4cGVjdChldmVudFJhaXNlZCkudG8uZXF1YWwodHJ1ZSwgJ0RlbGV0ZSBub3RpZmljYXRpb24gbm90IHJhaXNlZCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZWYXJzUHJvdmlkZXIubXVsdGlyb290LnRlc3QuanMubWFwIl19