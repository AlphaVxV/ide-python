// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
}); // tslint:disable:max-func-body-length no-invalid-this

const assert_1 = require("assert");

const chai_1 = require("chai");

const chaiAsPromised = require("chai-as-promised");

const TypeMoq = require("typemoq");

const vscode_1 = require("vscode");

require("../../../client/common/extensions");

const productInstaller_1 = require("../../../client/common/installer/productInstaller");

const productPath_1 = require("../../../client/common/installer/productPath");

const productService_1 = require("../../../client/common/installer/productService");

const types_1 = require("../../../client/common/installer/types");

const types_2 = require("../../../client/common/types");

const enum_1 = require("../../../client/common/utils/enum");

const types_3 = require("../../../client/formatters/types");

const types_4 = require("../../../client/linters/types");

const types_5 = require("../../../client/unittests/common/types");

chai_1.use(chaiAsPromised);
suite('Product Path', () => {
  [undefined, vscode_1.Uri.file('resource')].forEach(resource => {
    enum_1.getNamesAndValues(types_2.Product).forEach(product => {
      let serviceContainer;
      let formattingSettings;
      let unitTestSettings;
      let workspaceSymnbolSettings;
      let configService;
      let productInstaller;
      setup(() => {
        serviceContainer = TypeMoq.Mock.ofType();
        configService = TypeMoq.Mock.ofType();
        formattingSettings = TypeMoq.Mock.ofType();
        unitTestSettings = TypeMoq.Mock.ofType();
        workspaceSymnbolSettings = TypeMoq.Mock.ofType();
        productInstaller = new productInstaller_1.ProductInstaller(serviceContainer.object, TypeMoq.Mock.ofType().object);
        const pythonSettings = TypeMoq.Mock.ofType();
        pythonSettings.setup(p => p.formatting).returns(() => formattingSettings.object);
        pythonSettings.setup(p => p.unitTest).returns(() => unitTestSettings.object);
        pythonSettings.setup(p => p.workspaceSymbols).returns(() => workspaceSymnbolSettings.object);
        configService.setup(s => s.getSettings(TypeMoq.It.isValue(resource))).returns(() => pythonSettings.object);
        serviceContainer.setup(s => s.get(TypeMoq.It.isValue(types_2.IConfigurationService), TypeMoq.It.isAny())).returns(() => configService.object);
        serviceContainer.setup(s => s.get(TypeMoq.It.isValue(types_2.IInstaller), TypeMoq.It.isAny())).returns(() => productInstaller);
        serviceContainer.setup(c => c.get(TypeMoq.It.isValue(types_1.IProductService), TypeMoq.It.isAny())).returns(() => new productService_1.ProductService());
      });

      if (product.value === types_2.Product.isort) {
        return;
      }

      const productType = new productService_1.ProductService().getProductType(product.value);

      switch (productType) {
        case types_2.ProductType.Formatter:
          {
            test(`Ensure path is returned for ${product.name} (${resource ? 'With a resource' : 'without a resource'})`, () => __awaiter(void 0, void 0, void 0, function* () {
              const productPathService = new productPath_1.FormatterProductPathService(serviceContainer.object);
              const formatterHelper = TypeMoq.Mock.ofType();
              const expectedPath = 'Some Path';
              serviceContainer.setup(s => s.get(TypeMoq.It.isValue(types_3.IFormatterHelper), TypeMoq.It.isAny())).returns(() => formatterHelper.object);
              formattingSettings.setup(f => f.autopep8Path).returns(() => expectedPath).verifiable(TypeMoq.Times.atLeastOnce());
              formatterHelper.setup(f => f.getSettingsPropertyNames(TypeMoq.It.isValue(product.value))).returns(() => {
                return {
                  pathName: 'autopep8Path',
                  argsName: 'autopep8Args'
                };
              }).verifiable(TypeMoq.Times.once());
              const value = productPathService.getExecutableNameFromSettings(product.value, resource);
              chai_1.expect(value).to.be.equal(expectedPath);
              formattingSettings.verifyAll();
              formatterHelper.verifyAll();
            }));
            break;
          }

        case types_2.ProductType.Linter:
          {
            test(`Ensure path is returned for ${product.name} (${resource ? 'With a resource' : 'without a resource'})`, () => __awaiter(void 0, void 0, void 0, function* () {
              const productPathService = new productPath_1.LinterProductPathService(serviceContainer.object);
              const linterManager = TypeMoq.Mock.ofType();
              const linterInfo = TypeMoq.Mock.ofType();
              const expectedPath = 'Some Path';
              serviceContainer.setup(s => s.get(TypeMoq.It.isValue(types_4.ILinterManager), TypeMoq.It.isAny())).returns(() => linterManager.object);
              linterInfo.setup(l => l.pathName(TypeMoq.It.isValue(resource))).returns(() => expectedPath).verifiable(TypeMoq.Times.once());
              linterManager.setup(l => l.getLinterInfo(TypeMoq.It.isValue(product.value))).returns(() => linterInfo.object).verifiable(TypeMoq.Times.once());
              const value = productPathService.getExecutableNameFromSettings(product.value, resource);
              chai_1.expect(value).to.be.equal(expectedPath);
              linterInfo.verifyAll();
              linterManager.verifyAll();
            }));
          }

        case types_2.ProductType.RefactoringLibrary:
          {
            test(`Ensure path is returned for ${product.name} (${resource ? 'With a resource' : 'without a resource'})`, () => __awaiter(void 0, void 0, void 0, function* () {
              const productPathService = new productPath_1.RefactoringLibraryProductPathService(serviceContainer.object);
              const value = productPathService.getExecutableNameFromSettings(product.value, resource);
              const moduleName = productInstaller.translateProductToModuleName(product.value, types_2.ModuleNamePurpose.run);
              chai_1.expect(value).to.be.equal(moduleName);
            }));
            break;
          }

        case types_2.ProductType.WorkspaceSymbols:
          {
            test(`Ensure path is returned for ${product.name} (${resource ? 'With a resource' : 'without a resource'})`, () => __awaiter(void 0, void 0, void 0, function* () {
              const productPathService = new productPath_1.CTagsProductPathService(serviceContainer.object);
              const expectedPath = 'Some Path';
              workspaceSymnbolSettings.setup(w => w.ctagsPath).returns(() => expectedPath).verifiable(TypeMoq.Times.atLeastOnce());
              const value = productPathService.getExecutableNameFromSettings(product.value, resource);
              chai_1.expect(value).to.be.equal(expectedPath);
              workspaceSymnbolSettings.verifyAll();
            }));
            break;
          }

        case types_2.ProductType.TestFramework:
          {
            test(`Ensure path is returned for ${product.name} (${resource ? 'With a resource' : 'without a resource'})`, () => __awaiter(void 0, void 0, void 0, function* () {
              const productPathService = new productPath_1.TestFrameworkProductPathService(serviceContainer.object);
              const testHelper = TypeMoq.Mock.ofType();
              const expectedPath = 'Some Path';
              serviceContainer.setup(s => s.get(TypeMoq.It.isValue(types_5.ITestsHelper), TypeMoq.It.isAny())).returns(() => testHelper.object);
              testHelper.setup(t => t.getSettingsPropertyNames(TypeMoq.It.isValue(product.value))).returns(() => {
                return {
                  argsName: 'autoTestDiscoverOnSaveEnabled',
                  enabledName: 'autoTestDiscoverOnSaveEnabled',
                  pathName: 'nosetestPath'
                };
              }).verifiable(TypeMoq.Times.once());
              unitTestSettings.setup(u => u.nosetestPath).returns(() => expectedPath).verifiable(TypeMoq.Times.atLeastOnce());
              const value = productPathService.getExecutableNameFromSettings(product.value, resource);
              chai_1.expect(value).to.be.equal(expectedPath);
              testHelper.verifyAll();
              unitTestSettings.verifyAll();
            }));
            test(`Ensure module name is returned for ${product.name} (${resource ? 'With a resource' : 'without a resource'})`, () => __awaiter(void 0, void 0, void 0, function* () {
              const productPathService = new productPath_1.TestFrameworkProductPathService(serviceContainer.object);
              const testHelper = TypeMoq.Mock.ofType();
              serviceContainer.setup(s => s.get(TypeMoq.It.isValue(types_5.ITestsHelper), TypeMoq.It.isAny())).returns(() => testHelper.object);
              testHelper.setup(t => t.getSettingsPropertyNames(TypeMoq.It.isValue(product.value))).returns(() => {
                return {
                  argsName: 'autoTestDiscoverOnSaveEnabled',
                  enabledName: 'autoTestDiscoverOnSaveEnabled',
                  pathName: undefined
                };
              }).verifiable(TypeMoq.Times.once());
              const value = productPathService.getExecutableNameFromSettings(product.value, resource);
              const moduleName = productInstaller.translateProductToModuleName(product.value, types_2.ModuleNamePurpose.run);
              chai_1.expect(value).to.be.equal(moduleName);
              testHelper.verifyAll();
            }));
            break;
          }

        default:
          {
            test(`No tests for Product Path of this Product Type ${product.name}`, () => {
              assert_1.fail('No tests for Product Path of this Product Type');
            });
          }
      }
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByb2R1Y3RQYXRoLnVuaXQudGVzdC5qcyJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInZhbHVlIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiY2hhaV8xIiwiY2hhaUFzUHJvbWlzZWQiLCJUeXBlTW9xIiwidnNjb2RlXzEiLCJwcm9kdWN0SW5zdGFsbGVyXzEiLCJwcm9kdWN0UGF0aF8xIiwicHJvZHVjdFNlcnZpY2VfMSIsInR5cGVzXzEiLCJ0eXBlc18yIiwiZW51bV8xIiwidHlwZXNfMyIsInR5cGVzXzQiLCJ0eXBlc181IiwidXNlIiwic3VpdGUiLCJ1bmRlZmluZWQiLCJVcmkiLCJmaWxlIiwiZm9yRWFjaCIsInJlc291cmNlIiwiZ2V0TmFtZXNBbmRWYWx1ZXMiLCJQcm9kdWN0IiwicHJvZHVjdCIsInNlcnZpY2VDb250YWluZXIiLCJmb3JtYXR0aW5nU2V0dGluZ3MiLCJ1bml0VGVzdFNldHRpbmdzIiwid29ya3NwYWNlU3ltbmJvbFNldHRpbmdzIiwiY29uZmlnU2VydmljZSIsInByb2R1Y3RJbnN0YWxsZXIiLCJzZXR1cCIsIk1vY2siLCJvZlR5cGUiLCJQcm9kdWN0SW5zdGFsbGVyIiwib2JqZWN0IiwicHl0aG9uU2V0dGluZ3MiLCJwIiwiZm9ybWF0dGluZyIsInJldHVybnMiLCJ1bml0VGVzdCIsIndvcmtzcGFjZVN5bWJvbHMiLCJzIiwiZ2V0U2V0dGluZ3MiLCJJdCIsImlzVmFsdWUiLCJnZXQiLCJJQ29uZmlndXJhdGlvblNlcnZpY2UiLCJpc0FueSIsIklJbnN0YWxsZXIiLCJjIiwiSVByb2R1Y3RTZXJ2aWNlIiwiUHJvZHVjdFNlcnZpY2UiLCJpc29ydCIsInByb2R1Y3RUeXBlIiwiZ2V0UHJvZHVjdFR5cGUiLCJQcm9kdWN0VHlwZSIsIkZvcm1hdHRlciIsInRlc3QiLCJuYW1lIiwicHJvZHVjdFBhdGhTZXJ2aWNlIiwiRm9ybWF0dGVyUHJvZHVjdFBhdGhTZXJ2aWNlIiwiZm9ybWF0dGVySGVscGVyIiwiZXhwZWN0ZWRQYXRoIiwiSUZvcm1hdHRlckhlbHBlciIsImYiLCJhdXRvcGVwOFBhdGgiLCJ2ZXJpZmlhYmxlIiwiVGltZXMiLCJhdExlYXN0T25jZSIsImdldFNldHRpbmdzUHJvcGVydHlOYW1lcyIsInBhdGhOYW1lIiwiYXJnc05hbWUiLCJvbmNlIiwiZ2V0RXhlY3V0YWJsZU5hbWVGcm9tU2V0dGluZ3MiLCJleHBlY3QiLCJ0byIsImJlIiwiZXF1YWwiLCJ2ZXJpZnlBbGwiLCJMaW50ZXIiLCJMaW50ZXJQcm9kdWN0UGF0aFNlcnZpY2UiLCJsaW50ZXJNYW5hZ2VyIiwibGludGVySW5mbyIsIklMaW50ZXJNYW5hZ2VyIiwibCIsImdldExpbnRlckluZm8iLCJSZWZhY3RvcmluZ0xpYnJhcnkiLCJSZWZhY3RvcmluZ0xpYnJhcnlQcm9kdWN0UGF0aFNlcnZpY2UiLCJtb2R1bGVOYW1lIiwidHJhbnNsYXRlUHJvZHVjdFRvTW9kdWxlTmFtZSIsIk1vZHVsZU5hbWVQdXJwb3NlIiwicnVuIiwiV29ya3NwYWNlU3ltYm9scyIsIkNUYWdzUHJvZHVjdFBhdGhTZXJ2aWNlIiwidyIsImN0YWdzUGF0aCIsIlRlc3RGcmFtZXdvcmsiLCJUZXN0RnJhbWV3b3JrUHJvZHVjdFBhdGhTZXJ2aWNlIiwidGVzdEhlbHBlciIsIklUZXN0c0hlbHBlciIsInQiLCJlbmFibGVkTmFtZSIsInUiLCJub3NldGVzdFBhdGgiLCJmYWlsIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsU0FBUyxHQUFJLFVBQVEsU0FBS0EsU0FBZCxJQUE0QixVQUFVQyxPQUFWLEVBQW1CQyxVQUFuQixFQUErQkMsQ0FBL0IsRUFB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Q0FDYSxNQUFNO0FBQ2YsdUJBQU87QUFDSGlDLGtCQUFBQSxRQUFRLEVBQUUsK0JBRFA7QUFFSDhCLGtCQUFBQSxXQUFXLEVBQUUsK0JBRlY7QUFHSC9CLGtCQUFBQSxRQUFRLEVBQUV0RDtBQUhQLGlCQUFQO0FBS0gsZUFQRCxFQVFLa0QsVUFSTCxDQVFnQi9ELE9BQU8sQ0FBQ2dFLEtBQVIsQ0FBY0ssSUFBZCxFQVJoQjtBQVNBLG9CQUFNckYsS0FBSyxHQUFHd0Usa0JBQWtCLENBQUNjLDZCQUFuQixDQUFpRGxELE9BQU8sQ0FBQ3BDLEtBQXpELEVBQWdFaUMsUUFBaEUsQ0FBZDtBQUNBLG9CQUFNb0UsVUFBVSxHQUFHM0QsZ0JBQWdCLENBQUM0RCw0QkFBakIsQ0FBOENsRSxPQUFPLENBQUNwQyxLQUF0RCxFQUE2RHNCLE9BQU8sQ0FBQ2lGLGlCQUFSLENBQTBCQyxHQUF2RixDQUFuQjtBQUNBMUYsY0FBQUEsTUFBTSxDQUFDeUUsTUFBUCxDQUFjdkYsS0FBZCxFQUFxQndGLEVBQXJCLENBQXdCQyxFQUF4QixDQUEyQkMsS0FBM0IsQ0FBaUNXLFVBQWpDO0FBQ0FVLGNBQUFBLFVBQVUsQ0FBQ3BCLFNBQVg7QUFDSCxhQWxCa0ksQ0FBL0gsQ0FBSjtBQW1CQTtBQUNIOztBQUNEO0FBQVM7QUFDTHJCLFlBQUFBLElBQUksQ0FBRSxrREFBaURsQyxPQUFPLENBQUNtQyxJQUFLLEVBQWhFLEVBQW1FLE1BQU07QUFDekUzRCxjQUFBQSxRQUFRLENBQUN5RyxJQUFULENBQWMsZ0RBQWQ7QUFDSCxhQUZHLENBQUo7QUFHSDtBQXJITDtBQXVISCxLQXJKRDtBQXNKSCxHQXZKRDtBQXdKSCxDQXpKSSxDQUFMIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHRzbGludDpkaXNhYmxlOm1heC1mdW5jLWJvZHktbGVuZ3RoIG5vLWludmFsaWQtdGhpc1xyXG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbmNvbnN0IGNoYWlfMSA9IHJlcXVpcmUoXCJjaGFpXCIpO1xyXG5jb25zdCBjaGFpQXNQcm9taXNlZCA9IHJlcXVpcmUoXCJjaGFpLWFzLXByb21pc2VkXCIpO1xyXG5jb25zdCBUeXBlTW9xID0gcmVxdWlyZShcInR5cGVtb3FcIik7XHJcbmNvbnN0IHZzY29kZV8xID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxucmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vZXh0ZW5zaW9uc1wiKTtcclxuY29uc3QgcHJvZHVjdEluc3RhbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vaW5zdGFsbGVyL3Byb2R1Y3RJbnN0YWxsZXJcIik7XHJcbmNvbnN0IHByb2R1Y3RQYXRoXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi9pbnN0YWxsZXIvcHJvZHVjdFBhdGhcIik7XHJcbmNvbnN0IHByb2R1Y3RTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi9pbnN0YWxsZXIvcHJvZHVjdFNlcnZpY2VcIik7XHJcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi9pbnN0YWxsZXIvdHlwZXNcIik7XHJcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2NvbW1vbi90eXBlc1wiKTtcclxuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9jb21tb24vdXRpbHMvZW51bVwiKTtcclxuY29uc3QgdHlwZXNfMyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvZm9ybWF0dGVycy90eXBlc1wiKTtcclxuY29uc3QgdHlwZXNfNCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvbGludGVycy90eXBlc1wiKTtcclxuY29uc3QgdHlwZXNfNSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvdW5pdHRlc3RzL2NvbW1vbi90eXBlc1wiKTtcclxuY2hhaV8xLnVzZShjaGFpQXNQcm9taXNlZCk7XHJcbnN1aXRlKCdQcm9kdWN0IFBhdGgnLCAoKSA9PiB7XHJcbiAgICBbdW5kZWZpbmVkLCB2c2NvZGVfMS5VcmkuZmlsZSgncmVzb3VyY2UnKV0uZm9yRWFjaChyZXNvdXJjZSA9PiB7XHJcbiAgICAgICAgZW51bV8xLmdldE5hbWVzQW5kVmFsdWVzKHR5cGVzXzIuUHJvZHVjdCkuZm9yRWFjaChwcm9kdWN0ID0+IHtcclxuICAgICAgICAgICAgbGV0IHNlcnZpY2VDb250YWluZXI7XHJcbiAgICAgICAgICAgIGxldCBmb3JtYXR0aW5nU2V0dGluZ3M7XHJcbiAgICAgICAgICAgIGxldCB1bml0VGVzdFNldHRpbmdzO1xyXG4gICAgICAgICAgICBsZXQgd29ya3NwYWNlU3ltbmJvbFNldHRpbmdzO1xyXG4gICAgICAgICAgICBsZXQgY29uZmlnU2VydmljZTtcclxuICAgICAgICAgICAgbGV0IHByb2R1Y3RJbnN0YWxsZXI7XHJcbiAgICAgICAgICAgIHNldHVwKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNlcnZpY2VDb250YWluZXIgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25maWdTZXJ2aWNlID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGluZ1NldHRpbmdzID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgdW5pdFRlc3RTZXR0aW5ncyA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICAgICAgICAgIHdvcmtzcGFjZVN5bW5ib2xTZXR0aW5ncyA9IFR5cGVNb3EuTW9jay5vZlR5cGUoKTtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3RJbnN0YWxsZXIgPSBuZXcgcHJvZHVjdEluc3RhbGxlcl8xLlByb2R1Y3RJbnN0YWxsZXIoc2VydmljZUNvbnRhaW5lci5vYmplY3QsIFR5cGVNb3EuTW9jay5vZlR5cGUoKS5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHl0aG9uU2V0dGluZ3MgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBweXRob25TZXR0aW5ncy5zZXR1cChwID0+IHAuZm9ybWF0dGluZykucmV0dXJucygoKSA9PiBmb3JtYXR0aW5nU2V0dGluZ3Mub2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIHB5dGhvblNldHRpbmdzLnNldHVwKHAgPT4gcC51bml0VGVzdCkucmV0dXJucygoKSA9PiB1bml0VGVzdFNldHRpbmdzLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBweXRob25TZXR0aW5ncy5zZXR1cChwID0+IHAud29ya3NwYWNlU3ltYm9scykucmV0dXJucygoKSA9PiB3b3Jrc3BhY2VTeW1uYm9sU2V0dGluZ3Mub2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIGNvbmZpZ1NlcnZpY2Uuc2V0dXAocyA9PiBzLmdldFNldHRpbmdzKFR5cGVNb3EuSXQuaXNWYWx1ZShyZXNvdXJjZSkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXR1cm5zKCgpID0+IHB5dGhvblNldHRpbmdzLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZXJ2aWNlQ29udGFpbmVyLnNldHVwKHMgPT4gcy5nZXQoVHlwZU1vcS5JdC5pc1ZhbHVlKHR5cGVzXzIuSUNvbmZpZ3VyYXRpb25TZXJ2aWNlKSwgVHlwZU1vcS5JdC5pc0FueSgpKSlcclxuICAgICAgICAgICAgICAgICAgICAucmV0dXJucygoKSA9PiBjb25maWdTZXJ2aWNlLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZXJ2aWNlQ29udGFpbmVyLnNldHVwKHMgPT4gcy5nZXQoVHlwZU1vcS5JdC5pc1ZhbHVlKHR5cGVzXzIuSUluc3RhbGxlciksIFR5cGVNb3EuSXQuaXNBbnkoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJldHVybnMoKCkgPT4gcHJvZHVjdEluc3RhbGxlcik7XHJcbiAgICAgICAgICAgICAgICBzZXJ2aWNlQ29udGFpbmVyLnNldHVwKGMgPT4gYy5nZXQoVHlwZU1vcS5JdC5pc1ZhbHVlKHR5cGVzXzEuSVByb2R1Y3RTZXJ2aWNlKSwgVHlwZU1vcS5JdC5pc0FueSgpKSkucmV0dXJucygoKSA9PiBuZXcgcHJvZHVjdFNlcnZpY2VfMS5Qcm9kdWN0U2VydmljZSgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9kdWN0LnZhbHVlID09PSB0eXBlc18yLlByb2R1Y3QuaXNvcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VHlwZSA9IG5ldyBwcm9kdWN0U2VydmljZV8xLlByb2R1Y3RTZXJ2aWNlKCkuZ2V0UHJvZHVjdFR5cGUocHJvZHVjdC52YWx1ZSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocHJvZHVjdFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMi5Qcm9kdWN0VHlwZS5Gb3JtYXR0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0KGBFbnN1cmUgcGF0aCBpcyByZXR1cm5lZCBmb3IgJHtwcm9kdWN0Lm5hbWV9ICgke3Jlc291cmNlID8gJ1dpdGggYSByZXNvdXJjZScgOiAnd2l0aG91dCBhIHJlc291cmNlJ30pYCwgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0UGF0aFNlcnZpY2UgPSBuZXcgcHJvZHVjdFBhdGhfMS5Gb3JtYXR0ZXJQcm9kdWN0UGF0aFNlcnZpY2Uoc2VydmljZUNvbnRhaW5lci5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXJIZWxwZXIgPSBUeXBlTW9xLk1vY2sub2ZUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkUGF0aCA9ICdTb21lIFBhdGgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlQ29udGFpbmVyLnNldHVwKHMgPT4gcy5nZXQoVHlwZU1vcS5JdC5pc1ZhbHVlKHR5cGVzXzMuSUZvcm1hdHRlckhlbHBlciksIFR5cGVNb3EuSXQuaXNBbnkoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV0dXJucygoKSA9PiBmb3JtYXR0ZXJIZWxwZXIub2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZ1NldHRpbmdzLnNldHVwKGYgPT4gZi5hdXRvcGVwOFBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV0dXJucygoKSA9PiBleHBlY3RlZFBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmVyaWZpYWJsZShUeXBlTW9xLlRpbWVzLmF0TGVhc3RPbmNlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJIZWxwZXIuc2V0dXAoZiA9PiBmLmdldFNldHRpbmdzUHJvcGVydHlOYW1lcyhUeXBlTW9xLkl0LmlzVmFsdWUocHJvZHVjdC52YWx1ZSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldHVybnMoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoTmFtZTogJ2F1dG9wZXA4UGF0aCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc05hbWU6ICdhdXRvcGVwOEFyZ3MnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZlcmlmaWFibGUoVHlwZU1vcS5UaW1lcy5vbmNlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb2R1Y3RQYXRoU2VydmljZS5nZXRFeGVjdXRhYmxlTmFtZUZyb21TZXR0aW5ncyhwcm9kdWN0LnZhbHVlLCByZXNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFsdWUpLnRvLmJlLmVxdWFsKGV4cGVjdGVkUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmdTZXR0aW5ncy52ZXJpZnlBbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVySGVscGVyLnZlcmlmeUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMi5Qcm9kdWN0VHlwZS5MaW50ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0KGBFbnN1cmUgcGF0aCBpcyByZXR1cm5lZCBmb3IgJHtwcm9kdWN0Lm5hbWV9ICgke3Jlc291cmNlID8gJ1dpdGggYSByZXNvdXJjZScgOiAnd2l0aG91dCBhIHJlc291cmNlJ30pYCwgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0UGF0aFNlcnZpY2UgPSBuZXcgcHJvZHVjdFBhdGhfMS5MaW50ZXJQcm9kdWN0UGF0aFNlcnZpY2Uoc2VydmljZUNvbnRhaW5lci5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW50ZXJNYW5hZ2VyID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW50ZXJJbmZvID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZFBhdGggPSAnU29tZSBQYXRoJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmljZUNvbnRhaW5lci5zZXR1cChzID0+IHMuZ2V0KFR5cGVNb3EuSXQuaXNWYWx1ZSh0eXBlc180LklMaW50ZXJNYW5hZ2VyKSwgVHlwZU1vcS5JdC5pc0FueSgpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXR1cm5zKCgpID0+IGxpbnRlck1hbmFnZXIub2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGludGVySW5mby5zZXR1cChsID0+IGwucGF0aE5hbWUoVHlwZU1vcS5JdC5pc1ZhbHVlKHJlc291cmNlKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV0dXJucygoKSA9PiBleHBlY3RlZFBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmVyaWZpYWJsZShUeXBlTW9xLlRpbWVzLm9uY2UoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbnRlck1hbmFnZXIuc2V0dXAobCA9PiBsLmdldExpbnRlckluZm8oVHlwZU1vcS5JdC5pc1ZhbHVlKHByb2R1Y3QudmFsdWUpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXR1cm5zKCgpID0+IGxpbnRlckluZm8ub2JqZWN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZlcmlmaWFibGUoVHlwZU1vcS5UaW1lcy5vbmNlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb2R1Y3RQYXRoU2VydmljZS5nZXRFeGVjdXRhYmxlTmFtZUZyb21TZXR0aW5ncyhwcm9kdWN0LnZhbHVlLCByZXNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFsdWUpLnRvLmJlLmVxdWFsKGV4cGVjdGVkUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbnRlckluZm8udmVyaWZ5QWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbnRlck1hbmFnZXIudmVyaWZ5QWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlc18yLlByb2R1Y3RUeXBlLlJlZmFjdG9yaW5nTGlicmFyeToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3QoYEVuc3VyZSBwYXRoIGlzIHJldHVybmVkIGZvciAke3Byb2R1Y3QubmFtZX0gKCR7cmVzb3VyY2UgPyAnV2l0aCBhIHJlc291cmNlJyA6ICd3aXRob3V0IGEgcmVzb3VyY2UnfSlgLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RQYXRoU2VydmljZSA9IG5ldyBwcm9kdWN0UGF0aF8xLlJlZmFjdG9yaW5nTGlicmFyeVByb2R1Y3RQYXRoU2VydmljZShzZXJ2aWNlQ29udGFpbmVyLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvZHVjdFBhdGhTZXJ2aWNlLmdldEV4ZWN1dGFibGVOYW1lRnJvbVNldHRpbmdzKHByb2R1Y3QudmFsdWUsIHJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IHByb2R1Y3RJbnN0YWxsZXIudHJhbnNsYXRlUHJvZHVjdFRvTW9kdWxlTmFtZShwcm9kdWN0LnZhbHVlLCB0eXBlc18yLk1vZHVsZU5hbWVQdXJwb3NlLnJ1bik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFsdWUpLnRvLmJlLmVxdWFsKG1vZHVsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMi5Qcm9kdWN0VHlwZS5Xb3Jrc3BhY2VTeW1ib2xzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdChgRW5zdXJlIHBhdGggaXMgcmV0dXJuZWQgZm9yICR7cHJvZHVjdC5uYW1lfSAoJHtyZXNvdXJjZSA/ICdXaXRoIGEgcmVzb3VyY2UnIDogJ3dpdGhvdXQgYSByZXNvdXJjZSd9KWAsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjdFBhdGhTZXJ2aWNlID0gbmV3IHByb2R1Y3RQYXRoXzEuQ1RhZ3NQcm9kdWN0UGF0aFNlcnZpY2Uoc2VydmljZUNvbnRhaW5lci5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZFBhdGggPSAnU29tZSBQYXRoJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya3NwYWNlU3ltbmJvbFNldHRpbmdzLnNldHVwKHcgPT4gdy5jdGFnc1BhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV0dXJucygoKSA9PiBleHBlY3RlZFBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmVyaWZpYWJsZShUeXBlTW9xLlRpbWVzLmF0TGVhc3RPbmNlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb2R1Y3RQYXRoU2VydmljZS5nZXRFeGVjdXRhYmxlTmFtZUZyb21TZXR0aW5ncyhwcm9kdWN0LnZhbHVlLCByZXNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFsdWUpLnRvLmJlLmVxdWFsKGV4cGVjdGVkUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtzcGFjZVN5bW5ib2xTZXR0aW5ncy52ZXJpZnlBbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzIuUHJvZHVjdFR5cGUuVGVzdEZyYW1ld29yazoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3QoYEVuc3VyZSBwYXRoIGlzIHJldHVybmVkIGZvciAke3Byb2R1Y3QubmFtZX0gKCR7cmVzb3VyY2UgPyAnV2l0aCBhIHJlc291cmNlJyA6ICd3aXRob3V0IGEgcmVzb3VyY2UnfSlgLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RQYXRoU2VydmljZSA9IG5ldyBwcm9kdWN0UGF0aF8xLlRlc3RGcmFtZXdvcmtQcm9kdWN0UGF0aFNlcnZpY2Uoc2VydmljZUNvbnRhaW5lci5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SGVscGVyID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZFBhdGggPSAnU29tZSBQYXRoJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmljZUNvbnRhaW5lci5zZXR1cChzID0+IHMuZ2V0KFR5cGVNb3EuSXQuaXNWYWx1ZSh0eXBlc181LklUZXN0c0hlbHBlciksIFR5cGVNb3EuSXQuaXNBbnkoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV0dXJucygoKSA9PiB0ZXN0SGVscGVyLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RIZWxwZXIuc2V0dXAodCA9PiB0LmdldFNldHRpbmdzUHJvcGVydHlOYW1lcyhUeXBlTW9xLkl0LmlzVmFsdWUocHJvZHVjdC52YWx1ZSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldHVybnMoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzTmFtZTogJ2F1dG9UZXN0RGlzY292ZXJPblNhdmVFbmFibGVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkTmFtZTogJ2F1dG9UZXN0RGlzY292ZXJPblNhdmVFbmFibGVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoTmFtZTogJ25vc2V0ZXN0UGF0aCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmVyaWZpYWJsZShUeXBlTW9xLlRpbWVzLm9uY2UoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRUZXN0U2V0dGluZ3Muc2V0dXAodSA9PiB1Lm5vc2V0ZXN0UGF0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXR1cm5zKCgpID0+IGV4cGVjdGVkUGF0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52ZXJpZmlhYmxlKFR5cGVNb3EuVGltZXMuYXRMZWFzdE9uY2UoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvZHVjdFBhdGhTZXJ2aWNlLmdldEV4ZWN1dGFibGVOYW1lRnJvbVNldHRpbmdzKHByb2R1Y3QudmFsdWUsIHJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaV8xLmV4cGVjdCh2YWx1ZSkudG8uYmUuZXF1YWwoZXhwZWN0ZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdEhlbHBlci52ZXJpZnlBbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdFRlc3RTZXR0aW5ncy52ZXJpZnlBbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdChgRW5zdXJlIG1vZHVsZSBuYW1lIGlzIHJldHVybmVkIGZvciAke3Byb2R1Y3QubmFtZX0gKCR7cmVzb3VyY2UgPyAnV2l0aCBhIHJlc291cmNlJyA6ICd3aXRob3V0IGEgcmVzb3VyY2UnfSlgLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RQYXRoU2VydmljZSA9IG5ldyBwcm9kdWN0UGF0aF8xLlRlc3RGcmFtZXdvcmtQcm9kdWN0UGF0aFNlcnZpY2Uoc2VydmljZUNvbnRhaW5lci5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SGVscGVyID0gVHlwZU1vcS5Nb2NrLm9mVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlQ29udGFpbmVyLnNldHVwKHMgPT4gcy5nZXQoVHlwZU1vcS5JdC5pc1ZhbHVlKHR5cGVzXzUuSVRlc3RzSGVscGVyKSwgVHlwZU1vcS5JdC5pc0FueSgpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXR1cm5zKCgpID0+IHRlc3RIZWxwZXIub2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdEhlbHBlci5zZXR1cCh0ID0+IHQuZ2V0U2V0dGluZ3NQcm9wZXJ0eU5hbWVzKFR5cGVNb3EuSXQuaXNWYWx1ZShwcm9kdWN0LnZhbHVlKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV0dXJucygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NOYW1lOiAnYXV0b1Rlc3REaXNjb3Zlck9uU2F2ZUVuYWJsZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWROYW1lOiAnYXV0b1Rlc3REaXNjb3Zlck9uU2F2ZUVuYWJsZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhOYW1lOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmVyaWZpYWJsZShUeXBlTW9xLlRpbWVzLm9uY2UoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvZHVjdFBhdGhTZXJ2aWNlLmdldEV4ZWN1dGFibGVOYW1lRnJvbVNldHRpbmdzKHByb2R1Y3QudmFsdWUsIHJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IHByb2R1Y3RJbnN0YWxsZXIudHJhbnNsYXRlUHJvZHVjdFRvTW9kdWxlTmFtZShwcm9kdWN0LnZhbHVlLCB0eXBlc18yLk1vZHVsZU5hbWVQdXJwb3NlLnJ1bik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlfMS5leHBlY3QodmFsdWUpLnRvLmJlLmVxdWFsKG1vZHVsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXN0SGVscGVyLnZlcmlmeUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0KGBObyB0ZXN0cyBmb3IgUHJvZHVjdCBQYXRoIG9mIHRoaXMgUHJvZHVjdCBUeXBlICR7cHJvZHVjdC5uYW1lfWAsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0XzEuZmFpbCgnTm8gdGVzdHMgZm9yIFByb2R1Y3QgUGF0aCBvZiB0aGlzIFByb2R1Y3QgVHlwZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2R1Y3RQYXRoLnVuaXQudGVzdC5qcy5tYXAiXX0=